{"version":3,"sources":["xlsform-simple-schema/functions/odk-formulas/evaluation/XPath.ts","xlsform-simple-schema/types/Errors.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/types.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/InfixParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PrefixParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/Parser.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/NameExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/OperatorExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/BinaryOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/CallExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/CallParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/ConditionalExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/ConditionalParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/GroupParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/NameParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/PostfixExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PostfixOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/PrefixExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PrefixOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/index.ts","components/HighlightedExpression/StyledCode.tsx","xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext.ts","lib/ODKSurveyContext.ts","components/DarkModeContainer.tsx","lib/colors.ts","xlsform-simple-schema/functions/editing/createLocalizedString.tsx","xlsform-simple-schema/types/getEmptyNode.ts","lib/ODKNodeContext.ts","xlsform-simple-schema/field-types/fieldTypesToIcons.tsx","xlsform-simple-schema/field-types/internalFieldTypes.ts","xlsform-simple-schema/types/ODKNode.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaLexer.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/LiteralExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/LiteralParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/SelectorExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/SelectorParselet.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaPrecedence.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaParser.ts","xlsform-simple-schema/types/RowSchemas.ts","xlsform-simple-schema/types/RowTypes.ts","xlsform-simple-schema/types/AppearanceAttributeFlags.ts","xlsform-simple-schema/functions/nestSurvey.ts","xlsform-simple-schema/types/XLSForm.ts","xlsform-simple-schema/functions/loadSurveyFromXLSX.ts","xlsform-simple-schema/functions/editing/findOrReplaceFieldReferences.ts","xlsform-simple-schema/functions/getFirstColumnNameWithError.tsx","xlsform-simple-schema/types/assertIsODKNode.tsx","survey/useNodeDragAndDrop.tsx","components/Markdown.tsx","components/unindent.ts","components/StyledMarkdown.tsx","xlsform-simple-schema/functions/odk-formulas/evaluation/createLiteralExpressionFromValue.ts","survey/FieldPopoverButton/DefaultValueExplanation.tsx","survey/FieldPopoverButton/FormulaResultMeaning.tsx","survey/FieldPopoverButton/ExpressionPanel.tsx","survey/FieldPopoverButton/FieldPathBreadcrumbs.tsx","xlsform-simple-schema/field-types/fieldTypeNames.tsx","survey/FieldPopoverButton/ChoiceListMenu.tsx","xlsform-simple-schema/functions/editing/spliceRowsInWorksheet.ts","xlsform-simple-schema/functions/editing/addExampleChoices.tsx","xlsform-simple-schema/field-types/fieldCategoriesToIcons.tsx","xlsform-simple-schema/field-types/fieldCategoryNames.tsx","xlsform-simple-schema/field-types/fieldTypesToCategories.tsx","survey/FieldPopoverButton/FieldTypeMenu.tsx","survey/FieldPopoverButton/SetFieldTypeMenu.tsx","lib/undo/mergeCommands.tsx","survey/FieldPopoverButton/FieldTypeButtonGroup.tsx","survey/FieldPopoverButton/NoChoicesState.tsx","toaster.ts","survey/FieldPopoverButton/NodeReferencesMenu.tsx","survey/AddFieldMenuItem.tsx","survey/FieldPopoverButton/NodeActionMenuItems.tsx","lib/useNodeDeletionDialog.tsx","lib/useRenameNodeDialog.tsx","survey/FieldPopoverButton/FieldPopoverButton.tsx","components/HighlightedExpression/ObjectLiteral.tsx","components/HighlightedExpression/TokenElement.tsx","components/HighlightedExpression/InvalidExpression.tsx","components/HighlightedExpression/HighlightedODKExpression.tsx","code/ResultCodeTree.tsx","components/ExcelFileInput.tsx","components/AppEmptyState.tsx","lib/undo/UndoContext.ts","lib/undo/createUndoHistoryContext.ts","components/EditMenuButton.tsx","xlsform-simple-schema/functions/editing/saveXLSForm.tsx","components/FileMenuButton.tsx","components/LanguageSelector.tsx","components/OverflowScrollContainer.tsx","components/useViewOptionsButton.tsx","xlsform-simple-schema/functions/getLastRowIndexOfNode.ts","xlsform-simple-schema/functions/editing/createUntitledFieldRow.tsx","xlsform-simple-schema/functions/editing/createUntitledGroupRows.tsx","xlsform-simple-schema/functions/editing/addNodeToXLSForm.tsx","xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaFunctions.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateExpression.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateODKFormula.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeColumn.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeAndChildren.ts","xlsform-simple-schema/types/describeNode.tsx","lib/useChangeHooks.tsx","xlsform-simple-schema/functions/editing/patchXLSFormCell.ts","xlsform-simple-schema/functions/editing/removeNodeAndChildren.tsx","xlsform-simple-schema/functions/editing/renameNode.tsx","xlsform-simple-schema/functions/editing/nestNode.tsx","xlsform-simple-schema/functions/editing/ungroupNode.tsx","xlsform-simple-schema/functions/editing/moveNode.tsx","survey/fields/EditableSurveyTitle.tsx","survey/NoSurveyFieldsState.tsx","components/ErrorBoundary.tsx","survey/fields/BooleanField.tsx","survey/fields/CalculateField.tsx","xlsform-simple-schema/functions/schema-creation/getAllowedChoiceValues.ts","xlsform-simple-schema/functions/schema-creation/evaluateDynamicChoiceListName.ts","xlsform-simple-schema/functions/schema-creation/evaluateFilteredChoiceNames.ts","survey/fields/CheckboxGroupField.tsx","survey/fields/DateField.tsx","survey/fields/EditableFieldHint.tsx","survey/fields/EditableFieldLabel.tsx","lib/images/ImageResizer.ts","lib/images/uploadPhoto.ts","survey/fields/FileUploadField.tsx","xlsform-simple-schema/functions/schema-creation/geometry/SchemaOrgGeometry.ts","survey/fields/GeoPointField.tsx","survey/fields/NumberField.tsx","survey/fields/RadioGroupField.tsx","survey/fields/TextField.tsx","survey/fields/AnyValueField.tsx","survey/fields/FieldGroup.tsx","survey/fields/RepeatField.tsx","survey/SurveyField.tsx","survey/XLSFormSurvey.tsx","table/XLSFormWorksheet.tsx","table/XLSFormWorkbook.tsx","xlsform-simple-schema/functions/schema-creation/getNodeOptionalFunction.ts","xlsform-simple-schema/functions/schema-creation/getStringInterpolationFunctionOrString.ts","xlsform-simple-schema/functions/schema-creation/getQuantitativeValueSchema.ts","xlsform-simple-schema/functions/schema-creation/MediaSchemas.ts","xlsform-simple-schema/functions/schema-creation/questionTypesToSchemaGenerators.ts","xlsform-simple-schema/functions/schema-creation/createRecursiveNodeSchemaDefinition.ts","xlsform-simple-schema/functions/schema-creation/createLeafNodeSchemaDefinition.ts","App.tsx","lib/undo/useUndoHistory.ts","xlsform-simple-schema/functions/schema-creation/createSurveySchemaFromXLSForm.ts","lib/useGlobalHotkeys.tsx","reportWebVitals.ts","index.tsx"],"names":["findNodeByNameInsideScope","name","context","scope","survey","row","children","length","i","childScope","foundChild","findNodeByNameInCurrentAndAncestorScopes","child","stack","getAncestors","parentScope","findNodeByPathRelativeToScope","pathComponents","result","pathComponent","Error","slice","getReverseNodeAbsolutePath","node","rowIndex","getNodeAbsolutePath","reverse","getNodeAbsolutePathString","delimiter","join","getScopedNodeIndexPath","isEqual","push","childNode","foundStack","undefined","pop","getNodeIndexPath","getScopedAncestors","TokenType","ODKFormulaError","token","this","message","EvaluationError","type","expression","underlyingEvaluationError","nodeStack","ancestors","ParseError","tokens","LexerError","SyntaxError","SemanticError","FunctionNotImplementedError","functionName","InfixParselet","PrefixParselet","LEFT_PAREN","RIGHT_PAREN","COMMA","ASSIGN","PLUS","MINUS","ASTERISK","GREATER_THAN","LESS_THAN","BOOLEAN_AND","BOOLEAN_OR","SLASH","CARET","TILDE","BANG","MODULO","COMPARISON","BACKSLASH","QUESTION","COLON","SINGLE_QUOTE","DOUBLE_QUOTE","NAME","LITERAL","NUMBER_LITERAL","INT_LITERAL","FLOAT_LITERAL","STRING_LITERAL","BOOLEAN_LITERAL","WHITESPACE","UNKNOWN","EOF","INVALID","punctuator","tokenType","Expression","kind","Parser","options","readTokens","prefixParselets","Map","infixParselets","parselet","set","precedence","consumeAnything","prefix","get","text","left","parse","getPrecedence","infix","onExpression","expected","lookAhead","shift","distance","nextToken","next","value","onToken","parser","NameExpression","builder","OperatorExpression","operatorToken","right","print","BinaryOperatorParselet","isRight","parseExpression","CallExpression","fn","leftParenToken","argsAndDelimiters","rightParenToken","args","filter","e","CallParselet","rightParenTokenType","argumentDelimiterTokenType","match","delimiterToken","arg","consume","ConditionalExpression","condition","questionMarkToken","thenArm","colonToken","elseArm","ConditionalParselet","GroupParselet","NameParselet","getName","t","_parser","PostfixExpression","PostfixOperatorParselet","PrefixExpression","PrefixOperatorParselet","PrattParser","StyledCode","styled","code","Colors","RED2","VIOLET5","BLUE3","ORANGE3","ORANGE4","GRAY1","BLUE2","RED5","VERMILION3","VERMILION2","knownLiteralsWithoutDollarSign","yes","no","TRUE","FALSE","true","false","getEmptyEvaluationContext","typeParameters","label","indentationLevel","nodesToAnswers","evaluationResults","stackDepth","ODKSurveyContext","React","schema","SimpleSchema","debug","xlsForm","evaluationContext","language","languageCode","languageName","setEvaluationContext","setXLSFormWithPatches","onChangeAnswer","onChangeCell","onMoveNode","onSpliceRows","onRemoveRowAndChildren","onRenameNode","onNestNode","onUngroupNode","onAddNode","getDarkModeSetting","window","matchMedia","matches","DarkModeContainer","props","isDarkMode","useDarkMode","className","setIsDarkMode","handleChange","addEventListener","alpha","color","alphaColor","rgb","opacity","toString","createLocalizedString","languages","forEach","lang","ODKNodeContext","Set","Object","freeze","fieldTypesToIcons","integer","decimal","range","select_one","select_one_from_file","select_multiple","select_multiple_from_file","rank","note","geopoint","geotrace","geoshape","date","time","datetime","image","audio","video","file","barcode","calculate","acknowledge","hidden","start","end","today","deviceid","simserial","subscriberid","phonenumber","username","email","audit","begin_group","begin_repeat","internalFieldTypes","evaluatableColumnNames","isNodeRelevant","isRelevantEvaluationResult","isGroupNode","WHITESPACES","tokenPatterns","SELECTOR","ODKFormulaLexer","index","includes","tokenPattern","regex","substr","errorToken","INTERNAL_LEXER_ERROR","LiteralExpression","String","LiteralParselet","getValue","getType","SelectorExpression","selectorToken","selector","SelectorParselet","getSelector","ODKFormulaPrecedence","BOOLEAN_OP","CONDITIONAL","ASSIGNMENT","SUM","PRODUCT","EXPONENT","PREFIX","POSTFIX","CALL","ODKFormulaParser","expressions","register","startsWith","split","parseFloat","parseInt","Precedence","infixRight","infixLeft","getStringMapSchemaDefinition","schemaDefinition","blackbox","custom","keys","getLocalizedStringSchemaDefinition","optionalLocalizedString","optional","optionalStringMap","formulaValidationFunction","lexer","addValidationErrors","key","questionRowSchema","field","error","ErrorTypes","REQUIRED","operator","isSet","constraint","constraint_message","hint","guidance_hint","required_message","relevant","choice_filter","calculation","trigger","readonly","required","parameters","repeat_count","appearance","default","instance","bind","body","choiceRowSchema","settingsRowSchema","form_title","form_id","public_key","submission_url","default_language","version","assertValidQuestionRow","validate","appearanceAttributeFlags","multiline","minimal","quick","year","horizontal","likert","compact","quickcompact","signature","draw","parseAttributeFlags","attributeListString","attributeStrings","s","assertNoEndMarker","loadChoices","worksheet","map","rows","listName","list","loadXLSFormFromRows","defaultLanguage","settings","choices","flatNodes","worksheets","rootSurveyGroup","formRootNameFromSettings","titleFromSettings","onRow","root","normalizeType","trim","lastOpenedGroup","newGroupNode","newChildNode","nestSurvey","choicesByName","localizableColumnNames","nestDoubleColonFields","namespacePrefixes","defaultSuffix","foundSuffixes","k","add","namespacePrefix","suffix","objectToExtend","normalizeColumnNames","headerRow","columnName","replace","autoCleanOptions","getAutoValues","trimStrings","mutate","loadQuestionRow","cleanRow","clean","loadChoicesRow","assertValidChoiceRow","loadSettingsRow","assertValidSettingsRow","loadWorksheet","workbook","sheetName","loadRowFn","excelWorksheet","getWorksheet","firstRow","getRows","values","Array","columnNames","cellValue","columnNamesNormalized","columnNamesToTrues","findLanguagesInColumnNames","eachRow","rowRawData","columnIndex","rowDataWithNamespacedFields","JSON","stringify","details","loadExcelRow","loadFormFromExcelWorkbook","a","findOrReplaceFieldReferences","replaceName","oldName","nodeDependency","variableRegexp","RegExp","n","localizableKeys","flatMap","lcn","concat","newCellValue","replaceAll","cloneDeep","getFirstColumnNameWithError","nodeEvaluationResults","find","assertIsODKNode","every","p","resultIsInvalid","ODKNodeDragAndDropContext","onDropNode","MarkdownDiv","intent","html","marked","input","firstLineWithContent","line","matchedIndentation","matchedIndentationString","indentationRegExp","unindent","inline","omit","dangerouslySetInnerHTML","__html","Markdown","StyledMarkdown","createLiteralExpressionFromValue","DefaultValueExplanation","answer","nodeName","Classes","TEXT_MUTED","FormulaResultMeaning","results","formulaIsTrivial","ExpressionPanel","nodeEvaluationResult","style","cellIsEmpty","isLiteral","isName","title","icon","StyledPanel","backgroundColor","LIGHT_GRAY5","marginTop","padding","background","borderTop","DARK_GRAY2","LIGHT_GRAY3","StyledCodeBlock","fontSize","lineHeight","HighlightedExpression","state","StyledCalloutWithCode","toMarkdown","FieldPathBreadcrumbs","path","width","items","href","collapseFrom","overflowListProps","minVisibleItems","transition","fieldTypeNames","ChoiceListMenu","choiceListsByName","choiceListNames","onChange","event","checked","currentTarget","choiceListName","without","newTypeValue","newRow","description","numberOfRowsToRemove","rowsToAdd","margin","vertical","isSelected","nameElement","choiceNamesToRows","choiceNames","sortedChoiceRows","sortBy","r","toLowerCase","shownChoices","marginInline","restElement","UI_TEXT","marginLeft","paddingRight","aria-label","shownLabel","fill","display","LIST_UNSTYLED","justifyContent","large","disabled","spliceRowsInWorksheet","worksheetName","operations","surveyWorksheet","newRows","splice","newWorksheet","produceWithPatches","draft","addExampleChoices","fieldCategoriesToIcons","literal","choice","geo","media","stats","track","special","grouping","fieldCategoryNames","fieldTypesToCategories","FieldTypeMenu","onSelectType","header","onClick","dataset","c","category","data-type","SetFieldTypeMenu","commands","reduce","prev","current","FieldTypeButtonGroup","showType","isGroup","surveyHasChoiceLists","choiceListMenu","noChoicesAvailable","onAddExampleChoices","addExampleChoicesButton","action","NoChoicesState","typeName","hasItems","alignSelf","content","lazy","observeParents","Boundary","END","visibleItemRenderer","overflowRenderer","overflowItems","maxWidth","AppToaster","Toaster","create","position","Position","BOTTOM_RIGHT","NodeReferencesMenu","references","reference","AddFieldOrGroupMenuItem","group","omitAction","useContext","caption","addFieldWithType","useCallback","fieldType","addGroupedTextField","NodeActionMenuItems","renameText","nodeHasHint","renameNode","addHintToNode","nestNode","ungroupNode","removeNode","useNodeActionMenuItems","useState","isAlertOpen","setAlertOpen","closeAlert","show","showRemoveConfirmationDialog","alert","cancelButtonText","confirmButtonText","Intent","DANGER","isOpen","onCancel","onConfirm","canOutsideClickCancel","canEscapeKeyCancel","useNodeDeletionDialog","nodeDeletionAlert","isDialogOpen","setDialogOpen","newName","setNewName","nodeDependencies","setNodeDependencies","useEffect","changeName","closeDialog","preventDefault","showRenameDialog","dependenciesInfo","dialog","canOutsideClickClose","canEscapeKeyClose","isCloseButtonShown","onClose","onSubmit","DIALOG_BODY","labelFor","id","placeholder","defaultValue","pattern","autoFocus","DIALOG_FOOTER","DIALOG_FOOTER_ACTIONS","PRIMARY","useRenameNodeDialog","renameDialog","nodeActionDialogs","removeHintFromNode","nodeActionMenuItems","Code","div","Callout","DragStripe","RenderTarget","detailsButtonCaption","hasTypeIcon","isVisible","hasMissingParameters","hasError","isDraggedOver","setIsDraggedOver","dragProps","onDragStart","dataTransfer","setData","sourceNode","sourcePath","onDragOver","onDrop","data","getData","console","log","destinationNode","draggable","onDragLeave","useNodeDragAndDrop","violetColor","VIOLET3","flex","overflow","small","rightIcon","Boolean","htmlTitle","FieldPopoverButton","editable","nameOfOnlyShownTab","firstColumnNameWithError","firstColumnNameWithContent","setWidth","handleResize","entries","setTimeout","newWidth","contentRect","Math","abs","tabId","setTabId","referencesButton","referencesButtonTitle","ReferencesButton","editHeader","marginBottom","borderBottom","gap","FLEX_EXPANDER","placement","detailsContent","onResize","selectedTabId","renderActiveTabPanelOnly","panel","getTab","Provider","interactionKind","popoverClassName","PopoverClasses","POPOVER2_CONTENT_SIZING","rootBoundary","onOpening","modifiers","arrow","enabled","preventOverflow","targetTagName","buttonStyle","button","BLUE4","BLUE1","ObjectLiteralButtonWithPopover","object","isDate","Date","inspector","expandLevel","theme","chromeLight","TREENODE_FONT_FAMILY","TREENODE_FONT_SIZE","TREENODE_LINE_HEIGHT","BASE_FONT_SIZE","BASE_LINE_HEIGHT","OBJECT_NAME_COLOR","OBJECT_VALUE_NULL_COLOR","RED4","OBJECT_VALUE_UNDEFINED_COLOR","OBJECT_VALUE_REGEXP_COLOR","OBJECT_VALUE_STRING_COLOR","OBJECT_VALUE_SYMBOL_COLOR","OBJECT_VALUE_NUMBER_COLOR","OBJECT_VALUE_BOOLEAN_COLOR","OBJECT_VALUE_FUNCTION_PREFIX_COLOR","FunctionCallTokenElement","target","VariableReferenceTokenElement","referencedNode","data-referenced-node","TokenElement","parentExpression","isObject","InvalidExpression","lastToken","indexAfterLastToken","TEXT_DISABLED","isErroneousExpression","expressionOrToken","SecondaryLabel","keysWithErrors","calculationResults","getNodeTree","transform","childNodes","nodeData","ResultCodeTree","isExpanded","hasCaret","secondaryLabel","contents","ExcelFileInput","onFileChange","useWorkbookFromFile","onInputChange","setLanguage","onLoadWorkbook","files","wb","ExcelJS","reader","FileReader","readAsArrayBuffer","onload","buffer","ArrayBuffer","xlsx","load","then","AppEmptyState","fileInput","loadEmptyXLSForm","emptyWorkbook","addWorksheet","settingsWorksheet","addRow","nonIdealStateActions","UndoContext","undoHistory","setDocumentWithPatches","undo","redo","gotoIndex","document","EditMenuButton","undoContext","lastCommand","lastCommandDescription","nextCommand","nextCommandDescription","menu","command","active","saveXLSForm","modified","created","creator","internalWorksheet","cn","columns","addRows","model","writeBuffer","blob","Blob","createElement","appendChild","url","URL","createObjectURL","download","click","revokeObjectURL","removeChild","FileMenuButton","inputFieldRef","createRef","closeFile","saveFileAs","htmlFor","ref","LanguageSelect","Select","ofType","renderItem","handleClick","shouldDismissPopover","LanguageSelector","onItemSelect","itemRenderer","activeItem","noResults","filterable","OverflowScrollContainer","defaultViewOptions","table","json","getLastRowIndexOfNode","findIndex","untitledFieldIndex","untitledGroupIndex","createEmptyGroupRows","beginMarkerRow","endMarkerRow","addNodeToXLSForm","createEmptyFieldRow","rowsToInsert","currentNodeIsGroup","after","before","inside","assertString","argNo","number","ordinalize","assertNumber","assertBoolean","functions","if","elseExpression","not","coalesce","arg2","boolean","_xpath","once","_expression","selected","space_delimited_array","string","_space_delimited_array","_n","_multi_select_question","_choice_name","_select_question","_name","_group","_i","_sub_grp","_sub_i","_sub_sub_grp","_sub_sub_i","count","_nodeset","sum","max","min","contains","substring","endsWith","_string","_target","translate","_fromchars","_tochars","_separator","round","places","int","floor","Number","NaN","digest","_data","_algorithm","_encodingMethod","pow","exponent","log10","sin","cos","tan","asin","acos","atan","atan2","y","x","sqrt","exp","exp10","pi","PI","now","setHours","toISOString","_dateTime","_days","_time","_date","_format","area","_nodesetOrGeoshape","_nodesetOrGeoshapeOrGeotrace","random","randomize","_seed","uuid","_length","checklist","_min","_max","_response","evaluateExpression","deeperContext","evaluateLiteralExpression","evaluateNameExpression","evaluateNodeColumn","evaluateSelectorExpression","leftBeforeCasting","rightBeforeCasting","evaluateOperatorExpression","nameExpressionOrString","stringFromStringOrExpression","evaluatedArgs","apply","evaluateCallExpression","str","valueBeforeCasting","allowUndefinedNames","literalBag","nodeOrNodes","evaluationResult","evaluateNonDollarNameFn","tip","assertExpressionAfterEvaluation","evaluateODKFormula","formula","fallback","overrideFormula","originalFormula","fallbackValue","evaluateNodeAndChildren","onEval","fallbacks","getEvaluatedXLSFormResult","columnNamesToResults","describeNode","useChangeHooks","setContext","newContext","fieldProps","schemaKey","overrideLanguage","languageToUse","changeIsInSurveyWorksheet","valuePathInRow","indexPath","flat","has","normalizedColumnName","patchXLSFormCell","removeNodeAndChildren","previousState","finalNextState","finalPatches","finalInversePatches","nextState","patches","inversePatches","firstIndex","typeDescription","moveResult","onError","ancestor","numberOfSourceNodeRows","rowsOfSourceNode","destinationIsBeforeSource","moveNode","EditableSurveyTitle","surveyName","editedSurveyName","setEditedSurveyName","onChangeSurveyName","surveyTitleString","hasTitle","confirmOnEnterKey","TEXT_LARGE","minWidth","NoSurveyFieldsState","addNode","addGroup","actions","ErrorBoundary","info","BooleanField","labelElement","defaultChecked","CalculateField","surveyContext","editedFormula","setEditedFormula","shownValue","changeFormula","newFormula","fontFamily","WHITE","border","LIGHT_GRAY2","marginRight","getAllowedChoiceValues","choiceListStrings","availableListNames","choiceListString","evaluateDynamicChoiceListName","choiceObjects","o","choiceFilterString","choiceFilterFormula","choiceFilterExpression","choiceObject","choiceRow","evalResult","evaluateFilteredChoiceNames","CheckboxGroupField","valueIsInvalid","element","newChoices","delete","from","choiceLists","allowedValues","allowedValuesSet","choiceList","definedLabel","jsDateFormatter","formatDate","toLocaleDateString","parseDate","DateField","selectedDate","isUserChange","EditableFieldHint","editedHintString","setEditedHintString","onChangeHint","hintString","EditableFieldLabel","isEditable","labelString","evaluatedLabel","editedLabelString","setEditedLabelString","onConfirmLabel","labelInput","alignItems","DEFAULT_CONFIG","quality","maxHeight","autoRotate","mimeType","readAndCompressImage","userConfig","Promise","resolve","img","config","assign","src","fileReader","orientation","ExifReader","Orientation","err","scaleImage","canvas","height","exifApplied","findMaxWidth","getHalfScaleCanvas","scaleCanvasWithAlgorithm","reject","toBlob","ratio","mWidth","maxSize","scaleRatio","ctx","getContext","save","styleWidth","styleHeight","scale","rotate","drawImage","restore","outputWidth","scaledCanvas","srcImgData","getImageData","destImgData","createImageData","srcCanvasData","destCanvasData","inner","f00","f10","f01","f11","un_x","un_y","j","iyv","iy0","iy1","ixv","ix0","ix1","idxD","idxS00","idxS10","idxS01","idxS11","dx","dy","g","b","ceil","applyBilinearInterpolation","putImageData","halfCanvas","imageResizeConfig","uncachedBaseUrl","process","REACT_APP_ACCESSIBILITY_CLOUD_UNCACHED_BASE_URL","appToken","REACT_APP_ACCESSIBILITY_CLOUD_BASE_URL","REACT_APP_ACCESSIBILITY_CLOUD_APP_TOKEN","getImageSourceUrl","size","remotePath","surveyResultId","resizedImage","fetch","method","headers","Accept","response","ok","reason","success","ImageCard","contentUrl","onChangeCaption","onRemoveImage","interactive","elevation","Elevation","ONE","alt","boxShadow","outlined","FileUploadField","getUUID","Spinner","SIZE_SMALL","timeout","showUploadingState","contentSize","encodingFormat","createImageObjectFromFile","uploadPhoto","dimensions","thumbnail","createImageObjectFromRemoteImage","catch","showPersistentErrorToast","inputProps","multiple","accept","getSchemaOrgPointGeometrySchema","FieldContainer","section","MapContainer","CenteredPoint","FOREST3","getPointForCoordinates","coordinates","longitude","toFixed","latitude","getLatitudeFromValue","getLongitudeFromValue","GeoPointField","point","zoom","viewport","setViewport","onChangeAnswerDebounced","throttle","setViewportCallback","viewState","interactionState","newPoint","changeLatitude","newLatitudeNumber","newLatitudeString","changeLongitude","newLongitudeNumber","newLongitudeString","mapboxApiAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN","onViewportChange","mapStyle","DARK_GRAY4","positionOptions","enableHighAccuracy","trackUserLocation","showUserLocation","stepSize","minorStepSize","majorStepSize","asyncControl","onValueChange","NumberField","valueAsNumber","allowNumericCharactersOnly","RadioGroupField","selectedValue","choiceName","TextField","AutoField","FieldComponent","AnyValueField","isBoolean","checkbox","valueAsDate","radio","isInternalField","detailsButton","autoFieldProps","FieldGroup","subKeys","objectKeys","onChangeLabel","HeadingClass","H1","H2","H3","H4","H5","subkey","SurveyField","RepeatField","Stripe","CornerButton","TopCornerButton","BottomCornerButton","Hoverable","schemaKeyPath","nodeActionMenu","renderTarget","targetProps","hoverOpenDelay","hoverCloseDelay","PaddedContainer","FlexTable","Table","XLSFormWorksheet","numRows","uniq","onConfirmCellEdit","cellRenderer","paddingLeft","enableRowResizing","Container","XLSFormWorkbook","setWorksheetName","handleTabChange","getNodeOptionalFunction","getStringInterpolationFunctionOrString","inputString","offset","getQuantitativeValueSchema","rootDefinition","Text","oneOf","getMediaObjectSchema","regEx","RegEx","Url","getImageObjectSchema","withThumbnail","questionTypesToSchemaGenerators","Integer","getSchemaOrgLineStringGeometrySchema","getSchemaOrgPolygonGeometrySchema","getAudioObjectSchema","getVideoObjectSchema","EmailWithTLD","createRecursiveNodeSchemaDefinition","schemaDefinitions","definition","childrenSchemaDefinitions","defaults","schemaGeneratorFunction","firstField","createLeafNodeSchemaDefinition","FocusStyleManager","onlyShowFocusOnTabs","StyledXLSFormSurvey","isSurveyEmpty","noSurveyFieldsState","AppBody","App","setUndoHistory","newCommand","useUndoHistory","resultCodeElement","whiteSpace","viewOptions","setViewOptions","onDebugChange","onShowTableChange","onShowResultChange","viewMenuButton","Divider","useViewOptionsButton","changeHooks","useMemo","mergedSchema","createSurveySchemaFromXLSForm","hotkeys","combo","global","onKeyDown","allowInInput","useGlobalHotkeys","handleKeyDown","handleKeyUp","flexDirection","onKeyUp","Group","align","Alignment","RIGHT","DARK_GRAY5","DARK_GRAY1","zIndex","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","enableAllPlugins","enablePatches","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.25b82364.chunk.js","sourcesContent":["import { isEqual } from \"lodash\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\n\n/**\n * Recursively searches for a node by its name, starting from the given scope. Includes children of\n * the current scope in search.\n *\n * @param name the name of the node to select\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByNameInsideScope(\n  name: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKNode | ODKNode[] | undefined {\n  if (scope.row?.name === name) {\n    return scope;\n  } else if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childScope = scope.children[i];\n      if (childScope.row?.name === name) {\n        return childScope;\n      }\n      const foundChild = findNodeByNameInsideScope(name, context, childScope);\n      if (foundChild) {\n        return foundChild;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Recursively searches for a node by its name, starting from the given scope and moving upwards in\n * the hierarchy. Includes ancestors of the current scope in search, until it reaches the root\n * scope.\n *\n * @param name the name of the node to select\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByNameInCurrentAndAncestorScopes(\n  name: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): ODKNode | ODKNode[] | undefined {\n  if (scope.row?.name === name) {\n    return scope;\n  } else if (scope.children) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const child = scope.children[i];\n      if (child.row?.name === name) {\n        return child;\n      }\n    }\n  }\n  const stack = getAncestors(scope, context);\n  const parentScope = stack?.[stack.length - 1];\n  if (!parentScope) {\n    return undefined;\n  }\n  return (\n    findNodeByNameInCurrentAndAncestorScopes(name, context, parentScope) ||\n    undefined\n  );\n}\n\n/**\n * Returns a node that matches the given absolute path, or its relative path as seen from the given\n * scope. Works a bit like a file structure.\n *\n * @param pathComponents Path of the node to select. Array of strings, e.g. `['..', '..', 'name']`.\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByPathRelativeToScope(\n  pathComponents: string[],\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKNode | ODKNode[] | undefined {\n  const pathComponent = pathComponents[0];\n  // console.log('Searching', pathComponent, 'in scope', scope.row?.name, 'stack', scope.stack);\n  let result: ODKNode | undefined;\n\n  if (pathComponent === \".\") {\n    result = scope;\n  } else if (pathComponent === \"/\") {\n    result = context.survey;\n  } else if (pathComponent === \"..\") {\n    if (scope === context.survey) {\n      throw new Error(\n        \"Reached root - Can’t traverse further up the hierarchy.\"\n      );\n    }\n    const stack = getAncestors(scope, context);\n    result = stack?.[stack.length - 1];\n  } else if (pathComponent === scope.row.name) {\n    result = scope;\n  } else if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childScope = scope.children[i];\n      if (childScope.row.name === pathComponent) {\n        result = childScope;\n        break;\n      }\n    }\n  }\n\n  if (pathComponents.length === 1) {\n    return result;\n  }\n\n  return findNodeByPathRelativeToScope(\n    pathComponents.slice(1),\n    context,\n    result\n  );\n}\n\nfunction getReverseNodeAbsolutePath(\n  node: ODKNode | undefined,\n  context: ODKFormulaEvaluationContext\n): string[] {\n  if (!node) {\n    return [\"/\"];\n  }\n\n  if (!node?.row?.name) {\n    throw new Error(\n      `Encountered a row without a name (row #${node.rowIndex}). This should not happen. Please ensure the survey data is valid.`\n    );\n  }\n\n  const stack = getAncestors(node, context);\n  return [\n    node.row?.name,\n    ...getReverseNodeAbsolutePath(stack?.[stack.length - 1], context),\n  ];\n}\n\n/** @returns the key path of a given node in the survey tree as an array of node names.*/\nexport function getNodeAbsolutePath(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n): string[] {\n  return getReverseNodeAbsolutePath(node, context)?.reverse();\n}\n\n/**\n * @returns the key path of a given node in the survey tree as a string of node names joined by a\n * given delimiter (usually '.' or '/').\n */\nexport function getNodeAbsolutePathString(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  delimiter: string = \".\"\n): string {\n  return getNodeAbsolutePath(node, context).slice(1).join(delimiter);\n}\n\n/**\n * @returns `true` if a string is a valid XPath, `false` otherwise.\n */\nexport function isXPath(string: string): boolean {\n  return !!string.match(/^\\/(\\/?[\\w*]+(?:\\[[^]+?])?)$/);\n}\n\n/**\n * @returns a list of array indexes that allow finding a given node inside the scope by looking it\n * up using each ancestor's `children` array.\n */\nexport function getScopedNodeIndexPath(\n  node: ODKNode,\n  scope: ODKNode,\n  stack: number[] = []\n): number[] | undefined {\n  if (isEqual(node, scope)) {\n    return stack;\n  }\n  if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      stack.push(i);\n      const childNode = scope.children[i];\n      const foundStack = getScopedNodeIndexPath(node, childNode, stack);\n      if (foundStack !== undefined) {\n        return foundStack;\n      }\n      stack.pop();\n    }\n  }\n  return undefined;\n}\n\n/**\n * @returns a list of array indexes that allow finding a given node from the root by looking it\n * up using each ancestor's `children` array.\n */\n\nexport function getNodeIndexPath(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n): number[] | undefined {\n  return getScopedNodeIndexPath(node, context.survey);\n}\n\n/**\n * @returns the list of ancestors of a node (as node references), using the given scope as root.\n */\nexport function getScopedAncestors(\n  node: ODKNode,\n  scope: ODKNode,\n  stack: ODKNode[] = []\n): ODKNode[] | undefined {\n  if (isEqual(node, scope)) {\n    return stack;\n  }\n  if (scope.children?.length) {\n    stack.push(scope);\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childNode = scope.children[i];\n      const foundStack = getScopedAncestors(node, childNode, stack);\n      if (foundStack) {\n        return foundStack;\n      }\n    }\n    stack.pop();\n  }\n}\n\n/**\n * @returns the list of ancestors of a node (as node references) up to (and including) the survey\n * root node.\n */\n\nexport function getAncestors(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n) {\n  return getScopedAncestors(node, context.survey);\n}\n","import ODKFormulaEvaluationContext from \"../functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getScopedAncestors } from \"../functions/odk-formulas/evaluation/XPath\";\nimport { Expression, Token } from \"../functions/odk-formulas/pratt-parser-base\";\nimport { ODKNode } from \"./ODKNode\";\n\n/**\n * Abstract base class for any errors in ODK formulas.\n */\nexport abstract class ODKFormulaError extends Error {\n  token?: Token;\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\n/**\n * An error that happened while evaluating an ODK formula AST. Can wrap an underlying `Error`\n * that caused the evaluation to fail.\n */\n\nexport class EvaluationError extends ODKFormulaError {\n  nodeStack: readonly Readonly<ODKNode>[];\n\n  constructor(\n    message: string,\n    readonly type: string,\n    readonly expression: Expression | undefined,\n    readonly context: ODKFormulaEvaluationContext,\n    readonly scope: ODKNode,\n    readonly underlyingEvaluationError: EvaluationError | undefined = undefined\n  ) {\n    super(message);\n\n    const ancestors = getScopedAncestors(scope, context.survey);\n\n    this.nodeStack = [...(ancestors || []), scope];\n  }\n\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\n/**\n * An error that happened while trying to parse an ODK formula string to turn it into an AST.\n */\n\nexport class ParseError extends ODKFormulaError {\n  constructor(\n    readonly type: string,\n    message: string,\n    readonly tokens?: Token[]\n  ) {\n    super(message);\n  }\n\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\n/**\n * An error that happened while trying to tokenize an ODK formula string to turn it into a token\n * list.\n */\n\nexport class LexerError extends ODKFormulaError {\n  constructor(readonly token: Token, readonly message: string) {\n    super(message);\n  }\n}\n\n/**\n * Describes a syntax error in a XLSForm workbook.\n */\nexport class SyntaxError extends ODKFormulaError {}\n\n/** Describes an error with the semantics of a XLSForm workbook or a formula. */\nexport class SemanticError extends ODKFormulaError {}\n\n/** Thrown if an ODK formula function is not implemented yet. */\nexport class FunctionNotImplementedError extends ODKFormulaError {\n  constructor(functionName: string) {\n    super(\n      `The \\`${functionName}\\` function is not supported yet. If you need it, please contact the developers.`\n    );\n  }\n}\n\n/** Thrown if a feature is not implemented yet. */\nexport class UnsupportedFeatureError extends ODKFormulaError {\n  constructor(feature: string) {\n    super(`${feature} is not supported.`);\n  }\n}\n","export enum TokenType {\n  LEFT_PAREN,\n  RIGHT_PAREN,\n  COMMA,\n  ASSIGN,\n  PLUS,\n  MINUS,\n  ASTERISK,\n  DOLLAR,\n  LEFT_BRACE,\n  RIGHT_BRACE,\n  GREATER_THAN,\n  LESS_THAN,\n  SLASH,\n  POINT,\n  CARET,\n  TILDE,\n  BANG,\n  BACKSLASH,\n  QUESTION,\n  COLON,\n  SINGLE_QUOTE,\n  DOUBLE_QUOTE,\n  MODULO,\n  BOOLEAN_AND,\n  BOOLEAN_OR,\n  COMPARISON,\n  NAME,\n  LITERAL,\n  NUMBER_LITERAL,\n  FLOAT_LITERAL,\n  INT_LITERAL,\n  STRING_LITERAL,\n  BOOLEAN_LITERAL,\n  SELECTOR,\n  WHITESPACE,\n  UNKNOWN,\n  EOF,\n  INVALID,\n  INTERNAL_LEXER_ERROR,\n}\n\nexport const tokenTypes = [\n  TokenType.LEFT_PAREN,\n  TokenType.RIGHT_PAREN,\n  TokenType.COMMA,\n  TokenType.ASSIGN,\n  TokenType.PLUS,\n  TokenType.MINUS,\n  TokenType.ASTERISK,\n  TokenType.GREATER_THAN,\n  TokenType.LESS_THAN,\n  TokenType.BOOLEAN_AND,\n  TokenType.BOOLEAN_OR,\n  TokenType.SLASH,\n  TokenType.CARET,\n  TokenType.TILDE,\n  TokenType.BANG,\n  TokenType.MODULO,\n  TokenType.COMPARISON,\n  TokenType.BACKSLASH,\n  TokenType.QUESTION,\n  TokenType.COLON,\n  TokenType.SINGLE_QUOTE,\n  TokenType.DOUBLE_QUOTE,\n  TokenType.NAME,\n  TokenType.LITERAL,\n  TokenType.NUMBER_LITERAL,\n  TokenType.INT_LITERAL,\n  TokenType.FLOAT_LITERAL,\n  TokenType.STRING_LITERAL,\n  TokenType.BOOLEAN_LITERAL,\n  TokenType.WHITESPACE,\n  TokenType.UNKNOWN,\n  TokenType.EOF,\n  TokenType.INVALID,\n];\n\n/**\n * If the TokenType represents a punctuator (i.e. a token that can split an\n * identifier like '+', this will get its text.\n */\nexport function punctuator(tokenType: TokenType): string {\n  switch (tokenType) {\n    case TokenType.LEFT_PAREN:\n      return \"(\";\n    case TokenType.RIGHT_PAREN:\n      return \")\";\n    case TokenType.COMMA:\n      return \",\";\n    case TokenType.ASSIGN:\n      return \"=\";\n    case TokenType.PLUS:\n      return \"+\";\n    case TokenType.MINUS:\n      return \"-\";\n    case TokenType.ASTERISK:\n      return \"*\";\n    case TokenType.SLASH:\n      return \"/\";\n    case TokenType.CARET:\n      return \"^\";\n    case TokenType.TILDE:\n      return \"~\";\n    case TokenType.BANG:\n      return \"!\";\n    case TokenType.BACKSLASH:\n      return \"\\\\\";\n    case TokenType.QUESTION:\n      return \"?\";\n    case TokenType.COLON:\n      return \":\";\n    default:\n      return \"[undefined punctuator]\";\n  }\n}\n\n/**\n * A simple token class. These are generated by Lexer and consumed by Parser.\n */\nexport type Token = {\n  type: TokenType;\n  text: string;\n  index: number;\n};\n\n/**\n * Interface for all expression AST node classes.\n */\nexport abstract class Expression {\n  abstract readonly kind: string;\n  abstract tokens: Token[];\n  abstract children: (Token | Expression)[];\n  /**\n   * Pretty-print the expression to a string.\n   */\n  abstract print(builder: StringBuilder): void;\n}\n\nexport type StringBuilder = (result: string) => void;\n","import Parser from '../Parser';\nimport { Expression, Token } from '../types';\n\n/**\n * One of the two parselet interfaces used by the Pratt parser. An\n * InfixParselet is associated with a token that appears in the middle of the\n * expression it parses. Its parse() method will be called after the left-hand\n * side has been parsed, and it in turn is responsible for parsing everything\n * that comes after the token. This is also used for postfix expressions, in\n * which case it simply doesn't consume any more tokens in its parse() call.\n */\nexport default abstract class InfixParselet {\n  abstract parse(parser: Parser, left: Expression, token: Token): Expression;\n  abstract getPrecedence(): number;\n}\n","import Parser from '../Parser';\nimport { Expression, Token } from '../types';\n\n/**\n * One of the two interfaces used by the Pratt parser. A PrefixParselet is\n * associated with a token that appears at the beginning of an expression. Its\n * parse() method will be called with the consumed leading token, and the\n * parselet is responsible for parsing anything that comes after that token.\n * This interface is also used for single-token expressions like variables, in\n * which case parse() simply doesn't consume any more tokens.\n * @author rnystrom\n *\n */\nexport default abstract class PrefixParselet {\n  abstract parse(parser: Parser, token: Token): Expression;\n}\n","import { ParseError, SyntaxError } from \"../../../types/Errors\";\nimport InfixParselet from \"./parselets/InfixParselet\";\nimport PrefixParselet from \"./parselets/PrefixParselet\";\nimport { Expression, punctuator, Token, TokenType } from \"./types\";\n\nexport type TokenCallback = (expression: Token) => void;\nexport type ExpressionCallback = (expression: Expression) => void;\nexport interface ITokenizer {\n  next: () => { value: Token };\n}\nexport type ParserOptions = {\n  tokens: ITokenizer;\n  onToken?: TokenCallback;\n  onExpression?: ExpressionCallback;\n};\n\nexport default class Parser {\n  private readTokens: Token[] = [];\n  private prefixParselets: Map<TokenType, PrefixParselet> = new Map();\n  private infixParselets: Map<TokenType, InfixParselet> = new Map();\n\n  constructor(readonly options: ParserOptions) {}\n\n  public register(\n    token: TokenType,\n    parselet: PrefixParselet | InfixParselet\n  ): void {\n    if (parselet instanceof PrefixParselet) {\n      this.prefixParselets.set(token, parselet);\n    } else if (parselet instanceof InfixParselet) {\n      this.infixParselets.set(token, parselet);\n    } else {\n      throw new Error(\n        `Found a parselet that was neither an infix nor a prefix parselet: No idea what to do with it…`\n      );\n    }\n  }\n\n  public parseExpression(precedence = 0): Expression {\n    const token = this.consumeAnything();\n    if (!token) {\n      throw new ParseError(\n        \"prematureEOF\",\n        \"Parser encountered end of tokens. This should not happen.\"\n      );\n    }\n    const prefix = this.prefixParselets.get(token.type);\n    if (!prefix)\n      throw new ParseError(\n        \"undefinedPrefix\",\n        `Expected start of a new expression, but \\`${token.text}\\` is not an allowed prefix.`,\n        [token]\n      );\n\n    let left: Expression = prefix.parse(this, token);\n\n    while (precedence < this.getPrecedence()) {\n      const token = this.consumeAnything();\n      if (!token) {\n        throw new ParseError(\n          \"prematureEndOfTokens\",\n          \"Parser encountered end of tokens. This should not happen.\"\n        );\n      }\n      const infix = this.infixParselets.get(token.type);\n      if (!infix)\n        throw new ParseError(\n          \"undefinedInfix\",\n          `\\`${token.text}\\` is not an allowed infix.`,\n          [token]\n        );\n      left = infix.parse(this, left, token);\n    }\n\n    this.options.onExpression?.(left);\n    return left;\n  }\n\n  public match(expected: TokenType): Token | undefined {\n    const token = this.lookAhead(0);\n    if (token.type !== expected) {\n      return undefined;\n    }\n\n    return this.consumeAnything();\n  }\n\n  public consume(expected: TokenType): Token {\n    const token = this.lookAhead(0);\n    if (token.type !== expected) {\n      if (token.type === TokenType.EOF) {\n        throw new SyntaxError(\n          \"Missing `\" +\n            punctuator(expected) +\n            \"` before the end of the formula. Is the formula complete?\"\n        );\n      }\n\n      throw new SyntaxError(\n        \"Expected token `\" +\n          TokenType[expected] +\n          \"` but found `\" +\n          TokenType[token.type] +\n          \"`\"\n      );\n    }\n\n    const consumedToken = this.consumeAnything();\n    if (!consumedToken) {\n      throw new SyntaxError(\"Could not consume token \" + expected);\n    }\n    return token;\n  }\n\n  public consumeAnything(): Token | undefined {\n    // Make sure we've read the token.\n    this.lookAhead(0);\n\n    return this.readTokens.shift();\n  }\n\n  private lookAhead(distance: number): Token {\n    // Read in as many as needed.\n    while (distance >= this.readTokens.length) {\n      const nextToken = this.options.tokens.next();\n      if (nextToken.value) this.options.onToken?.(nextToken.value);\n      this.readTokens.push(nextToken.value);\n    }\n\n    // Get the queued token.\n    return this.readTokens[distance];\n  }\n\n  private getPrecedence(): number {\n    const parser = this.infixParselets.get(this.lookAhead(0).type);\n    if (parser) return parser.getPrecedence();\n    return 0;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A simple variable name expression like \"abc\".\n */\nexport default class NameExpression extends Expression {\n  kind = \"name\";\n  children = this.tokens;\n\n  constructor(\n    readonly tokens: Token[],\n    readonly name: string,\n    readonly text: string\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(this.name);\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A binary arithmetic expression like \"a + b\" or \"c ^ d\".\n */\nexport default class OperatorExpression extends Expression {\n  kind = \"operator\";\n  children = [this.left, this.operatorToken, this.right];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly left: Expression,\n    readonly operatorToken: Token,\n    readonly right: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.left.print(builder);\n    builder(\" \");\n    builder(this.operatorToken.text);\n    builder(\" \");\n    this.right.print(builder);\n    builder(\")\");\n  }\n}\n","import OperatorExpression from \"../expressions/OperatorExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Generic infix parselet for a binary arithmetic operator. The only\n * difference when parsing, \"+\", \"-\", \"*\", \"/\", and \"^\" is precedence and\n * associativity, so we can use a single parselet class for all of those.\n */\nexport default class BinaryOperatorParselet extends InfixParselet {\n  constructor(readonly precedence: number, readonly isRight: boolean) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    operatorToken: Token\n  ): Expression {\n    // To handle right-associative operators like \"^\", we allow a slightly\n    // lower precedence when parsing the right-hand side. This will let a\n    // parselet with the same precedence appear on the right, which will then\n    // take *this* parselet's result as its left-hand argument.\n    const right = parser.parseExpression(\n      this.precedence - (this.isRight ? 1 : 0)\n    );\n\n    return new OperatorExpression(\n      [...left.tokens, operatorToken, ...right.tokens],\n      left,\n      operatorToken,\n      right\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A function call like \"a(b, c, d)\".\n */\nexport default class CallExpression extends Expression {\n  kind = \"call\";\n  readonly args: Expression[];\n  children = [\n    this.fn,\n    this.leftParenToken,\n    ...this.argsAndDelimiters,\n    this.rightParenToken,\n  ];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly fn: Expression,\n    readonly leftParenToken: Token,\n    readonly argsAndDelimiters: (Expression | Token)[],\n    readonly rightParenToken: Token\n  ) {\n    super();\n    this.args = argsAndDelimiters.filter(\n      (e) => e instanceof Expression\n    ) as Expression[];\n  }\n\n  public print(builder: StringBuilder): void {\n    this.fn.print(builder);\n    builder(\"(\");\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i].print(builder);\n      if (i < this.args.length - 1) builder(\", \");\n    }\n    builder(\")\");\n  }\n}\n","import CallExpression from \"../expressions/CallExpression\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\nimport Parser from \"../Parser\";\n\n/**\n * Parselet to parse a function call like \"a(b, c, d)\".\n */\nexport default class CallParselet extends InfixParselet {\n  constructor(\n    readonly rightParenTokenType: TokenType,\n    readonly argumentDelimiterTokenType: TokenType,\n    readonly precedence: number\n  ) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    leftParenToken: Token\n  ): Expression {\n    // Parse the token-separated arguments until we hit the token that marks the argument list end.\n    const args: Expression[] = [];\n    let rightParenToken: Token | undefined = parser.match(\n      this.rightParenTokenType\n    );\n    const tokens: Token[] = [...left.tokens, leftParenToken];\n    const argsAndDelimiters: (Expression | Token)[] = [];\n    if (rightParenToken) {\n      // There may be no arguments at all.\n      tokens.push(rightParenToken);\n    } else {\n      let delimiterToken;\n      do {\n        const arg = parser.parseExpression();\n        args.push(arg);\n        tokens.push(...arg.tokens);\n        argsAndDelimiters.push(arg);\n        delimiterToken = parser.match(this.argumentDelimiterTokenType);\n        if (delimiterToken) {\n          tokens.push(delimiterToken);\n          argsAndDelimiters.push(delimiterToken);\n        }\n      } while (delimiterToken);\n      rightParenToken = parser.consume(this.rightParenTokenType);\n      if (rightParenToken) {\n        tokens.push(rightParenToken);\n      }\n    }\n\n    return new CallExpression(\n      tokens,\n      left,\n      leftParenToken,\n      argsAndDelimiters,\n      rightParenToken\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A ternary conditional expression like \"a ? b : c\".\n */\nexport default class ConditionalExpression extends Expression {\n  kind = \"conditional\";\n  children = [\n    this.condition,\n    this.questionMarkToken,\n    this.thenArm,\n    this.colonToken,\n    this.elseArm,\n  ];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly condition: Expression,\n    readonly questionMarkToken: Token,\n    readonly thenArm: Expression,\n    readonly colonToken: Token,\n    readonly elseArm: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.condition.print(builder);\n    builder(\" ? \");\n    this.thenArm.print(builder);\n    builder(\" : \");\n    this.elseArm.print(builder);\n    builder(\")\");\n  }\n}\n","import ConditionalExpression from \"../expressions/ConditionalExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Parselet for the condition or \"ternary\" operator, like \"a ? b : c\".\n */\nexport default class ConditionalParselet extends InfixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    questionMarkToken: Token\n  ): Expression {\n    const thenArm = parser.parseExpression();\n    const colonToken = parser.consume(TokenType.COLON);\n    const elseArm = parser.parseExpression(this.precedence - 1);\n    return new ConditionalExpression(\n      [\n        ...left.tokens,\n        questionMarkToken,\n        ...thenArm.tokens,\n        colonToken,\n        ...elseArm.tokens,\n      ],\n      left,\n      questionMarkToken,\n      thenArm,\n      colonToken,\n      elseArm\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import Parser from \"../Parser\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Parses parentheses used to group an expression, like \"a * (b + c)\".\n */\nexport default class GroupParselet extends PrefixParselet {\n  constructor(readonly rightParenTokenType: TokenType) {\n    super();\n  }\n\n  public parse(parser: Parser, leftParenToken: Token): Expression {\n    const expression = parser.parseExpression();\n    const rightParenToken = parser.consume(this.rightParenTokenType);\n    expression.tokens = [leftParenToken, ...expression.tokens, rightParenToken];\n    expression.children = [leftParenToken, expression, rightParenToken];\n    return expression;\n  }\n}\n","import NameExpression from \"../expressions/NameExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a named variable like \"abc\".\n */\nexport default class NameParselet extends PrefixParselet {\n  constructor(readonly getName: (text: string) => string = (t) => t) {\n    super();\n  }\n  public parse(_parser: Parser, token: Token): Expression {\n    const name = this.getName(token.text);\n    return new NameExpression([token], name, token.text);\n  }\n}\n","import { Expression, punctuator, StringBuilder, Token } from \"../types\";\n\n/**\n * A postfix unary arithmetic expression like \"a!\".\n */\nexport default class PostfixExpression extends Expression {\n  kind = \"postfix\";\n  children = [this.left, this.operatorToken];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly left: Expression,\n    readonly operatorToken: Token\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.left.print(builder);\n    builder(punctuator(this.operatorToken.type));\n    builder(\")\");\n  }\n}\n","import PostfixExpression from \"../expressions/PostfixExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Generic infix parselet for an unary arithmetic operator. Parses postfix\n * unary \"?\" expressions.\n */\nexport default class PostfixOperatorParselet extends InfixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(_parser: Parser, left: Expression, token: Token): Expression {\n    return new PostfixExpression([...left.tokens, token], left, token);\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, punctuator, StringBuilder, Token } from \"../types\";\n\n/**\n * A prefix unary arithmetic expression like \"!a\" or \"-b\".\n */\nexport default class PrefixExpression extends Expression {\n  kind = \"prefix\";\n  children = [this.right];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly operatorToken: Token,\n    readonly right: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    builder(punctuator(this.operatorToken.type));\n    this.right.print(builder);\n    builder(\")\");\n  }\n}\n","import PrefixExpression from \"../expressions/PrefixExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Generic prefix parselet for an unary arithmetic operator. Parses prefixes, for example\n * unary \"-\", \"+\", \"~\", and \"!\" expressions.\n */\nexport default class PrefixOperatorParselet extends PrefixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(parser: Parser, token: Token): Expression {\n    // To handle right-associative operators like \"^\", we allow a slightly\n    // lower precedence when parsing the right-hand side. This will let a\n    // parselet with the same precedence appear on the right, which will then\n    // take *this* parselet's result as its left-hand argument.\n    const right = parser.parseExpression(this.precedence);\n\n    return new PrefixExpression([token, ...right.tokens], token, right);\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import Parser from './Parser';\n\nexport const PrattParser = Parser;\n\nexport * from './parselets/index';\nexport * from './expressions/index';\nexport * from './types';\n\nexport default PrattParser;\n","import { Colors } from \"@blueprintjs/core\";\nimport styled from \"styled-components\";\n\n/** CSS container for highlighted formula code. */\n\nconst StyledCode = styled.code`\n  font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n    \"Courier New\", monospace;\n\n  .expression.has-error {\n    text-decoration: underline wavy ${Colors.RED2};\n    text-decoration-skip: none;\n    text-decoration-skip-ink: none;\n    text-decoration-color: ${Colors.RED2} !important;\n\n    a {\n      text-decoration: underline wavy ${Colors.RED2};\n      text-decoration-skip: none;\n      text-decoration-skip-ink: none;\n      text-decoration-color: ${Colors.RED2} !important;\n    }\n  }\n\n  .expression-name {\n    color: ${Colors.VIOLET5};\n  }\n\n  &.expression-call > .expression-name:first-child,\n  .expression-call > .expression-name:first-child {\n    color: ${Colors.BLUE3};\n  }\n\n  .expression-name {\n    word-break: break-word;\n  }\n\n  .token-STRING_LITERAL {\n    color: ${Colors.ORANGE3};\n  }\n\n  .token-NUMBER_LITERAL {\n    color: ${Colors.ORANGE4};\n  }\n\n  .token-COMMA {\n    color: ${Colors.GRAY1};\n  }\n\n  .token-LEFT_PAREN,\n  .token-RIGHT_PAREN {\n    color: ${Colors.BLUE2} !important;\n    font-weight: bold;\n  }\n\n  .token-INVALID {\n    border: 2px ${Colors.RED5} solid;\n    padding: 2px;\n    margin: -2px;\n    color: ${Colors.RED5};\n  }\n\n  .token-COMMA::after {\n    content: \" \";\n  }\n\n  .expression-operator {\n    clear: left;\n  }\n\n  .token-COMPARISON {\n    &::after,\n    &::before {\n      content: \" \";\n    }\n    font-weight: bold;\n    color: ${Colors.VERMILION3};\n  }\n\n  .token-COLON,\n  .token-BOOLEAN_AND,\n  .token-BOOLEAN_OR,\n  .token-PLUS,\n  .token-GREATER_THAN,\n  .token-LESS_THAN,\n  .token-MODULO,\n  .token-QUESTION {\n    word-break: break-word;\n    display: block;\n    font-weight: bold;\n    color: ${Colors.VERMILION2};\n  }\n`;\n\nexport default StyledCode;\n","import {\n  EvaluatableColumnName,\n  NodesToValues,\n  ODKNode,\n} from \"../../../types/ODKNode\";\nimport { NameExpression } from \"../pratt-parser-base\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\n/**\n * Contains global information that can be used in a single formula evaluation. The evaluation\n * process can use this to:\n *\n * - tracking stack overflows and potential create stack traces\n * - store state of the end user's survey answers\n * - store evaluated values of formulas\n * - find answer values of other nodes referenced in formulas\n */\n\ntype ODKFormulaEvaluationContext = {\n  /** The survey in which the evaluation takes place */\n  survey: ODKNode;\n  nodesToAnswers: NodesToValues;\n  evaluationResults: NodesToValues<\n    Map<EvaluatableColumnName, ODKFormulaEvaluationResult>\n  >;\n  /** The current stack depth. Used to to prevent stack overflows in recursive calculations. */\n  stackDepth: number;\n  knownLiteralsWithoutDollarSign: Record<string, unknown>;\n  evaluateNonDollarNameFn?: (options: {\n    expression: NameExpression;\n    context: ODKFormulaEvaluationContext;\n    scope: ODKNode;\n  }) => unknown;\n};\n\nexport default ODKFormulaEvaluationContext;\n\n/** These are literals that appeared (and apparently were supported) in our Kobo forms, and are documented in XLSForms. */\nexport const knownLiteralsWithoutDollarSign: Record<string, unknown> = {\n  yes: true,\n  no: false,\n  TRUE: true,\n  FALSE: false,\n  true: true,\n  false: false,\n};\n\n/** Returns a blank context to start evaluating from scratch. */\nexport const getEmptyEvaluationContext: (\n  survey?: ODKNode\n) => ODKFormulaEvaluationContext = (survey?: ODKNode) => ({\n  survey: survey || {\n    type: \"\",\n    typeParameters: [],\n    row: {\n      type: \"\",\n      name: \"data\",\n      label: { \"English (en)\": \"[empty survey]\" },\n    },\n    children: [],\n    indentationLevel: 0,\n    rowIndex: -1,\n  },\n  nodesToAnswers: new Map(),\n  evaluationResults: new Map(),\n  stackDepth: 0,\n  knownLiteralsWithoutDollarSign,\n});\n","import * as React from \"react\";\nimport SimpleSchema from \"simpl-schema\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport ODKFormulaEvaluationContext, {\n  getEmptyEvaluationContext,\n} from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport useChangeHooks from \"./useChangeHooks\";\n\n/** Provides the current XLSForm survey, its evaluation results, and its metadata. */\nexport type ODKSurveyContextType = {\n  /** `true` if the survey should show editing/debugging UI features, `false` otherwise. */\n  debug: boolean;\n\n  /** The current survey’s XLSForm model. */\n  xlsForm?: XLSForm;\n\n  /** A schema that allows to validate answer results for the current survey. */\n  schema?: SimpleSchema;\n\n  /** The ODK/XLSForm evaluation context for the survey. Contains evaluated answers and formulas. */\n  evaluationContext?: ODKFormulaEvaluationContext;\n\n  /** The currently selected language used for survey display. */\n  language?: string;\n\n  /** Name of the currently selected language used for survey display (e.g. 'Deutsch'). */\n  languageName?: string;\n\n  /** Language tag of the currently selected language used for survey display (e.g. 'de-AT'). */\n  languageCode?: string;\n} & ReturnType<typeof useChangeHooks>;\n\n/**\n * Provides the current XLSForm survey, its evaluation results, its metadata, and functions to edit\n * the survey.\n */\nexport const ODKSurveyContext = React.createContext<ODKSurveyContextType>({\n  schema: new SimpleSchema({}),\n  debug: true,\n  xlsForm: undefined,\n\n  evaluationContext: getEmptyEvaluationContext(),\n\n  language: \"English (en)\",\n  languageCode: \"en\",\n  languageName: \"English\",\n\n  setEvaluationContext: () => {},\n  setXLSFormWithPatches: () => {},\n  onChangeAnswer: () => {},\n  onChangeCell: () => {},\n  onMoveNode: () => {},\n  onSpliceRows: () => {},\n  onRemoveRowAndChildren: () => {},\n  onRenameNode: () => {},\n  onNestNode: () => {},\n  onUngroupNode: () => {},\n  onAddNode: () => {},\n});\n","import { HTMLDivProps } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\nfunction getDarkModeSetting(): boolean {\n  return (\n    window.matchMedia &&\n    window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n  );\n}\n\nexport default function DarkModeContainer(props: HTMLDivProps) {\n  const isDarkMode = useDarkMode();\n  return (\n    <div\n      {...props}\n      className={isDarkMode ? `${props.className} bp3-dark` : props.className}\n    >\n      {props.children}\n    </div>\n  );\n}\n\nexport function useDarkMode() {\n  const [isDarkMode, setIsDarkMode] = React.useState(getDarkModeSetting());\n\n  const handleChange = React.useCallback((e) => {\n    setIsDarkMode(getDarkModeSetting());\n  }, []);\n\n  React.useEffect(() => {\n    if (window.matchMedia === undefined) {\n      return;\n    }\n    window\n      .matchMedia(\"(prefers-color-scheme: dark)\")\n      .addEventListener(\"change\", handleChange);\n  }, [handleChange]);\n\n  return isDarkMode;\n}\n","import { hsl, rgb } from \"d3-color\";\nimport { interpolateHsl, interpolateLab } from \"d3-interpolate\";\n\n/**\n * @returns a brighter version of the given color. Nicer looking than using HSL + changing the\n * luminance: The LAB color space is modeled similarly to how the human eye senses light, resulting\n * in more ‘natural’ color tones.\n */\nexport function coloredWhite(color: string, value: number = 0.5) {\n  const labColor = hsl(color);\n  return interpolateHsl(labColor, \"white\")(value).toString();\n}\n\n/** @returns a brighter version of the given color. */\nexport function brighter(color: string, value: number = 0.3) {\n  return hsl(color).brighter(value).toString();\n}\n\n/** @returns a darker version of the given color. */\nexport function darker(color: string, value: number = 0.3) {\n  return hsl(color).darker(value).toString();\n}\n\n/** @returns the same color, but with a different alpha (opacity) value. */\nexport function alpha(color: string, value: number = 0.4) {\n  const alphaColor = rgb(color);\n  alphaColor.opacity *= value;\n  return alphaColor.toString();\n}\n\n/**\n * @returns a color between the given two colors, mixed using the LAB color space. This color space\n * is modeled similarly to how the human eye senses light, resulting in more ‘natural’ color tones.\n */\nexport function mixLab(color1: string, color2: string, ratio: number = 0.5) {\n  return interpolateLab(color1, color2)(ratio).toString();\n}\n","import { LocalizedString } from \"../../types/RowTypes\";\n\n/**\n * Creates an object with language codes as property names, using the given text as translation for\n * all languages. Helpful when you need a `LocalizedString` but have no sensible content yet.\n */\nexport function createLocalizedString(\n  text: string,\n  languages: Readonly<Set<string>>\n): LocalizedString {\n  const result: LocalizedString = {};\n  languages.forEach((lang) => {\n    result[lang] = text;\n  });\n  return result;\n}\n","import { createLocalizedString } from \"../functions/editing/createLocalizedString\";\nimport { ODKNode } from \"./ODKNode\";\n\nexport let i = 0;\n\nexport function getEmptyNode(\n  languages: Readonly<Set<string>>\n): Readonly<ODKNode> {\n  i += 1;\n  return Object.freeze({\n    row: {\n      type: \"text\",\n      name: `empty_node_${i}`,\n      label: createLocalizedString(`Empty node ${i}`, languages),\n    },\n    type: \"text\",\n    typeParameters: [],\n    children: [],\n    indentationLevel: 0,\n    rowIndex: -2,\n  });\n}\n","import * as React from \"react\";\nimport ODKFormulaEvaluationResult from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { getEmptyNode } from \"../xlsform-simple-schema/types/getEmptyNode\";\nimport {\n  EvaluatableColumnName,\n  ODKNode,\n} from \"../xlsform-simple-schema/types/ODKNode\";\n\n/** Provides the current XLSForm node (= survey field or group/repeat), and its evaluation results. */\nexport interface IODKNodeContext {\n  node: ODKNode;\n  nodeEvaluationResults?: Map<\n    EvaluatableColumnName,\n    ODKFormulaEvaluationResult\n  >;\n}\n\n/** Provides the current XLSForm node (= survey field or group/repeat), and its evaluation results. */\nexport const ODKNodeContext = React.createContext<IODKNodeContext>({\n  node: getEmptyNode(new Set([\"English (en)\"])),\n});\n","import { IconName } from \"@blueprintjs/core\";\n\nexport const fieldTypesToIcons: Record<string, IconName> = {\n  integer: \"numerical\",\n  decimal: \"numerical\",\n  range: \"horizontal-distribution\",\n  text: \"edit\",\n  select_one: \"selection\",\n  select_one_from_file: \"selection\",\n  select_multiple: \"multi-select\",\n  select_multiple_from_file: \"multi-select\",\n  rank: \"sort-numerical\",\n  note: \"lightbulb\",\n  geopoint: \"map-marker\",\n  geotrace: \"draw\",\n  geoshape: \"geofence\",\n  date: \"calendar\",\n  time: \"time\",\n  datetime: \"time\",\n  image: \"media\",\n  audio: \"headset\",\n  video: \"video\",\n  file: \"upload\",\n  barcode: \"barcode\",\n  calculate: \"function\",\n  acknowledge: \"switch\",\n  hidden: \"eye-off\",\n  \"xml-external\": \"layout-hierarchy\",\n  start: \"time\",\n  end: \"time\",\n  today: \"calendar\",\n  deviceid: \"desktop\",\n  simserial: \"sim-card\",\n  subscriberid: \"id-number\",\n  phonenumber: \"phone\",\n  username: \"person\",\n  email: \"envelope\",\n  audit: \"shield\",\n  begin_group: \"group-objects\",\n  begin_repeat: \"repeat\",\n};\n","/** These field types are internal and have automati values - fields of these types should not be shown to users. */\nexport const internalFieldTypes = [\n  undefined,\n  \"\",\n  \"start\",\n  \"end\",\n  \"today\",\n  \"username\",\n  \"simserial\",\n  \"subscriberid\",\n  \"deviceid\",\n  \"phonenumber\",\n  \"calculate\",\n];\n","import ODKFormulaEvaluationContext from \"../functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport AppearanceAttributeFlags from \"./AppearanceAttributeFlags\";\nimport {\n  IBeginGroupMarkerRow,\n  IBeginRepeatMarkerRow,\n} from \"./BeginOrEndMarkerRow\";\nimport { QuestionRow } from \"./RowTypes\";\n\n/**\n * Represents a 'raw' survey variable, input, field group or repeat group, before its content is\n * semantically inspected. An `ODKNode` can have an array of `ODKNode` objects in its `children`\n * property if it is a field group or repeat group.\n */\nexport type ODKNodeWithoutRuntimeInfo =\n  | {\n      row?: QuestionRow & (IBeginRepeatMarkerRow | IBeginGroupMarkerRow);\n      children: ODKNodeWithoutRuntimeInfo[];\n      indentationLevel: number;\n      rowIndex: number;\n    }\n  | {\n      row: QuestionRow;\n      children: ODKNodeWithoutRuntimeInfo[];\n      indentationLevel: number;\n      rowIndex: number;\n    };\n\n/**\n * Represents a 'raw' survey variable, input, field group or repeat group, after its content is\n * semantically inspected and added. An `ODKNode` can have an array of `ODKNode` objects in its\n * `children` property if it is a field group or repeat group.\n */\nexport type ODKNode =\n  | {\n      row: QuestionRow & (IBeginRepeatMarkerRow | IBeginGroupMarkerRow);\n      type: string;\n      typeParameters: string[];\n      appearance?: AppearanceAttributeFlags;\n      children: ODKNode[];\n      indentationLevel: number;\n      rowIndex: number;\n    }\n  | {\n      row: QuestionRow;\n      type: string;\n      typeParameters: string[];\n      appearance?: AppearanceAttributeFlags;\n      children: ODKNode[];\n      indentationLevel: number;\n      rowIndex: number;\n    };\n\n/** Maps `ODKNode` references to values, for example, answers, or formula evaluation results. */\nexport type NodesToValues<T = unknown> = Readonly<Map<Readonly<ODKNode>, T>>;\n\n/** A name of a column in the `survey` worksheet that can contain formulas. */\nexport type EvaluatableColumnName =\n  | \"relevant\"\n  | \"calculation\"\n  | \"required\"\n  | \"readonly\"\n  | \"constraint\";\n\n/** Names of columns in the `survey` worksheet that can contain formulas. */\nexport const evaluatableColumnNames: EvaluatableColumnName[] = [\n  \"calculation\",\n  \"required\",\n  \"relevant\",\n  \"readonly\",\n  \"constraint\",\n];\n\n/**\n * Evaluates a node's `relevant` formula condition. If there is no formula in the node’s `relevant`\n * cell, the function returns `true` and the node is visible in the survey.\n */\nexport function isNodeRelevant(\n  node: ODKNode,\n  context?: ODKFormulaEvaluationContext\n) {\n  if (!context) {\n    return false;\n  }\n  const isRelevantEvaluationResult = context.evaluationResults\n    .get(node)\n    ?.get(\"relevant\")?.result;\n  return isRelevantEvaluationResult === undefined || isRelevantEvaluationResult;\n}\n\n/**\n * Evaluates a node's `readonly` formula condition amd returns the result. If there is no formula in\n * the node’s `readonly` cell, the function returns `false` and the node is not read-only in the\n * survey.\n */\nexport function isNodeReadonly(\n  node: ODKNode,\n  context?: ODKFormulaEvaluationContext\n) {\n  if (!context) {\n    return false;\n  }\n  const isReadonlyEvaluationResult = context.evaluationResults\n    .get(node)\n    ?.get(\"readonly\")?.result;\n  return isReadonlyEvaluationResult === undefined || isReadonlyEvaluationResult;\n}\n\n/**\n * @returns `true` if the given node’s type is `begin_group` or `begin_repeat`, `false` otherwise.\n */\nexport function isGroupNode(node: ODKNode) {\n  return node.type === \"begin_group\" || node.type === \"begin_repeat\";\n}\n\nexport function isGroupRow(row: QuestionRow) {\n  return (\n    row.type === \"begin_group\" ||\n    row.type === \"begin_repeat\" ||\n    row.type === \"end_group\" ||\n    row.type === \"end_repeat\"\n  );\n}\n","import { LexerError } from \"../../../types/Errors\";\nimport { Token, TokenType } from \"../pratt-parser-base/types\";\n\nexport const xPathPrefixRegExp = /^\\/(\\/?[\\w*]+(?:\\[[^]+?]\\B)?)/;\n\nconst WHITESPACES = [\" \", \"\\t\", \"\\n\"];\nconst tokenPatterns: [TokenType, RegExp][] = [\n  [TokenType.STRING_LITERAL, /^'(\\\\\\\\|\\\\'|[^'])*'/],\n  [TokenType.STRING_LITERAL, /^\"(\\\\\\\\|\\\\\"|[^\"])*\"/],\n  [TokenType.SLASH, /^div/],\n  [TokenType.MODULO, /^mod/],\n  [TokenType.BOOLEAN_AND, /^and/],\n  [TokenType.BOOLEAN_OR, /^or/],\n  [TokenType.FLOAT_LITERAL, /^-?\\d+\\.\\d+/],\n  [TokenType.INT_LITERAL, /^-?\\d+/],\n  [TokenType.NAME, /^\\$?{[^}]+}/],\n  [TokenType.NAME, /^[a-zA-Z_\\w_][a-zA-Z_\\w_-]*/],\n  [TokenType.SELECTOR, xPathPrefixRegExp], // Match XPaths\n  [TokenType.LEFT_PAREN, /^\\(/],\n  [TokenType.RIGHT_PAREN, /^\\)/],\n  [TokenType.COMMA, /^,/],\n  [TokenType.PLUS, /^\\+/],\n  [TokenType.MINUS, /^-/],\n  [TokenType.ASTERISK, /^\\*/],\n  [TokenType.COMPARISON, /^(>=|>|<=|<|=|!=)/],\n  [TokenType.INVALID, /^(\\w+|[\\s\\S])/], // must be last\n];\n\n/** Divides a strings into tokens defined by ODK formula token patterns. */\nexport default class ODKFormulaLexer implements Iterator<Token> {\n  index = 0;\n  constructor(readonly text: string) {}\n  next(): { value: Token } {\n    if (this.index >= this.text.length) {\n      // Once we've reached the end of the string, just return EOF tokens. We'll\n      // just keeping returning them as many times as we're asked so that the\n      // parser's lookahead doesn't have to worry about running out of tokens.\n      return { value: { type: TokenType.EOF, text: \"\", index: this.index } };\n    }\n\n    // Consume and ignore whitespace\n    while (WHITESPACES.includes(this.text[this.index])) {\n      this.index += 1;\n    }\n\n    for (let i = 0; i < tokenPatterns.length; i += 1) {\n      const tokenPattern = tokenPatterns[i];\n      const [type, regex] = tokenPattern;\n      const result = this.text.slice(this.index).match(regex);\n      if (result === null) {\n        continue;\n      }\n      const text = result[0];\n      const token: Token = {\n        type,\n        text: this.text.substr(this.index, text.length),\n        index: this.index,\n      };\n      this.index += text.length;\n      return { value: token };\n    }\n\n    const errorToken: Token = {\n      type: TokenType.INTERNAL_LEXER_ERROR,\n      text: this.text[this.index],\n      index: this.index,\n    };\n    throw new LexerError(\n      errorToken,\n      \"Lexer should never get here. If we get here, this means there is no invalid token defined at the end of the pattern list. This invalid token should match at least one character that is not recognized by all other patterns.\"\n    );\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A literal expression like `true`, `\"some string\"`, `1.2345`.\n */\nexport default class LiteralExpression<T> extends Expression {\n  kind = \"literal\";\n  children = this.tokens;\n\n  constructor(\n    readonly tokens: Token[],\n    readonly type: string,\n    readonly value: T\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    if (this.type === \"string\") {\n      builder(`'${this.value}'`);\n      return;\n    }\n    builder(\"[\");\n    builder(this.type);\n    builder(\" \");\n    builder(String(this.value));\n    builder(\"]\");\n  }\n}\n","import LiteralExpression from \"../expressions/LiteralExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a literal value, like `-4` or `true`.\n */\nexport default class LiteralParselet<T> extends PrefixParselet {\n  constructor(\n    readonly getValue: (token: Token) => T,\n    readonly getType: (token: Token) => string\n  ) {\n    super();\n  }\n\n  public parse(_parser: Parser, token: Token): Expression {\n    const value = this.getValue(token);\n    const type = this.getType(token);\n    return new LiteralExpression<T>([token], type, value);\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A simple variable name expression like \"a > b > c\" or \"[foo=~bar]\".\n */\nexport default class SelectorExpression<T> extends Expression {\n  kind = \"selector\";\n  children = [this.selectorToken];\n  tokens = [this.selectorToken];\n\n  constructor(readonly selectorToken: Token, readonly selector: T) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(this.selectorToken.text);\n  }\n}\n","import SelectorExpression from \"../expressions/SelectorExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a selector variable like \"x > y > z\" or \"a/b/c[d='123']\".\n *\n * Expects that the lexer recognizes the whole selector already completely as one token.\n */\nexport default class SelectorParselet<T> extends PrefixParselet {\n  constructor(readonly getSelector: (text: string) => T) {\n    super();\n  }\n  public parse(_parser: Parser, token: Token): Expression {\n    const selector = this.getSelector(token.text);\n    return new SelectorExpression(token, selector);\n  }\n}\n","/**\n * Defines the different precedence levels used by the infix parsers. These\n * determine how a series of infix expressions will be grouped. For example,\n * \"a + b * c - d\" will be parsed as \"(a + (b * c)) - d\" because \"*\" has higher\n * precedence than \"+\" and \"-\". Here, bigger numbers mean higher precedence.\n */\nexport default class ODKFormulaPrecedence {\n  // Ordered in increasing precedence.\n  public static BOOLEAN_OP = 1;\n  public static CONDITIONAL = 2;\n  public static ASSIGNMENT = 3;\n  public static SUM = 4;\n  public static PRODUCT = 5;\n  public static EXPONENT = 6;\n  public static PREFIX = 7;\n  public static POSTFIX = 8;\n  public static CALL = 9;\n}\n","import {\n  BinaryOperatorParselet,\n  CallParselet,\n  ConditionalParselet,\n  default as PrattParser,\n  Expression,\n  GroupParselet,\n  NameParselet,\n  PostfixOperatorParselet,\n  PrefixOperatorParselet,\n  Token,\n  TokenType,\n} from \"../pratt-parser-base/index\";\nimport LiteralParselet from \"../pratt-parser-base/parselets/LiteralParselet\";\nimport SelectorParselet from \"../pratt-parser-base/parselets/SelectorParselet\";\nimport { ParserOptions } from \"../pratt-parser-base/Parser\";\nimport Precedence from \"./ODKFormulaPrecedence\";\n\n/**\n * Extends the generic PrattParser class with support for parsing ODK formula grammar.\n *\n * Based on a blog post by Bob Nystrom:\n *\n * http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n */\nexport default class ODKFormulaParser extends PrattParser {\n  expressions: Expression[] = [];\n  tokens: Token[] = [];\n\n  constructor(options: ParserOptions) {\n    super({\n      onExpression: (e) => this.expressions.push(e),\n      onToken: (t) => this.tokens.push(t),\n      ...options,\n    });\n\n    // Register all of the parselets for the grammar.\n\n    // Register the ones that need special parselets.\n    this.register(\n      TokenType.NAME,\n      new NameParselet((name) =>\n        name.startsWith(\"$\") ? name.slice(2, name.length - 1) : name\n      )\n    );\n    this.register(\n      TokenType.SELECTOR,\n      new SelectorParselet((text) => text.split(\"/\"))\n    );\n    this.register(\n      TokenType.FLOAT_LITERAL,\n      new LiteralParselet(\n        (t) => parseFloat(t.text),\n        () => \"float\"\n      )\n    );\n    this.register(\n      TokenType.INT_LITERAL,\n      new LiteralParselet(\n        (t) => parseInt(t.text, 10),\n        () => \"int\"\n      )\n    );\n    this.register(\n      TokenType.STRING_LITERAL,\n      new LiteralParselet(\n        (t) => t.text.slice(1, t.text.length - 1),\n        () => \"string\"\n      )\n    );\n    this.register(\n      TokenType.QUESTION,\n      new ConditionalParselet(Precedence.CONDITIONAL)\n    );\n    this.register(\n      TokenType.LEFT_PAREN,\n      new GroupParselet(TokenType.RIGHT_PAREN)\n    );\n    this.register(\n      TokenType.LEFT_PAREN,\n      new CallParselet(TokenType.RIGHT_PAREN, TokenType.COMMA, Precedence.CALL)\n    );\n\n    this.infixRight(TokenType.COMPARISON, Precedence.CONDITIONAL);\n\n    this.infixLeft(TokenType.BOOLEAN_AND, Precedence.BOOLEAN_OP);\n    this.infixLeft(TokenType.BOOLEAN_OR, Precedence.BOOLEAN_OP);\n    this.infixLeft(TokenType.PLUS, Precedence.SUM);\n    this.infixLeft(TokenType.MINUS, Precedence.SUM);\n    this.infixLeft(TokenType.ASTERISK, Precedence.PRODUCT);\n    this.infixLeft(TokenType.SLASH, Precedence.PRODUCT);\n    this.infixLeft(TokenType.MODULO, Precedence.EXPONENT);\n  }\n\n  /**\n   * Registers a postfix unary operator parselet for the given token and\n   * precedence.\n   */\n  public postfix(token: TokenType, precedence: number): void {\n    this.register(token, new PostfixOperatorParselet(precedence));\n  }\n\n  /**\n   * Registers a prefix unary operator parselet for the given token and\n   * precedence.\n   */\n  public prefix(token: TokenType, precedence: number): void {\n    this.register(token, new PrefixOperatorParselet(precedence));\n  }\n\n  /**\n   * Registers a left-associative binary operator parselet for the given token\n   * and precedence.\n   */\n  public infixLeft(token: TokenType, precedence: number): void {\n    this.register(token, new BinaryOperatorParselet(precedence, false));\n  }\n\n  /**\n   * Registers a right-associative binary operator parselet for the given token\n   * and precedence.\n   */\n  public infixRight(token: TokenType, precedence: number): void {\n    this.register(token, new BinaryOperatorParselet(precedence, true));\n  }\n}\n","// tslint:disable-next-line: import-name\nimport SimpleSchema, {\n  SchemaDefinition,\n  ValidationFunction,\n} from \"simpl-schema\";\nimport ODKFormulaLexer from \"../functions/odk-formulas/odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../functions/odk-formulas/odk-formula-parser/ODKFormulaParser\";\n\n/**\n * @returns a `SimpleSchema` definition for validating an object with string keys and string\n * values, e.g. for representing localized strings.\n */\nexport const getStringMapSchemaDefinition = <T>(\n  schemaDefinition: Partial<SchemaDefinition<T>> = {}\n): SchemaDefinition<T> => {\n  return {\n    type: Object,\n    blackbox: true,\n    custom() {\n      const { value } = this;\n      if (value === undefined) {\n        return;\n      }\n      if (typeof value === \"string\") {\n        return \"notAllowed\";\n      }\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (typeof value[key] !== \"string\") {\n          return \"notAllowed\";\n        }\n      }\n      return undefined;\n    },\n    ...schemaDefinition,\n  };\n};\n\n/**\n * @returns a `SimpleSchema` definition for validating an object with language codes as keys and\n * string values, representing localized variants of a string.\n */\nexport const getLocalizedStringSchemaDefinition = getStringMapSchemaDefinition;\n\nconst optionalLocalizedString = getLocalizedStringSchemaDefinition({\n  optional: true,\n});\nconst optionalStringMap = getStringMapSchemaDefinition({ optional: true });\n\n/**\n * A `SimpleSchema` validation function that validates if an ODK formula value is evaluatable.\n */\nconst formulaValidationFunction: ValidationFunction<unknown> = function () {\n  try {\n    const lexer = new ODKFormulaLexer(this.value);\n    const parser = new ODKFormulaParser({ tokens: lexer });\n    parser.parseExpression();\n  } catch (e) {\n    this.addValidationErrors([\n      {\n        name: this.key,\n        type: `Invalid formula: ${e.message}`,\n        value: this.value,\n      },\n    ]);\n  }\n};\n\n/** `SimpleSchema` for a row in the `survey` worksheet of an XLSForm. */\nexport const questionRowSchema = new SimpleSchema({\n  type: {\n    type: String,\n  },\n  name: {\n    type: String,\n    optional: true,\n    custom() {\n      const shouldBeRequired = ![\"end_group\", \"end_repeat\"].includes(\n        this.field(\"type\").value\n      );\n      if (shouldBeRequired) {\n        const error = SimpleSchema.ErrorTypes.REQUIRED;\n\n        // inserts\n        if (!this.operator) {\n          if (!this.isSet || this.value === null || this.value === \"\")\n            return error;\n        }\n\n        // updates\n        else if (this.isSet) {\n          if (\n            (this.operator === \"$set\" && this.value === null) ||\n            this.value === \"\"\n          )\n            return error;\n          if (this.operator === \"$unset\") return error;\n          if (this.operator === \"$rename\") return error;\n        }\n      }\n      return undefined;\n    },\n  },\n  constraint: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  constraint_message: optionalLocalizedString,\n  label: optionalLocalizedString,\n  image: optionalLocalizedString,\n  video: optionalLocalizedString,\n  hint: optionalLocalizedString,\n  guidance_hint: optionalLocalizedString,\n  required_message: optionalLocalizedString,\n  relevant: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  choice_filter: {\n    // Only on 'select*' types\n    type: String,\n    optional: true,\n  },\n  calculation: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  trigger: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  readonly: {\n    type: String,\n    optional: true,\n  },\n  required: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  parameters: {\n    type: String,\n    optional: true,\n  },\n  repeat_count: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  appearance: {\n    type: String,\n    optional: true,\n  },\n  default: {\n    type: String,\n    optional: true,\n  },\n  instance: optionalStringMap,\n  bind: optionalStringMap,\n  body: optionalStringMap,\n});\n\n/** `SimpleSchema` for a row in the `choice` worksheet of an XLSForm. */\nexport const choiceRowSchema = new SimpleSchema({\n  \"list name\": {\n    type: String,\n  },\n  name: {\n    type: String,\n  },\n  label: getLocalizedStringSchemaDefinition(),\n});\n\n/** `SimpleSchema` for a row in the `settings` worksheet of an XLSForm. */\nexport const settingsRowSchema = new SimpleSchema({\n  form_title: {\n    type: String,\n    optional: true,\n  },\n  form_id: {\n    type: String,\n    optional: true,\n  },\n  public_key: {\n    type: String,\n    optional: true,\n  },\n  submission_url: {\n    type: String,\n    optional: true,\n  },\n  default_language: {\n    type: String,\n    optional: true,\n  },\n  version: {\n    type: String,\n    optional: true,\n  },\n});\n","import {\n  choiceRowSchema,\n  questionRowSchema,\n  settingsRowSchema,\n} from \"./RowSchemas\";\n\nexport type StringMap = Record<string, string>;\n\n/**\n * Object with language codes as keys and strings as values, representing localized variants of a\n * string.\n */\n\nexport type LocalizedString = StringMap;\n\n/** Represents a row in the 'survey' worksheet */\n\nexport type QuestionRow = Record<\n  string,\n  string | LocalizedString | undefined\n> & {\n  /** specifies the type of entry you are adding. */\n  type: string;\n  /** specifies the unique variable name for that entry. No two entries can have the same name. Names have to start with a letter or an underscore. Names can only contain letters, digits, hyphens, underscores, and periods. Names are case-sensitive. */\n  name: string;\n  /** contains the actual text you see in the form. Alternatively, label translation columns can be used. */\n  label: LocalizedString;\n  constraint?: string;\n  constraint_message?: LocalizedString;\n  image?: LocalizedString;\n  audio?: LocalizedString;\n  video?: LocalizedString;\n  hint?: LocalizedString;\n  guidance_hint?: string;\n  relevant?: string;\n  choice_filter?: string;\n  calculation?: string;\n  trigger?: string;\n  readonly?: string;\n  required?: string;\n  required_message?: LocalizedString;\n  parameters?: string;\n  repeat_count?: string;\n  appearance?: string;\n  default?: string;\n  instance?: StringMap;\n  bind?: StringMap;\n  body?: StringMap;\n};\n\n/** Represents a row in the 'choices' worksheet */\n\nexport type ChoiceRow = Record<string, string | LocalizedString> & {\n  /** lets you group together a set of related answer choices, i.e., answer choices that should appear together under a question. */\n  \"list name\": string;\n  /** specifies the unique variable name for that answer choice. */\n  name: string;\n  /** shows the answer choice exactly as you want it to appear on the form. Alternatively, label translation columns can be used. */\n  label: LocalizedString;\n};\n\n/** Represents a row in the 'settings' worksheet */\n\nexport type SettingsRow = Record<string, string> & {\n  /** The title of the form that is shown to users. The form title is pulled from form_id if form_title is blank or missing. */\n  form_title: string;\n  /** The name used to uniquely identify the form on the server. The form id is pulled from the XLS file name if form_id is blank or missing. */\n  form_id: string;\n  /** For encryption-enabled forms, this is where the public key is copied and pasted. */\n  public_key: string;\n  /** This url can be used to override the default server where finalized records are submitted to. */\n  submission_url: string;\n  /** In localized forms, this sets which language should be used as the default. The same format as described for adding translations should be used, including the language code. */\n  default_language: string;\n  /** String of up to 10 numbers that describes this revision. Revised form definitions must have numerically greater versions than previous ones. A common convention is to use strings of the form 'yyyymmddrr'. For example, 2017021501 is the 1st revision from Feb 15th, 2017. */\n  version: string;\n};\n\nexport function assertValidQuestionRow(\n  row: Record<string, unknown>\n): asserts row is QuestionRow {\n  return questionRowSchema.validate(row);\n}\n\nexport function assertValidChoiceRow(\n  row: Record<string, unknown>\n): asserts row is ChoiceRow {\n  return choiceRowSchema.validate(row, { keys: [\"list name\", \"name\"] });\n}\n\nexport function assertValidSettingsRow(\n  row: Record<string, unknown>\n): asserts row is SettingsRow {\n  return settingsRowSchema.validate(row);\n}\n","/*\n * A map of string flags that can appear in the `appearance` column of a row in the `survey`\n * worksheet, each with a boolean value indicating if it is set.\n */\ntype AppearanceAttributeFlags = Record<string, boolean> & {\n  /** Best if used with web clients, makes the text box multiple lines long. */\n  multiline?: boolean;\n  /** Answer choices appear in a pull-down menu. */\n  minimal?: boolean;\n  /** Relevant for mobile clients only, this attribute auto-advances the form to the next question after an answer is selected.', */\n  quick?: boolean;\n  /** For mobile devices only, used to suppress the calendar. */\n  \"no-calendar\"?: boolean;\n  /** Select a month and year only for the date. */\n  \"month-year\"?: boolean;\n  /** Select only a year for the date. */\n  year?: boolean;\n  /** For web clients only, this displays the answer choices horizontally. */\n  \"horizontal-compact\"?: boolean;\n  /** For web clients only, this displays the answer choices horizontally, but in columns. */\n  horizontal?: boolean;\n  /** Best if used with web clients, makes the answer choices appear as a Likert scale. */\n  likert?: boolean;\n  /** Displays answer choices side by side with minimal padding and without radio buttons or checkboxes. Particularly useful with image choices.' */\n  compact?: boolean;\n  /** Same as 'compact', but auto-advances to the next question (in mobile clients only). */\n  quickcompact?: boolean;\n  /** Entire group of questions appear on one screen (for mobile clients only). */\n  \"field-list\"?: boolean;\n  /** Displays answer choice labels (and not inputs). */\n  label?: boolean;\n  /** 'Used in conjunction with label attribute above, displays the answer inputs without the labels (make sure to put label and list-nolabel fields inside a group with field-list attribute if using mobile client).' */\n  \"list-nolabel\"?: boolean;\n  /** An easier way to achieve the same appearance as with 'label', apply this attribute to the entire group of questions (might slow down the form a bit). */\n  \"table-list\"?: boolean;\n  /** Allows you to trace your signature into your form (mobile clients only). */\n  signature?: boolean;\n  /** Allows you to sketch a drawing with your finger on the mobile device screen. */\n  draw?: boolean;\n};\n\n/** A set of flags that can appear in the `appearance` column of a row in the `survey` worksheet */\nconst appearanceAttributeFlags: Record<keyof AppearanceAttributeFlags, true> = {\n  multiline: true,\n  minimal: true,\n  quick: true,\n  \"no-calendar\": true,\n  \"month-year\": true,\n  year: true,\n  \"horizontal-compact\": true,\n  horizontal: true,\n  likert: true,\n  compact: true,\n  quickcompact: true,\n  \"field-list\": true,\n  label: true,\n  \"list-nolabel\": true,\n  \"table-list\": true,\n  signature: true,\n  draw: true,\n};\n\n/**\n * Parses a set of flags that can appear in the `appearance` column of a row in the `survey`\n * worksheet, returning a map of flags with their state - `true` if a flag is set and `false` if it\n * is not set.\n */\nexport function parseAttributeFlags(\n  attributeListString: string\n): AppearanceAttributeFlags {\n  const attributeStrings = attributeListString.split(\" \");\n  const result: AppearanceAttributeFlags = {};\n  attributeStrings.forEach((s) => {\n    if (appearanceAttributeFlags[s]) {\n      result[s] = true;\n    }\n  });\n  return result;\n}\n\nexport default AppearanceAttributeFlags;\n","import { parseAttributeFlags } from \"../types/AppearanceAttributeFlags\";\nimport {\n  BeginMarkerRow,\n  BeginOrEndMarkerRow,\n} from \"../types/BeginOrEndMarkerRow\";\nimport { SemanticError } from \"../types/Errors\";\nimport { ODKNode } from \"../types/ODKNode\";\nimport { QuestionRow } from \"../types/RowTypes\";\nimport { normalizeType } from \"./loadSurveyFromXLSX\";\n\nfunction assertNoEndMarker(\n  row: QuestionRow | BeginOrEndMarkerRow,\n  i: number\n): asserts row is QuestionRow | BeginMarkerRow {\n  if (row.type.match(/^end[ _](?:group|repeat)$/)) {\n    throw new SemanticError(\n      `Found '${row.type}' without a matching start marker in row ${\n        i + 2\n      }. Please check that the group/repeat nesting is correct. The row: ${row}`\n    );\n  }\n}\n\n/**\n * Calculates a nested `Node` survey tree model for an array of non-nested survey worksheet rows.\n *\n * This nests everything between `begin_group`…`end_group` and `begin_repeat`…`end_repeat` row\n * markers.\n */\nexport default function nestSurvey({\n  /** flat array of non-nested rows to tree-ify */\n  rows,\n  /** Language name to assume if a column is not localized, for example, `\"English (en)\"` */\n  defaultLanguage,\n  /**\n   * In the XLSForm standard, the root survey node is reachable under the `//data` selector, so we\n   * name it `\"data\"` by default - you can customize this name, if necessary.\n   */\n  formRootNameFromSettings = \"data\",\n  /**\n   * Because it looks intuitive, you can give the root node a title, too. If you supply no title,\n   * the survey form's title is used (if it is defined in the `settings` worksheet).\n   */\n  titleFromSettings = \"\",\n  /**\n   * Called back for each row that is found, with the row and its generated `ODKNode` (if\n   * applicable).\n   */\n  onRow,\n}: {\n  rows: readonly (QuestionRow | BeginOrEndMarkerRow)[];\n  defaultLanguage: string;\n  formRootNameFromSettings?: string;\n  titleFromSettings?: string;\n  onRow?: (row: QuestionRow | BeginOrEndMarkerRow, node: ODKNode) => void;\n}): {\n  node: Readonly<ODKNode>;\n} {\n  const root: ODKNode = {\n    children: [] as ODKNode[],\n    type: \"\",\n    typeParameters: [],\n    rowIndex: -1,\n    indentationLevel: 0,\n    row: {\n      name: formRootNameFromSettings,\n      type: \"\",\n      label: { [defaultLanguage]: titleFromSettings },\n    } as QuestionRow,\n  };\n  const stack: ODKNode[] = [root];\n  let i = 0;\n\n  while (i < rows.length) {\n    const row = rows[i];\n    const [type, ...typeParameters] = normalizeType(row.type).split(\" \");\n    const appearance =\n      row.appearance && row.appearance.trim().length > 0\n        ? parseAttributeFlags(row.appearance)\n        : undefined;\n    const lastOpenedGroup = stack[stack.length - 1];\n\n    if (lastOpenedGroup.type === \"begin_group\" && type === \"end_group\") {\n      // Found an end marker row for the currently open group\n      stack.pop();\n      onRow?.(row, lastOpenedGroup);\n    } else if (\n      // Found an end marker row for the currently open repeat\n      lastOpenedGroup.type === \"begin_repeat\" &&\n      row.type === \"end_repeat\"\n    ) {\n      stack.pop();\n      onRow?.(row, lastOpenedGroup);\n    } else if (type.match(/^begin_(?:repeat|group)$/)) {\n      // Found the beginning of a new nested group or repeat\n      const newGroupNode: ODKNode = {\n        row: row as BeginMarkerRow,\n        type,\n        typeParameters,\n        appearance,\n        children: [],\n        indentationLevel: stack.length - 1,\n        rowIndex: i,\n      };\n      lastOpenedGroup.children.push(newGroupNode);\n      stack.push(newGroupNode);\n      onRow?.(row, newGroupNode);\n    } else {\n      // Assume we found a 'normal', non-nested row\n      assertNoEndMarker(row, i);\n      const newChildNode: ODKNode = {\n        row,\n        type,\n        typeParameters,\n        appearance,\n        indentationLevel: stack.length - 1,\n        rowIndex: i,\n        children: [],\n      };\n      lastOpenedGroup.children.push(newChildNode);\n      onRow?.(row, newChildNode);\n    }\n\n    i += 1;\n  }\n\n  return { node: root };\n}\n","import nestSurvey from \"../functions/nestSurvey\";\nimport { ODKNode } from \"./ODKNode\";\nimport { ChoiceRow, QuestionRow, SettingsRow } from \"./RowTypes\";\n\n/** Represents the content and meta information of a single worksheet in an XLSForm document. */\nexport type XLSFormWorksheet<RowT> = Readonly<{\n  rows: readonly RowT[];\n  languages: Readonly<Set<string>>;\n  columnNames: readonly string[];\n  columnNamesNormalized: readonly string[];\n}>;\n\n/** Represents the content and meta information of the `survey` worksheet in an XLSForm document. */\nexport type SurveyWorksheet = XLSFormWorksheet<QuestionRow>;\n/** Represents the content and meta information of the `choices` worksheet in an XLSForm document. */\nexport type ChoicesWorksheet = XLSFormWorksheet<ChoiceRow>;\n/** Represents the content and meta information of the `settings` worksheet in an XLSForm document. */\nexport type SettingsWorksheet = XLSFormWorksheet<SettingsRow>;\n\nexport type ChoiceRowByName = Record<string, ChoiceRow>;\nexport type ChoiceRowsByListNameAndName = Record<string, ChoiceRowByName>;\n\nexport type FlatNode = {\n  row: Readonly<QuestionRow>;\n  node: Readonly<ODKNode>;\n};\n\n/** Represents content and meta information of an XLSForm document. */\nexport type XLSForm = {\n  worksheets: {\n    survey: SurveyWorksheet;\n    choices?: ChoicesWorksheet;\n    settings?: SettingsWorksheet;\n  };\n  // TODO: Rename this to choiceRowsByNameAndListName\n  choicesByName: Readonly<ChoiceRowsByListNameAndName>;\n  /** The root node of the survey. Contains all groups and fields as descendants. */\n  rootSurveyGroup: Readonly<ODKNode>;\n  /** A set of all languages that the XLSForm uses in column names. */\n  languages: Readonly<Set<string>>;\n  /**\n   * All nodes by their row index. Rows containing `end_group` and `end_repeat` types are mapped\n   * to the same reference as their respective begin marker rows.\n   */\n  flatNodes: readonly ODKNode[];\n};\n\nexport type WorksheetName = keyof XLSForm[\"worksheets\"];\n\nexport type WorksheetRowsWithMetadata<RowT> = {\n  rows: readonly RowT[];\n  languages: Readonly<Set<string>>;\n  columnNames: readonly string[];\n  columnNamesNormalized: readonly string[];\n};\n\n/**\n * Creates a map of choice list names -> choice names -> choice rows from the `choices` worksheet\n * of an XLSForm\n */\nexport function loadChoices(\n  worksheet: ChoicesWorksheet\n): ChoiceRowsByListNameAndName {\n  const map: ChoiceRowsByListNameAndName = {};\n\n  worksheet.rows.forEach((row) => {\n    const listName = row[\"list name\"];\n    const { name } = row;\n    const list = map[listName] || {};\n    list[name] = row;\n    map[listName] = list;\n  });\n\n  return map;\n}\n\n/**\n * @returns an XLSForm model created from raw worksheet rows.\n */\nexport function loadXLSFormFromRows(\n  survey: Readonly<WorksheetRowsWithMetadata<QuestionRow>>,\n  defaultLanguage: string,\n  settings?: WorksheetRowsWithMetadata<SettingsRow>,\n  choices?: WorksheetRowsWithMetadata<ChoiceRow>\n) {\n  const flatNodes: ODKNode[] = [];\n  const { node: rootSurveyGroup } = nestSurvey({\n    rows: survey.rows,\n    defaultLanguage,\n    onRow: (row, node) => flatNodes.push(node),\n  });\n\n  const xlsForm: XLSForm = {\n    worksheets: {\n      settings,\n      choices,\n      survey,\n    },\n    rootSurveyGroup,\n    choicesByName: choices ? loadChoices(choices) : {},\n    languages: survey.languages,\n    flatNodes,\n  };\n  return xlsForm;\n}\n","import Excel from \"exceljs\";\nimport { SyntaxError } from \"../types/Errors\";\nimport {\n  choiceRowSchema,\n  questionRowSchema,\n  settingsRowSchema,\n} from \"../types/RowSchemas\";\nimport {\n  assertValidChoiceRow,\n  assertValidQuestionRow,\n  assertValidSettingsRow,\n  ChoiceRow,\n  QuestionRow,\n  SettingsRow,\n} from \"../types/RowTypes\";\nimport {\n  loadXLSFormFromRows,\n  WorksheetName,\n  WorksheetRowsWithMetadata,\n  XLSForm,\n} from \"../types/XLSForm\";\n\nexport const localizableColumnNames = [\n  \"label\",\n  \"hint\",\n  \"constraint_message\",\n  \"required_message\",\n  \"image\",\n  \"audio\",\n  \"video\",\n];\n\n/**\n * XLSForm uses double colons (`::`) in column names to allow multilingual variants of the same\n * column, like ‘label::русский (ru)’ or ‘label::English (en)’, and for custom namespacing.\n *\n * For each column name that supports this concept, the function finds matching columns in the\n * given row, and merges them them into a single object.\n *\n * You can supply a default suffix to always obtain namespaced objects after processing a row.\n *\n * @see [‘Advanced use and extensibility’](https://xlsform.org/en/#advanced-use-and-extensibility)\n * in the XLSForm specification.\n *\n * @example\n * // before\n *\n * {\n *   'label::русский (ru)': 'Как тебя зовут?',\n *   'label::English (en)': 'What is your name?'\n * }\n *\n * // after\n *\n * {\n *   label: {\n *     'русский (ru)': 'Как тебя зовут?',\n *     'English (en)': 'What is your name?'\n *   }\n * }\n */\nexport function nestDoubleColonFields(\n  /** The row to process. */\n  row: Record<string, unknown>,\n  /** The prefixes before the :: that you want nested */\n  namespacePrefixes: string[],\n  /**\n   * Use this to enforce the result to be always nested, even if a localizable column is not\n   * localized.\n   */\n  defaultSuffix?: string\n): {\n  result: Readonly<Record<string, unknown>>;\n  foundSuffixes: Readonly<Set<string>>;\n} {\n  const result: Record<string, unknown> = {\n    ...row,\n  };\n\n  const foundSuffixes = new Set<string>();\n\n  if (defaultSuffix) {\n    namespacePrefixes.forEach((k) => {\n      if (result[k]) {\n        result[`${k}::${defaultSuffix}`] = result[k];\n      }\n      foundSuffixes.add(defaultSuffix);\n      delete result[k];\n    });\n  }\n\n  namespacePrefixes.forEach((namespacePrefix) => {\n    Object.keys(result)\n      .filter((k) => k.startsWith(namespacePrefix))\n      .forEach((k) => {\n        const [prefix, suffix] = k.split(/::/);\n        /* Example { 'label::English (en)': 'A label!' } */\n        const objectToExtend = result[prefix] as\n          | Record<string, string>\n          | string;\n        const value = String(result[k]);\n        if (objectToExtend === undefined) {\n          result[prefix] = { [suffix]: value };\n          foundSuffixes.add(suffix);\n        } else if (typeof objectToExtend === \"object\") {\n          objectToExtend[suffix] = value;\n          foundSuffixes.add(suffix);\n        } else {\n          throw new SyntaxError(\n            `Can't handle \\`${prefix}\\` column. Columns with prefix \\`${prefix}\\` must be namespaced with \\`::\\`. See chapter [‘Advanced use and extensibility’](https://xlsform.org/en/#advanced-use-and-extensibility) in the documentation.`\n          );\n        }\n        delete result[k];\n      });\n  });\n\n  return { result, foundSuffixes };\n}\n\n// See reference table: https://xlsform.org/en/ref-table/\n\nexport function normalizeColumnNames(\n  headerRow: readonly string[]\n): readonly string[] {\n  const result: string[] = [];\n  for (let i = 0; i < headerRow.length; i += 1) {\n    const columnName = headerRow[i]?.toString() || \"\";\n    result.push(\n      columnName\n        .replace(/^constraint-msg\\B/, \"constraint_message\")\n        .replace(/^requiredMsg\\B/, \"required_message\")\n        .replace(/^bind::required$/, \"required\")\n        .replace(/^repeat-count$/, \"repeat_count\")\n        .replace(/^media::(image|audio|video)\\B/, \"$1\")\n        .replace(/^photo\\B/, \"image\")\n        .replace(/^list_name$/, \"list name\")\n    );\n  }\n  return Object.freeze(result);\n}\n\n// See reference table: https://xlsform.org/en/ref-table/. For groups and repeats, we deviate from\n// the reference to always use underscores, making a type name recognizable with a [a-z_]+ regex\n// pattern.\n\nexport function normalizeType(type: string): string {\n  return type\n    .replace(/^media::(image|audio|video)\\B/, \"$1\")\n    .replace(/^imei$/, \"deviceid\")\n    .replace(/^phone_number$/, \"phonenumber\")\n    .replace(/^select one\\B/, \"select_one\")\n    .replace(/^select multiple\\B/, \"select_multiple\")\n    .replace(/^location$/, \"geopoint\")\n    .replace(/^photo\\B/, \"image\")\n    .replace(/^trigger$/, \"acknowledge\")\n    .replace(/^begin group$/, \"begin_group\")\n    .replace(/^end group$/, \"end_group\")\n    .replace(/^begin repeat$/, \"begin_repeat\")\n    .replace(/^end repeat$/, \"end_repeat\");\n}\n\nconst autoCleanOptions = {\n  getAutoValues: true,\n  trimStrings: true,\n  mutate: false,\n};\n\n// Loads a plain object, cleans it up and throws if it’s not a valid row from a `survey` worksheet.\nexport function loadQuestionRow(row: Record<string, unknown>): QuestionRow {\n  const cleanRow = questionRowSchema.clean(\n    { ...row, type: normalizeType(String(row.type)) },\n    autoCleanOptions\n  );\n  assertValidQuestionRow(cleanRow);\n  return cleanRow;\n}\n\n// Loads a plain object, cleans it up and throws if it’s not a valid row from a `choices` worksheet.\nexport function loadChoicesRow(row: Record<string, unknown>): ChoiceRow {\n  const cleanRow = choiceRowSchema.clean(row, {\n    ...autoCleanOptions,\n    filter: false,\n  });\n  assertValidChoiceRow(cleanRow);\n  return cleanRow;\n}\n\n// Loads a plain object, cleans it up and throws if it’s not a valid row from a `settings` worksheet.\nexport function loadSettingsRow(row: Record<string, unknown>): SettingsRow {\n  const cleanRow = settingsRowSchema.clean(row, autoCleanOptions);\n  assertValidSettingsRow(cleanRow);\n  return cleanRow;\n}\n\ntype LoadRowFunction<T> = (row: Record<string, unknown>) => T;\n\n// Turns a plain ExcelJS row into a handier data model, cleaning it up and throwing if it’s invalid.\nexport function loadExcelRow<RowT>({\n  row,\n  columnNames,\n  defaultLanguage,\n  loadRowFn,\n}: {\n  readonly row: Excel.Row;\n  readonly columnNames: readonly string[];\n  readonly defaultLanguage: string | undefined;\n  readonly loadRowFn: LoadRowFunction<RowT>;\n}) {\n  const rowRawData: Record<string, unknown> = {};\n  (row.values as Excel.CellValue[]).slice(1).forEach((value, columnIndex) => {\n    const columnName = columnNames[columnIndex];\n    rowRawData[columnName] = `${value}`;\n  });\n  const { result: rowDataWithLocalizedStrings } = nestDoubleColonFields(\n    rowRawData,\n    localizableColumnNames,\n    defaultLanguage\n  );\n  const {\n    result: rowDataWithNamespacedFields,\n  } = nestDoubleColonFields(rowDataWithLocalizedStrings, [\n    \"instance\",\n    \"bind\",\n    \"body\",\n  ]);\n  try {\n    return loadRowFn(rowDataWithNamespacedFields);\n  } catch (error) {\n    throw new SyntaxError(\n      `Could not load row ${JSON.stringify(\n        rowDataWithNamespacedFields,\n        null,\n        2\n      )}: ${error} / ${JSON.stringify(error.details)}`\n    );\n  }\n}\n\n/**\n * @returns a set of localization language names from a given list of column names.\n *\n * @example\n * findLanguagesInColumnNames([\n *   'label::русский (ru)',\n *   'label::English (en)'\n * ]) // -> ['русский (ru)', 'English (en)']\n *\n * findLanguagesInColumnNames(['label']) // -> ['English (en)']\n */\nfunction findLanguagesInColumnNames(\n  columnNames: readonly string[],\n  defaultLanguage?: string\n): Readonly<Set<string>> {\n  const columnNamesToTrues: Record<string, unknown> = {};\n  columnNames.forEach((name) => {\n    columnNamesToTrues[name] = true;\n  });\n  const { foundSuffixes } = nestDoubleColonFields(\n    columnNamesToTrues,\n    localizableColumnNames,\n    defaultLanguage\n  );\n  return foundSuffixes;\n}\n\n/**\n * Loads an worksheet from an ExcelJS workbook and returns the sheet in our internal data model.\n */\nfunction loadWorksheet<RowT>(\n  /** The ExcelJS `Workbook` from which the sheet should be loaded. */\n  workbook: Excel.Workbook,\n  /** Name of the worksheet, for example, `\"survey\"` */\n  sheetName: WorksheetName,\n  /** Function to process, clean up, and load a single row into our internal row data model. */\n  loadRowFn: LoadRowFunction<RowT>,\n  /** Default language to assume if a column is not localized. */\n  defaultLanguage?: string\n): WorksheetRowsWithMetadata<RowT> | undefined {\n  const excelWorksheet = workbook.getWorksheet(sheetName);\n  const rows: RowT[] = [];\n\n  if (!excelWorksheet) {\n    return undefined;\n  }\n\n  const firstRow = excelWorksheet.getRows(1, 1)[0];\n  if (!(firstRow.values instanceof Array)) {\n    throw new SyntaxError(\n      `First row of the ‘${sheetName}’ worksheet must be an array structure, but is a ${typeof firstRow.values} instead. Please fix this.`\n    );\n  }\n\n  // Normalize column names because XLSForm implementations vary, unfortunately\n  const columnNames = firstRow.values\n    .slice(1)\n    .map((cellValue) => cellValue?.toString() || \"\");\n  const columnNamesNormalized = normalizeColumnNames(columnNames);\n\n  const languages = findLanguagesInColumnNames(\n    columnNamesNormalized,\n    defaultLanguage\n  );\n\n  // Apply given row loading function to all rows\n  excelWorksheet.eachRow((row, rowIndex) => {\n    if (rowIndex === 1) {\n      return;\n    }\n    rows.push(\n      loadExcelRow<RowT>({\n        row,\n        columnNames: columnNamesNormalized,\n        defaultLanguage,\n        loadRowFn,\n      })\n    );\n  });\n\n  return { rows, languages, columnNames, columnNamesNormalized };\n}\n\n/**\n * Loads a given ExcelJS workbook.\n *\n * @returns an `XLSForm` model.\n */\nexport async function loadFormFromExcelWorkbook(\n  /** The ExcelJS workbook to load as XLSForm model. */\n  workbook: Excel.Workbook\n): Promise<XLSForm> {\n  const settings = loadWorksheet(workbook, \"settings\", loadSettingsRow);\n  const defaultLanguage = settings?.rows[0].default_language || \"English (en)\";\n  const choices = loadWorksheet(\n    workbook,\n    \"choices\",\n    loadChoicesRow,\n    defaultLanguage\n  );\n  const survey = loadWorksheet(\n    workbook,\n    \"survey\",\n    loadQuestionRow,\n    defaultLanguage\n  );\n\n  if (!survey) {\n    throw new Error(\n      \"No `survey` sheet found in workbook. Please define a sheet named `survey` and try again.\"\n    );\n  }\n\n  const xlsForm: XLSForm = loadXLSFormFromRows(\n    survey,\n    defaultLanguage,\n    settings,\n    choices\n  );\n\n  return xlsForm;\n}\n\n/**\n * Loads a given ExcelJS workbook from a local file (works only in NodeJS environment, not in a\n * browser).\n *\n * @returns an `XLSForm` model.\n */\nexport default async function loadFormFromXLSXFile(\n  /** Name of the Excel (.xlsx) file containing the XLSForm definition. */\n  filename: string\n): Promise<XLSForm> {\n  const workbook = new Excel.Workbook();\n  await workbook.xlsx.readFile(filename);\n  return loadFormFromExcelWorkbook(workbook);\n}\n","import { cloneDeep, get, set } from \"lodash\";\nimport { evaluatableColumnNames, ODKNode } from \"../../types/ODKNode\";\nimport { QuestionRow } from \"../../types/RowTypes\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport { localizableColumnNames } from \"../loadSurveyFromXLSX\";\n\nexport type NodeDependency = {\n  node: ODKNode;\n  index: number;\n  row: QuestionRow;\n  columnName: string;\n};\n\n/**\n * Refactoring feature: Finds or replaces all references to a given field in other fields, so the\n * survey developer doesn't have to rename every reference manually.\n */\nexport default function findOrReplaceFieldReferences(\n  xlsForm: XLSForm,\n  node: ODKNode,\n  replaceName?: string\n) {\n  const oldName = node.row.name;\n  const nodeDependency: NodeDependency[] = [];\n  const variableRegexp = new RegExp(`\\\\\\${${oldName}}`);\n  xlsForm.flatNodes.forEach((n) => {\n    let row: QuestionRow | undefined;\n    const localizableKeys = localizableColumnNames.flatMap((lcn) =>\n      [...xlsForm.languages.values()].map((lang) => `${lcn}.${lang}`)\n    );\n    (evaluatableColumnNames as string[])\n      .concat(...localizableKeys)\n      .forEach((columnName) => {\n        const value = get(n.row, columnName);\n        if (typeof value !== \"string\" && value !== undefined) {\n          throw new Error(\n            `Replacing variable names works only with string cells. Please ensure the ${columnName} cell of the ${node.row.name} row has a string value.`\n          );\n        }\n        if (value?.match(variableRegexp)) {\n          if (replaceName) {\n            const newCellValue = value?.replaceAll(\n              `\\${${oldName}}`,\n              `\\${${replaceName}}`\n            );\n            row = row || cloneDeep(n.row);\n            set(row, columnName, newCellValue);\n          }\n          nodeDependency.push({\n            node: n,\n            index: n.rowIndex,\n            row: row || n.row,\n            columnName,\n          });\n        }\n      });\n  });\n  return nodeDependency;\n}\n","import ODKFormulaEvaluationResult from \"./odk-formulas/evaluation/ODKFormulaEvaluationResult\";\n\n/**\n * @returns name of the first found column with a formula parsing/evaluation error.\n */\nexport function getFirstColumnNameWithError(\n  nodeEvaluationResults: Map<string, ODKFormulaEvaluationResult> | undefined\n) {\n  return (\n    nodeEvaluationResults &&\n    [...nodeEvaluationResults.keys()].find(\n      (k) => nodeEvaluationResults?.get(k)?.error\n    )\n  );\n}\n","import { ODKNode } from \"./ODKNode\";\nimport { assertValidQuestionRow } from \"./RowTypes\";\n\n/** Throws an error of the given untyped object is not a valid ODK Node. */\nexport function assertIsODKNode(node: any): asserts node is ODKNode {\n  const error = () => {\n    throw new Error(\"Given data is not a valid ODK node.\");\n  };\n  if (typeof node !== \"object\") {\n    error();\n  }\n\n  assertValidQuestionRow(node.row);\n  if (\n    typeof node.type !== \"string\" ||\n    !(node.typeParameters instanceof Array) ||\n    !node.typeParameters.every((p: unknown) => typeof p === \"string\") ||\n    typeof node.indentationLevel !== \"number\" ||\n    typeof node.rowIndex !== \"number\" ||\n    (node.resultIsInvalid !== undefined &&\n      typeof node.resultIsInvalid !== \"boolean\")\n  ) {\n    error();\n  }\n  node.children.forEach(assertIsODKNode);\n}\n","import * as React from \"react\";\nimport ODKFormulaEvaluationContext from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeAbsolutePathString } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { assertIsODKNode } from \"../xlsform-simple-schema/types/assertIsODKNode\";\nimport { ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\n\nexport type DropNodeHandler = (options: {\n  sourceNode: ODKNode;\n  destinationNode: ODKNode;\n  sourcePath: string;\n  position: \"before\" | \"after\" | \"inside\";\n}) => void;\n\nexport const ODKNodeDragAndDropContext = React.createContext<{\n  onDropNode: DropNodeHandler;\n}>({ onDropNode: () => {} });\n\n/**\n * @returns a set of props that you can add to a React node to add field drag & drop features to\n * it. Makes the element draggable, and allows to drag ODK nodes over and onto the element.\n */\n\nexport function useNodeDragAndDrop({\n  node,\n  evaluationContext,\n  setIsDraggedOver,\n}: {\n  /** The ODK node model that will be transferred when dragging & dropping */\n  node: ODKNode;\n  /** The source evaluation context in which to find the source node */\n  evaluationContext?: ODKFormulaEvaluationContext;\n  /**\n   * A React state setter method to allow the UI to show that it is a potential drop target while\n   * dragging over it\n   */\n  setIsDraggedOver: React.Dispatch<React.SetStateAction<boolean>>;\n}) {\n  const { onDropNode } = React.useContext(ODKNodeDragAndDropContext);\n\n  const onDragStart = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      if (!evaluationContext) {\n        return;\n      }\n      event.dataTransfer.setData(\n        \"application/json\",\n        JSON.stringify({\n          sourceNode: node,\n          sourcePath: getNodeAbsolutePathString(node, evaluationContext),\n        })\n      );\n    },\n    [evaluationContext, node]\n  );\n\n  const onDragOver = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      event.preventDefault();\n      if (!evaluationContext) {\n        return;\n      }\n      setIsDraggedOver(true);\n    },\n    [evaluationContext, setIsDraggedOver]\n  );\n\n  const onDrop = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      if (!evaluationContext) {\n        return;\n      }\n      const path = getNodeAbsolutePathString(node, evaluationContext);\n      const data = JSON.parse(event.dataTransfer.getData(\"application/json\"));\n      const { sourcePath, sourceNode } = data;\n      assertIsODKNode(sourceNode);\n      console.log(\"Dropped on path\", path);\n      setIsDraggedOver(false);\n      onDropNode({\n        sourceNode,\n        sourcePath,\n        destinationNode: node,\n        position: \"before\",\n      });\n    },\n    [evaluationContext, node, onDropNode, setIsDraggedOver]\n  );\n\n  const onDragLeave = React.useCallback(() => {\n    if (!evaluationContext) {\n      return;\n    }\n    const path = getNodeAbsolutePathString(node, evaluationContext);\n    console.log(\"Left dragging at path\", path);\n    setIsDraggedOver(false);\n  }, [evaluationContext, node, setIsDraggedOver]);\n\n  const dragProps = {\n    draggable: true,\n    onDragStart,\n    onDragOver,\n    onDragLeave,\n    onDrop,\n  };\n\n  return dragProps;\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport { omit } from \"lodash\";\nimport marked from \"marked\";\nimport * as React from \"react\";\nimport unindent from \"./unindent\";\n\ninterface IProps extends React.HTMLProps<HTMLDivElement> {\n  children: React.ReactNode;\n  /** Use this to supply any markdown compiler function that can convert a Markdown string to a HTML string */\n  marked: (markdown: string) => string;\n  /** Removes <p></p> tags around the markdown code */\n  inline?: boolean;\n}\n\nfunction MarkdownDiv(props: IProps) {\n  if (typeof props.children !== \"string\") {\n    return (\n      <Callout intent=\"danger\">Markdown content must be a string.</Callout>\n    );\n  }\n  let html = props.marked?.(unindent(props.children));\n  if (props.inline) {\n    html = html.replaceAll(/<\\/?p>/g, \"\");\n  }\n  return (\n    <div\n      {...omit(props, \"children\", \"marked\", \"inline\")}\n      dangerouslySetInnerHTML={{\n        __html: html,\n      }}\n    />\n  );\n}\n\n// Use this code to load the component lazily at runtime.\n// const Markdown = LoadableMap({\n//   loader: {\n//     marked: () => import(\"marked\"),\n//   },\n//   render(loaded, props: IProps) {\n//     return <MarkdownDiv {...props} marked={loaded.marked?.default} />;\n//   },\n//   loading: () => null,\n// });\n\n/**\n * React component that displays a given Markdown as formatted output. Allows arbitrary indentation\n * of the whole code for readability.\n *\n * @example\n *   <Markdown>{`\n *     # A header\n *\n *     ## A secondary header\n *\n *     - a list item\n *     - another list item\n *   `}</Markdown>\n */\nfunction Markdown(props: {\n  children: React.ReactNode;\n  /** Removes <p></p> tags around the markdown code */\n  inline?: boolean;\n}) {\n  return <MarkdownDiv {...props} marked={marked} />;\n}\n\nexport default Markdown;\n","/**\n * Removes first level of whitespace indentation from a given string by recognizing the indentation\n * level from the first line that has non-whitespace content contains  to remove.\n *\n * This allows to specify hardcoded strings with indentation in code without having to break the\n * code's own indentation:\n *\n * @example\n *   // before:\n *   function getMarkdown() {\n *     return `\n *   # Hello\n *\n *   - this is a markdown list\n *   - with multiple items\n *   `;\n *   }\n *\n *   // with unindent:\n *   function getMarkdown() {\n *     return unindent(`\n *       # Hello\n *\n *       - this is a markdown list\n *       - with multiple items\n *     `);\n *   }\n*/\nexport default function unindent(input: string): string {\n  const firstLineWithContent = input\n    .split(/\\n/)\n    .find(line => line.replace(/\\s/, '').length > 0);\n  if (!firstLineWithContent) {\n    return input;\n  }\n\n  const matchedIndentation = firstLineWithContent.match(/^\\s+/);\n  if (!matchedIndentation) {\n    return input;\n  }\n\n  const matchedIndentationString = matchedIndentation[0];\n  if (!matchedIndentationString) {\n    return input;\n  }\n\n  const indentationRegExp = new RegExp(`^${matchedIndentationString}`);\n  return input\n    .split(/\\n/)\n    .map(line => line.replace(indentationRegExp, ''))\n    .join('\\n');\n}\n","import styled from \"styled-components\";\nimport Markdown from \"./Markdown\";\n\nconst StyledMarkdown = styled(Markdown)`\n  h1,\n  h2,\n  h3,\n  h4,\n  h5 {\n    margin: 1em 0;\n  }\n\n  code,\n  pre {\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n    color: inherit;\n    margin: -1px;\n    padding: 2px 3px;\n    background-color: rgba(255, 255, 255, 0.3);\n    @media (prefers-color-scheme: dark) {\n      background-color: rgba(0, 0, 0, 0.1);\n    }\n  }\n\n  pre {\n    padding: 0.5em 0.55em;\n    margin: 0.5em 0;\n    line-height: 1.3em;\n    white-space: pre-wrap;\n  }\n\n  code {\n    font-weight: 600;\n  }\n\n  p {\n    margin-block-end: 16px;\n  }\n  p:last-child {\n    margin-block-end: 0;\n  }\n\n  ul,\n  ol {\n    margin: 1em 1.25em;\n  }\n`;\n\nexport default StyledMarkdown;\n","import { TokenType } from \"../pratt-parser-base\";\nimport LiteralExpression from \"../pratt-parser-base/expressions/LiteralExpression\";\n\n/**\n * @returns an evaluatable formula literal usable in an AST and for syntax highlighting.\n */\nexport default function createLiteralExpressionFromValue(value: unknown) {\n  return new LiteralExpression(\n    [{ type: TokenType.LITERAL, text: JSON.stringify(value), index: -1 }],\n    value instanceof Array ? \"array\" : typeof value,\n    value\n  );\n}\n","import { Classes, Text } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { EvaluatableColumnName } from \"../../xlsform-simple-schema/types/ODKNode\";\n\n/** Shows a text explaining what happens if a formula-based XLSForm cell is empty. */\nexport function DefaultValueExplanation({\n  answer,\n  columnName,\n  nodeName,\n}: {\n  answer: unknown;\n  columnName: EvaluatableColumnName;\n  nodeName: string;\n}) {\n  return (\n    <Text className={Classes.TEXT_MUTED}>\n      {\n        {\n          calculation:\n            answer === undefined || answer === \"\" ? (\n              <>\n                This survey field has no entered answer yet, and the{\" \"}\n                <code>{columnName}</code> cell is empty.\n              </>\n            ) : (\n              <>\n                This is the answer value entered in the <code>{nodeName}</code>{\" \"}\n                field.\n              </>\n            ),\n          required: (\n            <>\n              This means users are not required to enter this field. This is the\n              default when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          relevant: (\n            <>\n              This means the survey field is always shown. This is the default\n              behavior when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          readonly: (\n            <>\n              This means the survey field enables input. This is the default\n              behavior when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          constraint: (\n            <>\n              If the cell contains a formula that evaluates to <code>true</code>{\" \"}\n              or if there is no formula in the <code>{columnName}</code> cell,\n              the field accepts any input.\n            </>\n          ),\n        }[columnName]\n      }\n    </Text>\n  );\n}\n","import { Classes, Text } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { EvaluatableColumnName } from \"../../xlsform-simple-schema/types/ODKNode\";\n\n/**\n * Displays an explanation of a formula result — what effect will it have for end users?\n */\nexport function FormulaResultMeaning({\n  results,\n  columnName,\n  formulaIsTrivial,\n}: {\n  results: ODKFormulaEvaluationResult;\n  columnName: EvaluatableColumnName;\n  formulaIsTrivial: boolean;\n}) {\n  return (\n    <Text className={Classes.TEXT_MUTED}>\n      {\n        {\n          calculation:\n            !formulaIsTrivial &&\n            (results.error ? (\n              <>Because of this error, the field has no result yet.</>\n            ) : (\n              <>This is the result of the formula.</>\n            )),\n          required: `This means you ${\n            results?.result ? \"can’t\" : \"can\"\n          } complete the survey without entering data in this field.`,\n          relevant: `This means the survey field is ${\n            results?.result ? \"shown\" : \"hidden\"\n          }.`,\n          readonly: `This means the survey field is ${\n            results?.result ? \"read-only\" : \"editable\"\n          }.`,\n          constraint: `This means the survey field contains an input that is ${\n            results?.result ? \"allowed\" : \"not allowed\"\n          } by the constraint formula..`,\n        }[columnName]\n      }\n    </Text>\n  );\n}\n","import { Callout, Colors, Icon } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { useDarkMode } from \"../../components/DarkModeContainer\";\nimport HighlightedExpression from \"../../components/HighlightedExpression/HighlightedODKExpression\";\nimport StyledMarkdown from \"../../components/StyledMarkdown\";\nimport { alpha } from \"../../lib/colors\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport createLiteralExpressionFromValue from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/createLiteralExpressionFromValue\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { NameExpression } from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport LiteralExpression from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/LiteralExpression\";\nimport { EvaluationError } from \"../../xlsform-simple-schema/types/Errors\";\nimport {\n  EvaluatableColumnName,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { DefaultValueExplanation } from \"./DefaultValueExplanation\";\nimport {\n  StyledCalloutWithCode,\n  StyledCodeBlock,\n  StyledPanel,\n} from \"./FieldPopoverButton\";\nimport { FormulaResultMeaning } from \"./FormulaResultMeaning\";\n\n/**\n * Visual debugger for XLSForm cells that support formulas. Shows the cell's syntax-highlighted\n * formula, the calculated result, and explanations.\n */\nexport function ExpressionPanel({\n  node,\n  columnName,\n  nodeEvaluationResult,\n  style,\n}: {\n  node: ODKNode;\n  columnName: EvaluatableColumnName;\n  nodeEvaluationResult: ODKFormulaEvaluationResult | undefined;\n  style?: React.CSSProperties;\n}) {\n  const isDarkMode = useDarkMode();\n  const context = React.useContext(ODKSurveyContext);\n  const cellValue = node.row[columnName];\n  const results = nodeEvaluationResult;\n  const cellIsEmpty = cellValue === undefined;\n  const isLiteral = results?.expression?.kind === \"literal\";\n  const isName = results?.expression?.kind === \"name\";\n  const answer = context.evaluationContext?.nodesToAnswers.get(node);\n  const nodeName = context.evaluationContext\n    ? getNodeAbsolutePathString(node, context.evaluationContext)\n    : node.row.name;\n\n  const formulaIsTrivial =\n    results?.expression instanceof LiteralExpression ||\n    (results?.expression instanceof NameExpression &&\n      results?.expression.name === results?.expression.text);\n\n  let title: React.ReactNode = \"Result\";\n  if (cellIsEmpty) {\n    if (columnName === \"calculation\") {\n      if (answer !== undefined) {\n        title = \"Using answer value\";\n      }\n    } else {\n      title = \"Default value\";\n    }\n  } else {\n    title = (\n      <>\n        <Icon icon=\"function\" />{\" \"}\n        {columnName === \"calculation\" ? \"Formula\" : \"Condition\"}\n      </>\n    );\n  }\n\n  const panel = (\n    <StyledPanel\n      lang=\"en\"\n      style={{\n        backgroundColor: Colors.LIGHT_GRAY5,\n        marginTop: \"0\",\n        padding: \"20px\",\n        background: `linear-gradient(${alpha(Colors.BLUE3, 0.06)}, ${alpha(\n          Colors.BLUE3,\n          0.05\n        )} 5px, ${alpha(Colors.BLUE3, 0.01)} 10px, transparent 30px)`,\n        borderTop: `solid 1px ${\n          isDarkMode ? Colors.DARK_GRAY2 : Colors.LIGHT_GRAY3\n        }`,\n        ...style,\n      }}\n    >\n      <h4>{title}</h4>\n\n      {!cellIsEmpty && (\n        <>\n          <StyledCodeBlock\n            style={{\n              fontSize: isLiteral || isName ? \"20px\" : \"16px\",\n              lineHeight: \"28px\",\n            }}\n          >\n            <HighlightedExpression\n              node={node}\n              state={results?.state}\n              error={results?.error}\n              expression={results?.expression}\n            />\n          </StyledCodeBlock>\n        </>\n      )}\n\n      {(cellIsEmpty || !formulaIsTrivial) && (\n        <>\n          {!cellIsEmpty && !results && (\n            <Callout intent=\"none\">Not calculated yet.</Callout>\n          )}\n          {results?.state !== \"error\" && (\n            <StyledCodeBlock style={{ fontSize: \"20px\", lineHeight: \"28px\" }}>\n              {!formulaIsTrivial && <>=&nbsp;</>}\n              {results?.result === undefined ? (\n                \"undefined\"\n              ) : (\n                <HighlightedExpression\n                  node={node}\n                  state={results?.state}\n                  error={results?.error}\n                  expression={createLiteralExpressionFromValue(results?.result)}\n                />\n              )}\n            </StyledCodeBlock>\n          )}\n        </>\n      )}\n\n      {results?.state === \"error\" && (\n        <StyledCalloutWithCode intent=\"danger\">\n          {results.error instanceof EvaluationError && (\n            <>\n              Error in&nbsp;\n              <code>\n                <HighlightedExpression\n                  node={node}\n                  expression={results.error.expression}\n                />\n              </code>\n              :\n            </>\n          )}\n          <StyledMarkdown>{results.error.toMarkdown()}</StyledMarkdown>\n        </StyledCalloutWithCode>\n      )}\n\n      {!cellIsEmpty && results?.result !== undefined && (\n        <FormulaResultMeaning {...{ results, columnName, formulaIsTrivial }} />\n      )}\n\n      {cellIsEmpty && (\n        <DefaultValueExplanation {...{ answer, columnName, nodeName }} />\n      )}\n    </StyledPanel>\n  );\n  return panel;\n}\n","import { Breadcrumbs } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\n/**\n * Shows all parent groups of a field and the field’s name in breadcrumb layout.\n */\nexport function FieldPathBreadcrumbs({\n  path,\n  width,\n}: {\n  path: string[];\n  width: number;\n}) {\n  return (\n    <Breadcrumbs\n      items={path.map((k, i) => ({\n        href: `#//${path.slice(0, i + 1).join(\"/\")}`,\n        text: k,\n      }))}\n      collapseFrom=\"start\"\n      overflowListProps={{\n        minVisibleItems: 1,\n        style: {\n          transition: \"width 0.1s ease-out\",\n          width: `${width}px`,\n        },\n      }}\n    />\n  );\n}\n","export const fieldTypeNames: Record<string, string> = {\n  integer: \"Integer number\",\n  decimal: \"Decimal number\",\n  range: \"Slider\",\n  text: \"Text field\",\n  select_one: \"Single choice\",\n  select_one_from_file: \"Single choice from file\",\n  select_multiple: \"Multiple choice\",\n  select_multiple_from_file: \"Multiple choice from file\",\n  rank: \"Rank items\",\n  note: \"Note / Hint\",\n  geopoint: \"Locate a point\",\n  geotrace: \"Trace a line\",\n  geoshape: \"Draw a shape\",\n  date: \"Date\",\n  time: \"Time\",\n  datetime: \"Date and time\",\n  image: \"Image\",\n  audio: \"Audio\",\n  video: \"Video\",\n  file: \"File\",\n  barcode: \"Scan a code\",\n  acknowledge: \"Checkbox\",\n  calculate: \"Calculate formula\",\n  hidden: \"Hidden field\",\n  \"xml-external\": \"External XML reference\",\n  start: \"Survey start date and time\",\n  end: \"Survey submission date and time\",\n  today: \"Survey start day\",\n  deviceid: \"Device ID\",\n  simserial: \"SIM serial number\",\n  subscriberid: \"Subscriber ID\",\n  phonenumber: \"Phone number\",\n  username: \"Username\",\n  email: \"Email address\",\n  audit: \"Audit trail\",\n  begin_group: \"Field group\",\n  begin_repeat: \"Repeat group\",\n};\n","import {\n  Callout,\n  Checkbox,\n  Classes,\n  Code,\n  ControlGroup,\n  Menu,\n  Text,\n} from \"@blueprintjs/core\";\nimport { sortBy, without } from \"lodash\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { XLSForm } from \"../../xlsform-simple-schema\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { QuestionRow } from \"../../xlsform-simple-schema/types/RowTypes\";\n\n/** Displays all defined XLSForm survey choice lists as selectable checkboxes. */\nexport function ChoiceListMenu({\n  xlsForm,\n  node,\n}: {\n  xlsForm: XLSForm;\n  node: ODKNode;\n}) {\n  const choiceListsByName = xlsForm?.choicesByName;\n  const choiceListNames = choiceListsByName\n    ? Object.keys(choiceListsByName)\n    : [];\n  const context = React.useContext(ODKSurveyContext);\n\n  const onChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const checked = event.currentTarget.checked;\n      const choiceListName = event.currentTarget.value;\n      let typeParameters = [...node.typeParameters];\n      if (checked) {\n        typeParameters.push(choiceListName);\n      } else {\n        typeParameters = without(typeParameters, choiceListName);\n      }\n      const newTypeValue = [node.type, ...typeParameters].join(\" \");\n      const newRow: QuestionRow = {\n        ...node.row,\n        type: newTypeValue,\n      };\n      const description = checked\n        ? `Add \\`${choiceListName}\\` choice list to \\`${node.row.name}\\``\n        : `Remove \\`${choiceListName}\\` choice list from \\`${node.row.name}\\``;\n      context.onSpliceRows(\n        \"survey\",\n        [\n          {\n            rowIndex: node.rowIndex,\n            numberOfRowsToRemove: 1,\n            rowsToAdd: [newRow],\n          },\n        ],\n        description\n      );\n    },\n    [context, node]\n  );\n\n  const choiceListMenu = (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">\n          Set which choice lists should be visible.\n        </h6>\n      </li>\n      <ControlGroup style={{ margin: \"16px 8px 4px\" }} vertical={true}>\n        {choiceListNames.map((listName) => {\n          const isSelected = node.typeParameters.includes(listName);\n          const nameElement = listName;\n          const choiceNamesToRows = choiceListsByName[listName];\n          const choiceNames = Object.keys(choiceNamesToRows);\n\n          const sortedChoiceRows = sortBy(\n            choiceNames.map((n) => choiceNamesToRows[n]),\n            (r) => r.name.toLowerCase()\n          );\n\n          const maxChoicesCount = 4;\n          const shownChoices = sortedChoiceRows\n            .slice(0, maxChoicesCount)\n            .map((row) => (\n              <li>\n                <Code\n                  key={row.name}\n                  style={{\n                    marginInline: \"1px\",\n                  }}\n                >\n                  {row.name}\n                </Code>\n              </li>\n            ));\n          const restElement = sortedChoiceRows.length > maxChoicesCount && (\n            <span\n              className={Classes.UI_TEXT}\n              style={{\n                lineHeight: \"24px\",\n                marginLeft: \"4px\",\n                paddingRight: \"2px\",\n              }}\n              aria-label={`and ${\n                sortedChoiceRows.length - maxChoicesCount\n              } more`}\n            >\n              +{sortedChoiceRows.length - maxChoicesCount}\n            </span>\n          );\n          const shownLabel = (\n            <ControlGroup fill={true} style={{ display: \"inline-flex\" }}>\n              <header aria-label={`Choice list ${listName}, allowed values:`}>\n                <Text>{nameElement}</Text>\n              </header>\n              <ul className={Classes.LIST_UNSTYLED}>\n                <ControlGroup\n                  style={{\n                    justifyContent: \"flex-end\",\n                    marginLeft: \"16px\",\n                  }}\n                >\n                  {shownChoices}\n                  {restElement}\n                </ControlGroup>\n              </ul>\n            </ControlGroup>\n          );\n\n          return (\n            <Checkbox\n              value={listName}\n              onChange={onChange}\n              large={true}\n              checked={isSelected}\n              disabled={\n                node.typeParameters.length === 1 &&\n                listName === node.typeParameters[0]\n              }\n            >\n              {shownLabel}\n            </Checkbox>\n          );\n        })}\n      </ControlGroup>\n\n      <Callout intent=\"primary\">\n        The content of these lists is defined in the <code>choices</code> Excel\n        sheet.\n      </Callout>\n    </Menu>\n  );\n  return choiceListMenu;\n}\n","import { produceWithPatches } from \"immer\";\nimport { Patch } from \"../../../lib/undo/useUndoHistory\";\nimport {\n  ChoicesWorksheet,\n  loadXLSFormFromRows,\n  SettingsWorksheet,\n  SurveyWorksheet,\n  WorksheetName,\n  XLSForm,\n} from \"../../types/XLSForm\";\n\n/**\n * Defines a splice operation on the XLSForm’s rows. A 'Splice' operation is generic and allows to\n * add, remove, and edit rows at once.\n */\nexport type RowSpliceOperation = {\n  rowIndex: number;\n  numberOfRowsToRemove: number;\n  rowsToAdd: any[];\n};\n\n/**\n * Adds and removes one or more set(s) of rows in a single operation.\n *\n * If possible, use this method for all operations that change the XLSForm model. Splicing allows\n * adding, editing, and removing rows in one go. The function recreates the whole underlying XLSForm\n * model and evaluation context so you don't have to think about how the survey model looks\n * internally.\n */\nexport default function spliceRowsInWorksheet(\n  xlsForm: XLSForm,\n  worksheetName: WorksheetName,\n  operations: RowSpliceOperation[]\n): [value: XLSForm, patches: Patch[], inversePatches: Patch[]] {\n  const surveyWorksheet = xlsForm.worksheets.survey;\n  if (!surveyWorksheet) {\n    throw new Error(\"No survey worksheet defined.\");\n  }\n\n  const worksheet = xlsForm.worksheets[worksheetName];\n  if (!worksheet) {\n    return [xlsForm, [], []];\n  }\n\n  // Create a copy of the rows array to give the array a new identity, causing a re-render op\n  const newRows = [...worksheet?.rows];\n  operations.forEach(({ rowIndex, numberOfRowsToRemove, rowsToAdd }) =>\n    newRows.splice(rowIndex, numberOfRowsToRemove, ...rowsToAdd)\n  );\n  const newWorksheet = { ...worksheet, rows: newRows };\n\n  // Reload the whole XLSForm from the new row array\n  return produceWithPatches(xlsForm, (draft) =>\n    loadXLSFormFromRows(\n      worksheetName === \"survey\"\n        ? (newWorksheet as SurveyWorksheet)\n        : surveyWorksheet,\n      xlsForm?.worksheets.settings?.rows[0]?.default_language || \"English (en)\",\n      worksheetName === \"settings\"\n        ? (newWorksheet as SettingsWorksheet)\n        : xlsForm?.worksheets.settings,\n      worksheetName === \"choices\"\n        ? (newWorksheet as ChoicesWorksheet)\n        : xlsForm?.worksheets.choices\n    )\n  );\n}\n","import { ChoiceRow } from \"../../types/RowTypes\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport { createLocalizedString } from \"./createLocalizedString\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/** Adds example choice list to the XLSForm source. */\nexport default function addExampleChoices(xlsForm: XLSForm) {\n  const languages = xlsForm.languages || new Set([\"English (en)\"]);\n  const choiceRows: ChoiceRow[] = [\n    {\n      \"list name\": \"yes_no_maybe\",\n      name: \"yes\",\n      label: createLocalizedString(\"yes\", languages),\n    },\n    {\n      \"list name\": \"yes_no_maybe\",\n      name: \"no\",\n      label: createLocalizedString(\"no\", languages),\n    },\n    {\n      \"list name\": \"yes_no_maybe\",\n      name: \"maybe\",\n      label: createLocalizedString(\"maybe\", languages),\n    },\n  ];\n  return spliceRowsInWorksheet(xlsForm, \"choices\", [\n    {\n      rowIndex: 0,\n      numberOfRowsToRemove: 0,\n      rowsToAdd: choiceRows,\n    },\n  ]);\n}\n","import { IconName } from \"@blueprintjs/core\";\n\nexport const fieldCategoriesToIcons: Record<string, IconName> = {\n  literal: \"edit\",\n  choice: \"selection\",\n  geo: \"globe\",\n  time: \"time\",\n  media: \"upload\",\n  stats: \"scatter-plot\",\n  track: \"person\",\n  special: \"small-minus\",\n  grouping: \"layout-hierarchy\",\n};\n","export const fieldCategoryNames: Record<string, string> = {\n  literal: \"Enter value\",\n  choice: \"Choice\",\n  geo: \"Maps\",\n  time: \"Date and time\",\n  media: \"Upload\",\n  special: \"Other\",\n  stats: \"Statistics\",\n  track: \"Personal data\",\n  grouping: \"Grouping\",\n};\n","export const fieldTypesToCategories: Record<string, string> = {\n  text: \"literal\",\n  acknowledge: \"literal\",\n  integer: \"literal\",\n  decimal: \"literal\",\n  range: \"literal\",\n  barcode: \"literal\",\n  select_one: \"choice\",\n  select_one_from_file: \"choice\",\n  select_multiple: \"choice\",\n  select_multiple_from_file: \"choice\",\n  rank: \"choice\",\n  geopoint: \"geo\",\n  geotrace: \"geo\",\n  geoshape: \"geo\",\n  date: \"time\",\n  time: \"time\",\n  datetime: \"time\",\n  image: \"media\",\n  audio: \"media\",\n  video: \"media\",\n  file: \"media\",\n  note: \"special\",\n  calculate: \"special\",\n  hidden: \"special\",\n  \"xml-external\": \"special\",\n  start: \"stats\",\n  end: \"stats\",\n  today: \"stats\",\n  deviceid: \"track\",\n  simserial: \"track\",\n  subscriberid: \"track\",\n  phonenumber: \"track\",\n  username: \"track\",\n  email: \"track\",\n  audit: \"track\",\n  begin_group: \"grouping\",\n  begin_repeat: \"grouping\",\n};\n","import { Menu, MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { fieldCategoriesToIcons } from \"../../xlsform-simple-schema/field-types/fieldCategoriesToIcons\";\nimport { fieldCategoryNames } from \"../../xlsform-simple-schema/field-types/fieldCategoryNames\";\nimport { fieldTypeNames } from \"../../xlsform-simple-schema/field-types/fieldTypeNames\";\nimport { fieldTypesToCategories } from \"../../xlsform-simple-schema/field-types/fieldTypesToCategories\";\nimport { fieldTypesToIcons } from \"../../xlsform-simple-schema/field-types/fieldTypesToIcons\";\n\nexport function FieldTypeMenu({\n  onSelectType,\n  header,\n}: {\n  header: React.ReactNode;\n  onSelectType: (fieldType: keyof typeof fieldTypeNames) => void;\n}) {\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      const type = event.currentTarget.dataset.type;\n      if (!type) {\n        throw new Error(\n          \"Encountered a menu item without a set field type. This is a bug – please report this to the developers.\"\n        );\n      }\n      onSelectType(type);\n    },\n    [onSelectType]\n  );\n\n  return (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">{header}</h6>\n      </li>\n\n      {Object.keys(fieldCategoriesToIcons)\n        .filter((c) => c !== \"special\" && c !== \"grouping\")\n        .map((category) => (\n          <MenuItem\n            text={fieldCategoryNames[category]}\n            icon={fieldCategoriesToIcons[category]}\n          >\n            {Object.keys(fieldTypesToCategories)\n              .filter((t) => fieldTypesToCategories[t] === category)\n              .map((type) => (\n                <MenuItem\n                  text={fieldTypeNames[type]}\n                  icon={fieldTypesToIcons[type]}\n                  onClick={onClick}\n                  data-type={type}\n                />\n              ))}\n          </MenuItem>\n        ))}\n\n      <MenuDivider />\n\n      {Object.keys(fieldTypesToCategories)\n        .filter((t) => fieldTypesToCategories[t] === \"special\")\n        .map((type) => (\n          <MenuItem\n            text={fieldTypeNames[type]}\n            icon={fieldTypesToIcons[type]}\n            onClick={onClick}\n            data-type={type}\n          />\n        ))}\n    </Menu>\n  );\n}\n","import * as React from \"react\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { mergeCommands } from \"../../lib/undo/mergeCommands\";\nimport { fieldTypeNames } from \"../../xlsform-simple-schema/field-types/fieldTypeNames\";\nimport addExampleChoices from \"../../xlsform-simple-schema/functions/editing/addExampleChoices\";\nimport spliceRowsInWorksheet from \"../../xlsform-simple-schema/functions/editing/spliceRowsInWorksheet\";\nimport { QuestionRow } from \"../../xlsform-simple-schema/types/RowTypes\";\nimport { FieldTypeMenu } from \"./FieldTypeMenu\";\n\nexport function SetFieldTypeMenu() {\n  const context = React.useContext(ODKSurveyContext);\n  const { node } = React.useContext(ODKNodeContext);\n\n  const onSelectType = React.useCallback(\n    (type: keyof typeof fieldTypeNames) => {\n      const typeParameters = type?.match(/^select/) ? node.typeParameters : [];\n      const newTypeValue = [type, ...typeParameters].join(\" \");\n      const newRow: QuestionRow = {\n        ...node.row,\n        type: newTypeValue,\n      };\n\n      if (!context.xlsForm) {\n        return;\n      }\n\n      const commands = [];\n      if (\n        type?.match(/^select/) &&\n        !context.xlsForm?.worksheets.choices?.rows.length\n      ) {\n        commands.push(addExampleChoices(context.xlsForm));\n      }\n\n      commands.push(\n        spliceRowsInWorksheet(commands[0]?.[0] || context.xlsForm, \"survey\", [\n          {\n            rowIndex: node.rowIndex,\n            numberOfRowsToRemove: 1,\n            rowsToAdd: [newRow],\n          },\n        ])\n      );\n      context.setXLSFormWithPatches(\n        `Set ${node.row.name}’s field type to ${type}`,\n        ...mergeCommands(commands)\n      );\n    },\n    [context, node]\n  );\n\n  return (\n    <FieldTypeMenu onSelectType={onSelectType} header={\"Set a field type.\"} />\n  );\n}\n","import { Patch } from \"immer\";\n\nexport function mergeCommands<T>(\n  ops: [nextState: T, patches: Patch[], inversePatches: Patch[]][]\n) {\n  return ops.reduce((prev, current, index) => [\n    current[0],\n    prev[1].concat(current[1]),\n    prev[2].concat(current[2]),\n  ]);\n}\n","import {\n  Boundary,\n  Button,\n  ButtonGroup,\n  Classes,\n  Code,\n  Icon,\n  OverflowList,\n} from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { fieldTypeNames } from \"../../xlsform-simple-schema/field-types/fieldTypeNames\";\nimport { fieldTypesToIcons } from \"../../xlsform-simple-schema/field-types/fieldTypesToIcons\";\nimport {\n  isGroupNode,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { ChoiceListMenu } from \"./ChoiceListMenu\";\nimport { NoChoicesState } from \"./NoChoicesState\";\nimport { SetFieldTypeMenu } from \"./SetFieldTypeMenu\";\n\n/**\n * Shows a survey field’s type and type parameters (if existing). The type and parameters are\n * clickable and allow to reconfigure the field.\n */\nexport function FieldTypeButtonGroup({\n  node,\n  showType,\n}: {\n  node: ODKNode;\n  showType: boolean;\n}) {\n  const isGroup = isGroupNode(node);\n  const context = React.useContext(ODKSurveyContext);\n  const { xlsForm } = context;\n  const surveyHasChoiceLists =\n    !!xlsForm && Object.keys(xlsForm?.choicesByName).length > 0;\n  const choiceListMenu = xlsForm && (\n    <ChoiceListMenu xlsForm={xlsForm} node={node} />\n  );\n  const noChoicesAvailable = NoChoicesState();\n  const typeName = fieldTypeNames[node.type];\n  const icon = fieldTypesToIcons[node.type];\n  const hasItems = node.typeParameters.length > 0;\n\n  if (isGroup)\n    return (\n      <span\n        className={[Classes.TEXT_MUTED].join(\" \")}\n        style={{ alignSelf: \"center\", marginLeft: \"8px\" }}\n      >\n        <Icon icon={icon} />\n        &nbsp;{typeName}\n      </span>\n    );\n\n  return (\n    <ButtonGroup>\n      {showType && (\n        <Popover2 content={<SetFieldTypeMenu />} lazy={true}>\n          <Button\n            icon={icon || \"blank\"}\n            fill={false}\n            minimal={true}\n            // rightIcon={\"caret-down\"}\n          >\n            {typeName}\n          </Button>\n        </Popover2>\n      )}\n\n      {node.type.match(/^select/) && (\n        <Popover2\n          lazy={true}\n          content={surveyHasChoiceLists ? choiceListMenu : noChoicesAvailable}\n        >\n          <Button\n            fill={true}\n            minimal={true}\n            // rightIcon={\"caret-down\"}\n            intent={hasItems ? \"none\" : \"warning\"}\n          >\n            {!hasItems && \"Set visible choices\"}\n            {hasItems && (\n              <OverflowList\n                observeParents={true}\n                minVisibleItems={2}\n                collapseFrom={Boundary.END}\n                items={node.typeParameters}\n                visibleItemRenderer={(p) => <Code>{p}</Code>}\n                overflowRenderer={(overflowItems) => (\n                  <span>{`+${overflowItems.length}`}</span>\n                )}\n                style={{\n                  transition: \"width 0.1s ease-out\",\n                  maxWidth: `200px`,\n                }}\n              />\n            )}\n          </Button>\n        </Popover2>\n      )}\n    </ButtonGroup>\n  );\n}\n","import { Button, ControlGroup, NonIdealState } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport addExampleChoices from \"../../xlsform-simple-schema/functions/editing/addExampleChoices\";\n/**\n * Shown when no choice lists are defined in the survey, allowing to create an example choice list.\n */\nexport function NoChoicesState() {\n  const context = React.useContext(ODKSurveyContext);\n\n  const onAddExampleChoices = React.useCallback(() => {\n    if (!context.xlsForm) {\n      return;\n    }\n    context.setXLSFormWithPatches(\n      \"Add example choices\",\n      ...addExampleChoices(context.xlsForm)\n    );\n  }, [context]);\n\n  const addExampleChoicesButton = (\n    <Button large={true} intent=\"primary\" onClick={onAddExampleChoices}>\n      Create example choice list\n    </Button>\n  );\n\n  return (\n    <ControlGroup style={{ padding: \"16px\" }}>\n      <NonIdealState\n        icon=\"selection\"\n        action={addExampleChoicesButton}\n        title=\"Sometimes, we have no choice.\"\n        description={\n          <>\n            This survey has no choice lists yet. Please add one first to make it\n            available for this survey question.\n          </>\n        }\n      />\n    </ControlGroup>\n  );\n}\n","import { Position, Toaster } from \"@blueprintjs/core\";\n\n/** Singleton toaster instance. Create separate instances for different options. */\nexport const AppToaster = Toaster.create({\n  className: \"recipe-toaster\",\n  position: Position.BOTTOM_RIGHT,\n});\n","import { Menu, MenuItem } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { fieldTypesToIcons } from \"../../xlsform-simple-schema/field-types/fieldTypesToIcons\";\nimport { NodeDependency } from \"../../xlsform-simple-schema/functions/editing/findOrReplaceFieldReferences\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\n\n/**\n * Displays a menu showing all fields that reference the given field.\n */\nexport function NodeReferencesMenu(props: { references: NodeDependency[] }) {\n  const context = React.useContext(ODKSurveyContext);\n\n  return (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">\n          This field influences{\" \"}\n          {props.references.length === 1\n            ? \"one other field.\"\n            : `${props.references?.length} other fields.`}\n        </h6>\n      </li>\n\n      {props.references?.map((reference) => {\n        if (!context.evaluationContext) {\n          return null;\n        }\n        const href = `#//${getNodeAbsolutePathString(\n          reference.node,\n          context.evaluationContext,\n          \"/\"\n        )}`;\n\n        return (\n          <MenuItem\n            text={<code>{reference.node?.row.name}</code>}\n            icon={fieldTypesToIcons[reference.node.type]}\n            href={href}\n            label={reference.columnName}\n          />\n        );\n      })}\n    </Menu>\n  );\n}\n","import { Code, IconName, MenuItem } from \"@blueprintjs/core\";\nimport { useCallback, useContext } from \"react\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { fieldTypeNames } from \"../xlsform-simple-schema/field-types/fieldTypeNames\";\nimport { ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { FieldTypeMenu } from \"./FieldPopoverButton/FieldTypeMenu\";\n\nexport default function AddFieldOrGroupMenuItem({\n  node,\n  position,\n  icon,\n  group,\n  omitAction,\n}: {\n  node: ODKNode;\n  position: \"before\" | \"after\" | \"inside\";\n  icon?: IconName;\n  group: boolean;\n  omitAction?: boolean;\n}) {\n  const context = useContext(ODKSurveyContext);\n\n  const caption = (\n    <>\n      {omitAction ? null : `Add ${group ? \"group\" : \"field\"}`} {position}{\" \"}\n      <Code>{node.row.name}</Code>\n    </>\n  );\n\n  const addFieldWithType = useCallback(\n    (fieldType: keyof typeof fieldTypeNames) => {\n      context.onAddNode({ position, node, group, fieldType });\n    },\n    [context, group, node, position]\n  );\n\n  const addGroupedTextField = useCallback(() => {\n    context.onAddNode({ position, node, group, fieldType: \"text\" });\n  }, [context, group, node, position]);\n\n  if (group) {\n    return (\n      <MenuItem\n        icon={icon}\n        // intent=\"primary\"\n        text={caption}\n        onClick={addGroupedTextField}\n      />\n    );\n  }\n\n  return (\n    <MenuItem\n      icon={icon}\n      // intent=\"primary\"\n      text={caption}\n    >\n      <FieldTypeMenu\n        onSelectType={addFieldWithType}\n        header={\"Choose a type for the new field.\"}\n      />\n    </MenuItem>\n  );\n}\n","import { MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport { useCallback, useContext } from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport useNodeDeletionDialog from \"../../lib/useNodeDeletionDialog\";\nimport useRenameNodeDialog from \"../../lib/useRenameNodeDialog\";\nimport {\n  isGroupNode,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport AddFieldOrGroupMenuItem from \"../AddFieldMenuItem\";\n\n/**\n * Anonymous React component with menu items for doing something with a given field.\n */\nexport default function NodeActionMenuItems(props: {\n  node?: ODKNode;\n  removeNode: () => void;\n  renameNode: () => void;\n  nestNode: () => void;\n  ungroupNode: () => void;\n  addHintToNode: () => void;\n  removeHintFromNode: () => void;\n}) {\n  const context = useContext(ODKSurveyContext);\n  const { node } = props;\n  if (!node) {\n    return null;\n  }\n\n  const isGroup = isGroupNode(node);\n  const renameText = isGroup ? \"Rename group…\" : \"Rename field…\";\n  const nodeHasHint = context.language && node.row.hint?.[context.language];\n\n  const items = (\n    <>\n      <MenuItem icon=\"edit\" text={renameText} onClick={props.renameNode} />\n      {!nodeHasHint && (\n        <MenuItem\n          icon=\"lightbulb\"\n          text=\"Add hint\"\n          onClick={props.addHintToNode}\n        />\n      )}\n      <MenuDivider />\n\n      <MenuItem icon=\"group-objects\" text=\"Add group\">\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"before\"\n          icon=\"arrow-up\"\n          group={true}\n          omitAction={true}\n        />\n        {isGroup && (\n          <AddFieldOrGroupMenuItem\n            node={node}\n            position=\"inside\"\n            icon=\"key-enter\"\n            group={true}\n            omitAction={true}\n          />\n        )}\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"after\"\n          icon=\"arrow-down\"\n          group={true}\n          omitAction={true}\n        />\n      </MenuItem>\n\n      <MenuItem icon=\"manually-entered-data\" text=\"Add field\">\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"before\"\n          icon=\"arrow-up\"\n          group={false}\n          omitAction={true}\n        />\n        {isGroup && (\n          <AddFieldOrGroupMenuItem\n            node={node}\n            position=\"inside\"\n            icon=\"key-enter\"\n            group={false}\n            omitAction={true}\n          />\n        )}\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"after\"\n          icon=\"arrow-down\"\n          group={false}\n          omitAction={true}\n        />\n      </MenuItem>\n\n      <MenuDivider />\n\n      <MenuItem\n        icon=\"group-objects\"\n        text=\"Nest in new group\"\n        onClick={props.nestNode}\n      />\n      {isGroup && (\n        <MenuItem\n          icon=\"ungroup-objects\"\n          text=\"Ungroup\"\n          onClick={props.ungroupNode}\n        />\n      )}\n\n      <MenuDivider />\n\n      <MenuItem\n        intent=\"danger\"\n        icon=\"trash\"\n        text={`Remove ${isGroup ? \"group\" : \"field\"}…`}\n        onClick={props.removeNode}\n      />\n    </>\n  );\n\n  return items;\n}\n\nexport function useNodeActionMenuItems(node?: ODKNode) {\n  const context = useContext(ODKSurveyContext);\n  const {\n    alert: nodeDeletionAlert,\n    showRemoveConfirmationDialog,\n  } = useNodeDeletionDialog(node);\n  const { dialog: renameDialog, showRenameDialog } = useRenameNodeDialog(node);\n  const nodeActionDialogs = (\n    <>\n      {nodeDeletionAlert}\n      {renameDialog}\n    </>\n  );\n\n  const addHintToNode = useCallback(() => {\n    if (!node) {\n      return;\n    }\n    context.onChangeCell(\"survey\", node?.rowIndex, \"hint\", \" \", node);\n  }, [context, node]);\n\n  const removeHintFromNode = useCallback(() => {\n    if (!node) {\n      return;\n    }\n    context.xlsForm?.languages.forEach((language) => {\n      context.onChangeCell(\n        \"survey\",\n        node?.rowIndex,\n        \"hint\",\n        \"\",\n        node,\n        language\n      );\n    });\n  }, [context, node]);\n\n  const nodeActionMenuItems = node && (\n    <NodeActionMenuItems\n      node={node}\n      removeNode={showRemoveConfirmationDialog}\n      renameNode={showRenameDialog}\n      nestNode={context.onNestNode.bind(undefined, node)}\n      ungroupNode={context.onUngroupNode.bind(undefined, node)}\n      addHintToNode={addHintToNode}\n      removeHintFromNode={removeHintFromNode}\n    />\n  );\n\n  return { nodeActionDialogs, nodeActionMenuItems };\n}\n","import { Alert, Intent } from \"@blueprintjs/core\";\nimport { useCallback, useContext, useState } from \"react\";\nimport { AppToaster } from \"../toaster\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { ODKSurveyContext } from \"./ODKSurveyContext\";\n\n/**\n * Custom React hook returning a function to show a nice looking field deletion confirmation\n * prompt. The prompt contains a list of fields that are affected by the deletion.\n */\nexport default function useNodeDeletionDialog(node?: ODKNode) {\n  const context = useContext(ODKSurveyContext);\n  const [isAlertOpen, setAlertOpen] = useState(false);\n  const isGroup = node && isGroupNode(node);\n\n  const closeAlert = useCallback(() => {\n    setAlertOpen(false);\n  }, []);\n\n  const removeNode = useCallback(() => {\n    if (!node) {\n      return;\n    }\n    AppToaster.show({\n      intent: \"none\",\n      message: (\n        <>\n          <code>{node.row.name}</code> field removed.\n        </>\n      ),\n    });\n    context.onRemoveRowAndChildren(node);\n    setAlertOpen(false);\n  }, [context, node]);\n\n  const showRemoveConfirmationDialog = useCallback(() => {\n    setAlertOpen(true);\n  }, []);\n\n  const alert = (\n    <Alert\n      cancelButtonText=\"Cancel\"\n      confirmButtonText=\"Delete\"\n      icon=\"trash\"\n      intent={Intent.DANGER}\n      isOpen={isAlertOpen}\n      onCancel={closeAlert}\n      onConfirm={removeNode}\n      canOutsideClickCancel={true}\n      canEscapeKeyCancel={true}\n    >\n      <p>\n        Are you sure you want to remove the <code>{node?.row.name}</code>{\" \"}\n        {isGroup ? \"group\" : \"field\"}?\n      </p>\n      {isGroup && node?.children.length && (\n        <p>This will also remove the group’s nested fields.</p>\n      )}\n    </Alert>\n  );\n\n  return {\n    showRemoveConfirmationDialog,\n    alert,\n  };\n}\n","import {\n  Button,\n  Classes,\n  Dialog,\n  FormGroup,\n  InputGroup,\n  Intent,\n} from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport { NodeReferencesMenu } from \"../survey/FieldPopoverButton/NodeReferencesMenu\";\nimport { AppToaster } from \"../toaster\";\nimport findOrReplaceFieldReferences, {\n  NodeDependency,\n} from \"../xlsform-simple-schema/functions/editing/findOrReplaceFieldReferences\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { ODKSurveyContext } from \"./ODKSurveyContext\";\n\n/**\n * Custom React hook returning a function to show a nice-looking rename prompt for a field.\n */\nexport default function useRenameNodeDialog(node?: ODKNode) {\n  const context = useContext(ODKSurveyContext);\n  const [isDialogOpen, setDialogOpen] = useState(false);\n  const [newName, setNewName] = useState<string>(\"\");\n  const [nodeDependencies, setNodeDependencies] = useState<NodeDependency[]>(\n    []\n  );\n\n  useEffect(() => {\n    setNewName(\"\");\n  }, [node?.row.name, node]);\n\n  useEffect(() => {\n    if (context.xlsForm && node) {\n      setNodeDependencies(\n        findOrReplaceFieldReferences(context.xlsForm, node, newName)\n      );\n    }\n  }, [node?.row.name, node, context.xlsForm, newName]);\n\n  const changeName = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      setNewName(event.currentTarget.value);\n    },\n    []\n  );\n\n  const closeDialog = useCallback(() => {\n    setDialogOpen(false);\n  }, []);\n\n  const renameNode = useCallback(\n    (event: React.FormEvent<HTMLFormElement>) => {\n      event.preventDefault();\n      if (!node) {\n        return;\n      }\n      context.onRenameNode(node, newName);\n      AppToaster.show({\n        intent: \"none\",\n        message: (\n          <>\n            The field has been renamed to ‘<code>{newName}</code>’.\n          </>\n        ),\n      });\n      setDialogOpen(false);\n    },\n    [context, newName, node]\n  );\n\n  const showRenameDialog = useCallback(() => {\n    setDialogOpen(true);\n  }, []);\n\n  const dependenciesInfo =\n    nodeDependencies.length > 0 ? (\n      <Popover2\n        content={<NodeReferencesMenu references={nodeDependencies} />}\n        lazy={true}\n      >\n        <Button minimal={true} intent=\"primary\">\n          See {nodeDependencies.length} updates…\n        </Button>\n      </Popover2>\n    ) : undefined;\n\n  const isGroup = node && isGroupNode(node);\n\n  const dialog = (\n    <Dialog\n      title={\n        <>\n          Rename ‘<code>{node?.row.name}</code>’ {isGroup ? \"group\" : \"field\"}…\n        </>\n      }\n      icon=\"edit\"\n      isOpen={isDialogOpen}\n      canOutsideClickClose={true}\n      canEscapeKeyClose={true}\n      isCloseButtonShown={true}\n      onClose={closeDialog}\n      lazy={true}\n    >\n      <form onSubmit={renameNode}>\n        <div className={Classes.DIALOG_BODY}>\n          <FormGroup\n            label={`Please enter a new name for this ${\n              isGroup ? \"group\" : \"field\"\n            }:`}\n            labelFor={\"newName\"}\n            style={{ display: \"flex\" }}\n          >\n            <InputGroup\n              id={\"newName\"}\n              placeholder=\"Enter a field name…\"\n              defaultValue={node?.row.name}\n              large={true}\n              onChange={changeName}\n              pattern=\"@?[\\w\\d_-]+\"\n              autoFocus={true}\n            />\n          </FormGroup>\n        </div>\n        <div className={Classes.DIALOG_FOOTER}>\n          <div className={Classes.DIALOG_FOOTER_ACTIONS}>\n            <div>{dependenciesInfo}</div>\n            <Button onClick={closeDialog} type=\"button\">\n              Close\n            </Button>\n            <Button\n              intent={Intent.PRIMARY}\n              type=\"submit\"\n              disabled={newName === \"\"}\n            >\n              Rename\n            </Button>\n          </div>\n        </div>\n      </form>\n    </Dialog>\n  );\n\n  return {\n    showRenameDialog,\n    dialog,\n  };\n}\n","import {\n  Button,\n  ButtonGroup,\n  Callout,\n  Classes,\n  Code,\n  Colors,\n  ControlGroup,\n  HTMLDivProps,\n  Icon,\n  IResizeEntry,\n  Menu,\n  ResizeSensor,\n  Tab,\n  Tabs,\n} from \"@blueprintjs/core\";\nimport { Classes as PopoverClasses, Popover2 } from \"@blueprintjs/popover2\";\nimport { without } from \"lodash\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport { useDarkMode } from \"../../components/DarkModeContainer\";\nimport { alpha } from \"../../lib/colors\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { fieldTypesToIcons } from \"../../xlsform-simple-schema/field-types/fieldTypesToIcons\";\nimport { internalFieldTypes } from \"../../xlsform-simple-schema/field-types/internalFieldTypes\";\nimport findOrReplaceFieldReferences, {\n  NodeDependency,\n} from \"../../xlsform-simple-schema/functions/editing/findOrReplaceFieldReferences\";\nimport { getFirstColumnNameWithError } from \"../../xlsform-simple-schema/functions/getFirstColumnNameWithError\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  EvaluatableColumnName,\n  evaluatableColumnNames,\n  isNodeRelevant,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { useNodeDragAndDrop } from \"../useNodeDragAndDrop\";\nimport { ExpressionPanel } from \"./ExpressionPanel\";\nimport { FieldPathBreadcrumbs } from \"./FieldPathBreadcrumbs\";\nimport { FieldTypeButtonGroup } from \"./FieldTypeButtonGroup\";\nimport { useNodeActionMenuItems } from \"./NodeActionMenuItems\";\nimport { NodeReferencesMenu } from \"./NodeReferencesMenu\";\n\nexport const StyledCodeBlock = styled(Code)`\n  overflow: auto;\n  word-break: break-all;\n  font-size: 16px;\n  line-height: 20px;\n  display: block;\n  border: none;\n  box-shadow: none;\n  background: transparent;\n  padding: 0;\n`;\n\nexport const StyledPanel = styled.div`\n  display: grid;\n  gap: 8px;\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5 {\n    margin: 0;\n    &:not(:first-child) {\n      margin-top: 8px;\n    }\n  }\n`;\n\nexport const StyledCalloutWithCode = styled(Callout)`\n  > code,\n  pre {\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n    color: inherit;\n    margin: -1px;\n    padding: 2px 4px;\n    background-color: rgba(255, 255, 255, 0.3);\n    @media (prefers-color-scheme: dark) {\n      background-color: rgba(0, 0, 0, 0.1);\n    }\n  }\n\n  pre {\n    padding: 0.5em 0.55em;\n    margin: 0.5em 0;\n    line-height: 1.3em;\n    background: white;\n    white-space: pre-wrap;\n  }\n\n  code {\n    font-weight: 600;\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n  }\n`;\n\nconst DragStripe = styled.div`\n  position: absolute;\n  top: 0px;\n  left: -20px;\n  width: calc(100% + 40px);\n  height: 5px;\n  background-color: ${Colors.BLUE3};\n  z-index: 10000000;\n`;\n\nfunction RenderTarget({\n  detailsButtonCaption,\n  hasTypeIcon,\n  style,\n}: {\n  detailsButtonCaption?: React.ReactNode;\n  hasTypeIcon?: boolean;\n  style?: React.CSSProperties;\n}) {\n  const context = React.useContext(ODKSurveyContext);\n  const { node, nodeEvaluationResults } = React.useContext(ODKNodeContext);\n  const isInternalFieldType = internalFieldTypes.includes(node.type);\n  const isVisible =\n    !isInternalFieldType && isNodeRelevant(node, context.evaluationContext);\n  const hasMissingParameters =\n    node.type.match(/^select/) && node.typeParameters.length === 0;\n  const firstColumnNameWithError = getFirstColumnNameWithError(\n    nodeEvaluationResults\n  );\n  const hasError = !!firstColumnNameWithError;\n  const [isDraggedOver, setIsDraggedOver] = React.useState(false);\n  const dragProps = useNodeDragAndDrop({\n    evaluationContext: context.evaluationContext,\n    node,\n    setIsDraggedOver,\n  });\n\n  const isDarkMode = useDarkMode();\n  const violetColor = isDarkMode ? Colors.VIOLET5 : Colors.VIOLET3;\n\n  return (\n    <ControlGroup\n      style={{\n        display: \"inline-flex\",\n        flex: \"none\",\n        position: \"relative\",\n        overflow: \"visible\",\n        ...style,\n      }}\n      {...dragProps}\n    >\n      {isDraggedOver && <DragStripe />}\n      <Button\n        minimal={true}\n        small={true}\n        lang=\"en\"\n        intent={\n          hasError ? \"danger\" : hasMissingParameters ? \"warning\" : undefined\n        }\n        rightIcon={hasError ? \"error\" : undefined}\n        icon={\n          hasTypeIcon ? (\n            <Icon\n              icon={fieldTypesToIcons[node.type]}\n              color={hasError || hasMissingParameters ? undefined : violetColor}\n            />\n          ) : undefined\n        }\n        style={{\n          color: hasError || hasMissingParameters ? undefined : violetColor,\n          fontSize: \"inherit\",\n          padding: 0,\n        }}\n        className={[!hasError && !isVisible && Classes.TEXT_MUTED]\n          .filter(Boolean)\n          .join(\" \")}\n      >\n        <ControlGroup>\n          {detailsButtonCaption || (\n            <code style={{ color: \"inherit\" }}>{node.row.name}</code>\n          )}\n          {!isVisible && (\n            <>\n              &nbsp;\n              <Icon\n                icon=\"eye-off\"\n                style={{ opacity: 0.5, color: \"inherit\" }}\n                title=\"Invisible\"\n                htmlTitle=\"Invisible\"\n              />\n            </>\n          )}\n        </ControlGroup>\n      </Button>\n    </ControlGroup>\n  );\n}\n\nexport default function FieldPopoverButton(props: {\n  detailsButtonCaption?: React.ReactNode;\n  detailsContent?: string | JSX.Element | undefined;\n  node: ODKNode;\n  controlGroupProps?: HTMLDivProps;\n  showJumpButton?: boolean;\n  editable: boolean;\n  nameOfOnlyShownTab?: EvaluatableColumnName;\n  hasTypeIcon?: boolean;\n  buttonStyle?: React.CSSProperties;\n}) {\n  const {\n    node,\n    editable,\n    nameOfOnlyShownTab,\n    detailsButtonCaption,\n    hasTypeIcon,\n  } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const nodeEvaluationResults = context.evaluationContext?.evaluationResults.get(\n    node\n  );\n  const firstColumnNameWithError = getFirstColumnNameWithError(\n    nodeEvaluationResults\n  );\n  const { row } = node;\n  const isInternalField = internalFieldTypes.includes(node.type);\n  const columnNames = isInternalField\n    ? without(evaluatableColumnNames, \"relevant\", \"readonly\")\n    : evaluatableColumnNames;\n  const firstColumnNameWithContent = columnNames.find((n) => {\n    const value = row[n];\n    return typeof value === \"string\" && value.length > 0;\n  });\n  const isDarkMode = useDarkMode();\n\n  const [width, setWidth] = React.useState(100);\n  const handleResize = React.useCallback(\n    (entries: IResizeEntry[]) => {\n      setTimeout(() => {\n        const newWidth = entries[0]?.contentRect.width;\n        if (Math.abs(newWidth - width) > 10) {\n          setWidth(newWidth);\n        }\n      }, 50);\n    },\n    [width]\n  );\n\n  const [tabId, setTabId] = React.useState<string | number>(\n    firstColumnNameWithError || firstColumnNameWithContent || \"calculation\"\n  );\n\n  const references = React.useMemo(\n    () =>\n      context?.xlsForm && findOrReplaceFieldReferences(context.xlsForm, node),\n    [context, node]\n  );\n\n  const { nodeActionMenuItems, nodeActionDialogs } = useNodeActionMenuItems(\n    node\n  );\n  if (!context.evaluationContext) {\n    return null;\n  }\n\n  const path = getNodeAbsolutePath(node, context.evaluationContext).slice(1);\n\n  const referencesButton = ReferencesButton({ references, editable });\n\n  const editHeader = (\n    <ControlGroup\n      style={{\n        margin: \"-20px\",\n        marginBottom: \"24px\",\n        backgroundColor: Colors.LIGHT_GRAY5,\n        // padding: \"20px\",\n        background: `linear-gradient(\n          ${alpha(Colors.BLUE3, 0.0)} 0px,\n          ${alpha(Colors.BLUE3, 0.05)} 22px,\n          ${alpha(Colors.BLUE3, 0.06)} 32px)`,\n        borderBottom: `solid 1px ${\n          isDarkMode ? Colors.DARK_GRAY2 : Colors.LIGHT_GRAY3\n        }`,\n        gap: \"8px\",\n      }}\n    >\n      <FieldTypeButtonGroup node={node} showType={true} />\n\n      <div className={Classes.FLEX_EXPANDER} />\n\n      {referencesButton}\n\n      <ButtonGroup fill={false}>\n        <Popover2\n          content={<Menu>{nodeActionMenuItems}</Menu>}\n          lazy={true}\n          placement=\"right-start\"\n        >\n          <Button icon={\"more\"} minimal={true} text=\"Actions\" />\n        </Popover2>\n      </ButtonGroup>\n    </ControlGroup>\n  );\n\n  const detailsContent = (\n    <ControlGroup vertical={true}>\n      {editable && editHeader}\n\n      <ResizeSensor onResize={handleResize} observeParents={true}>\n        <ControlGroup style={{ width: \"100%\", margin: \"-12px 8px 8px 0px\" }}>\n          <FieldPathBreadcrumbs {...{ path, width }} />\n        </ControlGroup>\n      </ResizeSensor>\n\n      {nameOfOnlyShownTab ? (\n        <ExpressionPanel\n          {...{\n            node,\n            columnName: nameOfOnlyShownTab,\n            nodeEvaluationResult: nodeEvaluationResults?.get(\n              nameOfOnlyShownTab\n            ),\n          }}\n          style={{ margin: \"0 -20px -20px -20px\" }}\n        />\n      ) : (\n        <Tabs\n          onChange={setTabId}\n          selectedTabId={tabId}\n          renderActiveTabPanelOnly={false}\n        >\n          {columnNames.map((columnName) =>\n            getTab({\n              node,\n              nodeEvaluationResults,\n              columnName: columnName,\n            })\n          )}\n        </Tabs>\n      )}\n    </ControlGroup>\n  );\n\n  return (\n    <ODKNodeContext.Provider value={{ node, nodeEvaluationResults }}>\n      {nodeActionDialogs}\n      <Popover2\n        lazy={true}\n        interactionKind=\"click\"\n        popoverClassName={PopoverClasses.POPOVER2_CONTENT_SIZING}\n        minimal={false}\n        placement=\"top\"\n        rootBoundary=\"viewport\"\n        onOpening={() => setWidth(0)}\n        modifiers={{\n          arrow: { enabled: true },\n          preventOverflow: { enabled: true },\n        }}\n        content={detailsContent}\n        fill={false}\n        targetTagName=\"span\"\n      >\n        <RenderTarget\n          {...{ detailsButtonCaption, hasTypeIcon, style: props.buttonStyle }}\n        />\n      </Popover2>\n    </ODKNodeContext.Provider>\n  );\n}\n\nfunction ReferencesButton({\n  references,\n  editable,\n}: {\n  references: NodeDependency[] | undefined;\n  editable: boolean;\n}) {\n  const referencesButtonTitle =\n    references &&\n    (references.length === 1\n      ? \"One dependency\"\n      : `${references.length} dependencies`);\n  const referencesButton = editable && references && references.length > 0 && (\n    <Popover2\n      content={<NodeReferencesMenu references={references} />}\n      lazy={true}\n    >\n      <Button\n        icon=\"link\"\n        // rightIcon={\"caret-down\"}\n        fill={false}\n        minimal={true}\n        title={referencesButtonTitle}\n        aria-label={referencesButtonTitle}\n      >\n        {references.length}\n      </Button>\n    </Popover2>\n  );\n  return referencesButton;\n}\n\nfunction getTab({\n  nodeEvaluationResults,\n  node,\n  columnName,\n}: {\n  nodeEvaluationResults: Map<string, ODKFormulaEvaluationResult> | undefined;\n  node: ODKNode;\n  columnName: EvaluatableColumnName;\n}) {\n  const nodeEvaluationResult = nodeEvaluationResults?.get(columnName);\n  const panel = (\n    <ExpressionPanel\n      {...{ node, columnName, nodeEvaluationResult }}\n      style={{ margin: \"-20px\" }}\n    />\n  );\n\n  return (\n    <Tab\n      id={columnName}\n      key={columnName}\n      panel={panel}\n      title={\n        <>\n          {columnName}\n          {nodeEvaluationResult?.state === \"error\" && (\n            <>\n              &nbsp;\n              <Icon icon=\"warning-sign\" intent=\"warning\" />\n            </>\n          )}\n        </>\n      }\n    />\n  );\n}\n","import { Colors } from \"@blueprintjs/core\";\nimport { Classes as PopoverClasses, Popover2 } from \"@blueprintjs/popover2\";\nimport { get } from \"lodash\";\nimport Inspector, { chromeLight } from \"react-inspector\";\nimport styled from \"styled-components\";\nimport { alpha } from \"../../lib/colors\";\n\nconst StyledCode = styled.button`\n  display: inline-block;\n  padding: 0.2em 0.4em;\n  cursor: pointer;\n  background: linear-gradient(\n    ${alpha(Colors.BLUE4, 0.1)},\n    ${alpha(Colors.BLUE4, 0.1)}\n  );\n  border: 0.1em ${alpha(Colors.BLUE1, 0.4)} solid;\n  color: ${Colors.BLUE1};\n  border-radius: 1em;\n`;\n\n/**\n * Shows a JavaScript object literal like Chrome inspector would show it.\n */\nexport default function ObjectLiteralButtonWithPopover({\n  object,\n}: {\n  object: unknown;\n}) {\n  const isDate = object instanceof Date;\n  const linkedDataType = get(object, \"@type\");\n  const type = linkedDataType || (isDate && \"Date\");\n  const inspector = (\n    <div style={{ margin: \"-20px\", padding: \"20px\", overflow: \"auto\" }}>\n      <Inspector\n        data={object}\n        name={type}\n        expandLevel={0}\n        theme={{\n          ...chromeLight,\n          TREENODE_FONT_FAMILY:\n            'SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace',\n          TREENODE_FONT_SIZE: \"14px\",\n          TREENODE_LINE_HEIGHT: \"1.5\",\n          BASE_FONT_SIZE: \"14px\",\n          BASE_LINE_HEIGHT: \"1.5\",\n          OBJECT_NAME_COLOR: Colors.VIOLET3,\n          OBJECT_VALUE_NULL_COLOR: Colors.RED4,\n          OBJECT_VALUE_UNDEFINED_COLOR: Colors.RED4,\n          OBJECT_VALUE_REGEXP_COLOR: Colors.RED4,\n          OBJECT_VALUE_STRING_COLOR: Colors.RED4,\n          OBJECT_VALUE_SYMBOL_COLOR: Colors.RED4,\n          OBJECT_VALUE_NUMBER_COLOR: Colors.RED4,\n          OBJECT_VALUE_BOOLEAN_COLOR: Colors.RED4,\n          OBJECT_VALUE_FUNCTION_PREFIX_COLOR: Colors.RED4,\n        }}\n      />\n    </div>\n  );\n  if (type === undefined && !isDate) {\n    return inspector;\n  }\n  return (\n    <Popover2\n      lazy={true}\n      interactionKind=\"click\"\n      popoverClassName={PopoverClasses.POPOVER2_CONTENT_SIZING}\n      minimal={false}\n      placement=\"top\"\n      rootBoundary=\"viewport\"\n      modifiers={{\n        arrow: { enabled: true },\n        preventOverflow: { enabled: true },\n      }}\n      content={inspector}\n      fill={false}\n      targetTagName=\"span\"\n    >\n      <StyledCode>{String(type)}</StyledCode>\n    </Popover2>\n  );\n}\n","import { isObject } from \"lodash\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport FieldPopoverButton from \"../../survey/FieldPopoverButton/FieldPopoverButton\";\nimport ODKFormulaEvaluationContext from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport {\n  findNodeByNameInCurrentAndAncestorScopes,\n  findNodeByNameInsideScope,\n} from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  Expression,\n  NameExpression,\n  Token,\n  TokenType,\n} from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport LiteralExpression from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/LiteralExpression\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport ObjectLiteralButtonWithPopover from \"./ObjectLiteral\";\n\n/** Shows a function name as a link to the function's documentation. */\nfunction FunctionCallTokenElement({\n  token,\n  className,\n}: {\n  token: Token;\n  className?: string;\n}) {\n  return (\n    <a\n      href={`https://getodk.github.io/xforms-spec/#fn:${token.text}`}\n      className={className}\n      target=\"docs\"\n    >\n      {token.text}\n    </a>\n  );\n}\n\n/** Shows a variable name as a link to its definition. */\nfunction VariableReferenceTokenElement({\n  expression,\n  context,\n  className,\n  token,\n  node,\n}: {\n  expression: NameExpression;\n  context: ODKFormulaEvaluationContext;\n  className?: string;\n  token: Token;\n  node: ODKNode;\n}) {\n  // Expression is a variable reference.\n  const referencedNode =\n    findNodeByNameInCurrentAndAncestorScopes(expression.name, context, node) ||\n    findNodeByNameInsideScope(expression.name, context, context.survey);\n\n  if (!referencedNode || referencedNode instanceof Array) {\n    // We should never get here.\n    debugger;\n    return (\n      <var className={className} data-referenced-node={referencedNode}>\n        {token.text}\n      </var>\n    );\n  }\n\n  return (\n    <var>\n      {\"${\"}\n      <FieldPopoverButton\n        node={referencedNode}\n        editable={false}\n        nameOfOnlyShownTab={\"calculation\"}\n      />\n      {\"}\"}\n    </var>\n  );\n}\n\n/** Shows a single parsed formula token as highlighted code. */\nexport function TokenElement({\n  token,\n  expression,\n  parentExpression,\n  node,\n}: {\n  token: Token;\n  expression?: Expression;\n  parentExpression?: Expression;\n  node: ODKNode;\n}) {\n  const className = `token token-${TokenType[token.type]}`;\n  const context = React.useContext(ODKSurveyContext);\n\n  const isFunctionCall =\n    token.type === TokenType.NAME &&\n    parentExpression?.kind === \"call\" &&\n    expression instanceof NameExpression &&\n    token === parentExpression.tokens[0];\n\n  if (isFunctionCall) {\n    return <FunctionCallTokenElement {...{ token, className }} />;\n  }\n\n  if (\n    token.type === TokenType.NAME &&\n    token.text.startsWith(\"$\") &&\n    expression instanceof NameExpression &&\n    context.evaluationContext\n  ) {\n    return (\n      <VariableReferenceTokenElement\n        {...{\n          expression,\n          context: context.evaluationContext,\n          className,\n          token,\n          node,\n        }}\n      />\n    );\n  }\n\n  if (\n    expression instanceof LiteralExpression &&\n    isObject(expression.value) &&\n    expression.type === \"object\"\n  ) {\n    return (\n      <ObjectLiteralButtonWithPopover\n        object={expression.value as Record<string, unknown>}\n      />\n    );\n  }\n\n  return <span className={className}>{token.text}</span>;\n}\n","import { Classes } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { CSSProperties } from \"styled-components\";\nimport { Token } from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport StyledCode from \"./StyledCode\";\nimport { TokenElement } from \"./TokenElement\";\n\n/**\n * Shows an invalid expression's tokens and the non-tokenizable rest of its code with syntax\n * highlighting.\n */\nexport function InvalidExpression(props: {\n  code?: string;\n  className?: string;\n  style?: CSSProperties;\n  tokens?: Token[];\n  node: ODKNode;\n}) {\n  if (!props.tokens) {\n    return (\n      <StyledCode\n        style={props.style}\n        className={`${props.className || \"\"} expression expression-invalid`}\n      >\n        {props.code}\n      </StyledCode>\n    );\n  }\n\n  const lastToken = props.tokens[props.tokens.length - 1];\n  const indexAfterLastToken = lastToken.index + lastToken.text.length;\n  return (\n    <StyledCode\n      style={props.style}\n      className={`${props.className || \"\"} expression expression-invalid`}\n    >\n      {props.tokens.map((token) => (\n        <TokenElement token={token} key={token.index} node={props.node} />\n      ))}\n      <span className={Classes.TEXT_DISABLED}>\n        {props.code?.slice(indexAfterLastToken)}\n      </span>\n    </StyledCode>\n  );\n}\n","import * as React from \"react\";\nimport { CSSProperties } from \"styled-components\";\nimport { Expression } from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport { EvaluationError } from \"../../xlsform-simple-schema/types/Errors\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { InvalidExpression } from \"./InvalidExpression\";\nimport StyledCode from \"./StyledCode\";\nimport { TokenElement } from \"./TokenElement\";\n\n/** Shows a parsed formula expression with syntax highlighting and debugging features. */\nexport default function HighlightedExpression(props: {\n  /** The code to show. */\n  /** Highlights the success state of a formula parsing or evaluation process. */\n  state?: \"error\" | \"success\";\n  /** The error object to show, if applicable. */\n  error?: Error;\n  /** The formula expression to show. */\n  expression?: Expression;\n  /** The expression's parent expression. Allows customizing appearance based on the parent. */\n  parentExpression?: Expression;\n  /** The tokens to show. */\n  node: ODKNode;\n  /** Additional CSS class to apply. */\n  className?: string;\n  /** Additional CSS styles to apply. */\n  style?: CSSProperties;\n}) {\n  if (!props.expression) {\n    return <InvalidExpression {...props} />;\n  }\n  const isErroneousExpression =\n    props.error instanceof EvaluationError &&\n    props.error.expression === props.expression;\n\n  return (\n    <StyledCode\n      style={props.style}\n      className={`${props.className || \"\"} expression expression-${\n        props.expression.kind\n      } ${isErroneousExpression ? \"has-error\" : \"\"}`}\n    >\n      {props.expression.children.map((expressionOrToken, i) => {\n        if (expressionOrToken instanceof Expression) {\n          return (\n            <HighlightedExpression\n              expression={expressionOrToken}\n              parentExpression={props.expression}\n              error={props.error}\n              node={props.node}\n            />\n          );\n        } else {\n          return (\n            <TokenElement\n              token={expressionOrToken}\n              key={expressionOrToken.index}\n              expression={props.expression}\n              parentExpression={props.parentExpression}\n              node={props.node}\n            />\n          );\n        }\n      })}\n    </StyledCode>\n  );\n}\n","import { Colors, ControlGroup, Icon, ITreeNode, Tree } from \"@blueprintjs/core\";\nimport { Tooltip2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport HighlightedExpression from \"../components/HighlightedExpression/HighlightedODKExpression\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport FieldPopoverButton from \"../survey/FieldPopoverButton/FieldPopoverButton\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport createLiteralExpressionFromValue from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/createLiteralExpressionFromValue\";\nimport ODKFormulaEvaluationContext from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeAbsolutePath } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  evaluatableColumnNames,\n  ODKNode,\n} from \"../xlsform-simple-schema/types/ODKNode\";\n\n/** The label visible on the right of each tree item. */\nfunction SecondaryLabel(props: { node: ODKNode }) {\n  const { node } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const results = context.evaluationContext?.evaluationResults.get(node);\n  if (!results) {\n    return <Icon icon=\"calculator\" intent=\"none\" />;\n  }\n  const keysWithErrors = evaluatableColumnNames.filter(\n    (k) => results.get(k)?.error\n  );\n\n  const calculationResults = results?.get(\"calculation\");\n  const caption = (\n    <HighlightedExpression\n      node={node}\n      state={calculationResults?.state}\n      error={calculationResults?.error}\n      expression={createLiteralExpressionFromValue(calculationResults?.result)}\n    />\n  );\n  const error =\n    keysWithErrors.length > 0 &&\n    `Node has errors in the following columns: ${keysWithErrors\n      .map((k) => `‘${k}’`)\n      .join(\", \")}`;\n  const icon = error ? (\n    <>\n      &nbsp;\n      <Tooltip2 content={error}>\n        <Icon icon=\"error\" intent=\"danger\" title={error} htmlTitle={error} />\n      </Tooltip2>\n    </>\n  ) : null;\n  return (\n    <ControlGroup>\n      {caption}\n      {icon}\n    </ControlGroup>\n  );\n}\n\n/** Recursively creates ITreeNode objects from the given survey root. */\nexport function getNodeTree(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  transform: (result: ITreeNode<ODKNode>) => ITreeNode<ODKNode>\n): ITreeNode<ODKNode> {\n  if (node.children.length === 0) {\n    return transform({\n      id: getNodeAbsolutePath(node, context).join(\".\"),\n      label: node.row.name,\n      childNodes: [],\n      nodeData: node,\n    });\n  }\n\n  return transform({\n    id: getNodeAbsolutePath(node, context).join(\".\"),\n    label: node.row.name,\n    childNodes: node.children.map((childNode) =>\n      getNodeTree(childNode, context, transform)\n    ),\n    nodeData: node,\n  });\n}\n\n/** Shows a collapsible JSON tree of the survey result data for debugging. */\nexport default function ResultCodeTree(props: { xlsForm: XLSForm }) {\n  const { xlsForm } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const evaluationContext = context.evaluationContext;\n\n  const result = React.useMemo(() => {\n    return xlsForm && evaluationContext\n      ? getNodeTree(xlsForm.rootSurveyGroup, evaluationContext, (result) => {\n          const node = result.nodeData;\n          if (!node) {\n            debugger;\n            throw new Error(\n              \"Encountered a tree node that is not associated with a node. Please fix this.\"\n            );\n          }\n\n          if (!context.evaluationContext) {\n            throw new Error(\n              \"No context defined. Please define a context before using this component.\"\n            );\n          }\n\n          const label = (\n            <FieldPopoverButton\n              node={node}\n              editable={true}\n              hasTypeIcon={true}\n              buttonStyle={{ color: Colors.VIOLET3 }}\n            />\n          );\n\n          return {\n            ...result,\n            label,\n            key: node.row.name,\n            isExpanded: true,\n            hasCaret: !(result.childNodes?.length === 0),\n            secondaryLabel: node && <SecondaryLabel node={node} />,\n          } as ITreeNode<ODKNode>;\n        })\n      : null;\n  }, [context.evaluationContext, evaluationContext, xlsForm]);\n\n  return result ? <Tree contents={[result]} /> : <div></div>;\n}\n","import { FileInput } from \"@blueprintjs/core\";\nimport * as ExcelJS from \"exceljs\";\nimport * as React from \"react\";\nimport { Patch } from \"../lib/undo/useUndoHistory\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport { loadFormFromExcelWorkbook } from \"../xlsform-simple-schema/functions/loadSurveyFromXLSX\";\n\nexport default function ExcelFileInput(props: {\n  setXLSFormWithPatches: (\n    description: string,\n    value: XLSForm | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  setLanguage: (language: string) => void;\n}) {\n  const { onFileChange } = useWorkbookFromFile(props);\n  return <FileInput onInputChange={onFileChange} large={true} />;\n}\n\nexport function useWorkbookFromFile({\n  setXLSFormWithPatches,\n  setLanguage,\n}: {\n  setXLSFormWithPatches: (\n    description: string,\n    value: XLSForm | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  setLanguage: (language: string) => void;\n}) {\n  const onLoadWorkbook = React.useCallback(\n    async (workbook: ExcelJS.Workbook) => {\n      const xlsForm = await loadFormFromExcelWorkbook(workbook);\n      setXLSFormWithPatches(\"Load Excel workbook\", xlsForm, [], []);\n      setLanguage(\n        xlsForm.worksheets.settings?.rows[0].default_language ||\n          [...xlsForm.languages?.values()][0] ||\n          \"English (en)\"\n      );\n    },\n    [setLanguage, setXLSFormWithPatches]\n  );\n\n  const onFileChange = React.useCallback(\n    (e) => {\n      const file = e.target.files[0];\n      const wb = new ExcelJS.Workbook();\n      const reader = new FileReader();\n\n      reader.readAsArrayBuffer(file);\n      reader.onload = () => {\n        const buffer = reader.result;\n        if (!(buffer instanceof ArrayBuffer)) {\n          throw new Error(\n            \"Buffer was not defined as Buffer object after reading.\"\n          );\n        }\n        wb.xlsx.load(buffer).then((workbook) => {\n          onLoadWorkbook(wb);\n        });\n      };\n    },\n    [onLoadWorkbook]\n  );\n\n  return { onFileChange };\n}\n","import { Button, ControlGroup, NonIdealState } from \"@blueprintjs/core\";\nimport * as ExcelJS from \"exceljs\";\nimport React, { useCallback } from \"react\";\nimport { Patch } from \"../lib/undo/useUndoHistory\";\nimport { loadFormFromExcelWorkbook } from \"../xlsform-simple-schema/functions/loadSurveyFromXLSX\";\nimport { XLSForm } from \"../xlsform-simple-schema/index\";\nimport ExcelFileInput from \"./ExcelFileInput\";\n\n/** Shows a load button and a 'create empty survey' button after the app just loaded. */\nexport function AppEmptyState({\n  setXLSFormWithPatches,\n  setLanguage,\n}: {\n  setXLSFormWithPatches: (\n    description: string,\n    value: XLSForm | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  setLanguage: (language: string) => void;\n}) {\n  const fileInput = (\n    <ExcelFileInput {...{ setXLSFormWithPatches, setLanguage }} />\n  );\n\n  const loadEmptyXLSForm = useCallback(async () => {\n    const emptyWorkbook = new ExcelJS.Workbook();\n    emptyWorkbook.addWorksheet(\"survey\");\n    emptyWorkbook.addWorksheet(\"choices\");\n    const settingsWorksheet = emptyWorkbook.addWorksheet(\"settings\");\n    settingsWorksheet.addRow([\"default_language\"]);\n    settingsWorksheet.addRow([\"English (en)\"]);\n\n    setXLSFormWithPatches(\n      \"Load empty XLSForm document\",\n      await loadFormFromExcelWorkbook(emptyWorkbook),\n      [],\n      []\n    );\n  }, [setXLSFormWithPatches]);\n\n  const nonIdealStateActions = (\n    <ControlGroup vertical={true}>\n      <p>{fileInput}</p>\n      <p>or</p>\n      <p>\n        <Button large={true} onClick={loadEmptyXLSForm}>\n          Start from scratch\n        </Button>\n      </p>\n    </ControlGroup>\n  );\n\n  const nonIdealState = (\n    <NonIdealState\n      icon=\"document-open\"\n      title=\"Open an XLSForm Excel file to start.\"\n      action={nonIdealStateActions}\n    />\n  );\n  return nonIdealState;\n}\n","import { XLSForm } from \"../../xlsform-simple-schema\";\nimport { createUndoHistoryContext } from \"./createUndoHistoryContext\";\n\nexport const UndoContext = createUndoHistoryContext<XLSForm>();\n","import { Patch } from \"immer\";\nimport * as React from \"react\";\nimport { UndoHistory } from \"./types\";\n\nexport type UndoContextType<T> = {\n  setDocumentWithPatches: (\n    description: string,\n    nextState: T | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  document: T | undefined;\n  undoHistory: UndoHistory<T>;\n  undo: () => void;\n  redo: () => void;\n  gotoIndex: (index: number) => void;\n};\n\nexport function createUndoHistoryContext<T>() {\n  return React.createContext<UndoContextType<T>>({\n    undoHistory: {\n      commands: [],\n      index: -1,\n    },\n    setDocumentWithPatches: () => {},\n    undo: () => {},\n    redo: () => {},\n    gotoIndex: () => {},\n    document: undefined,\n  });\n}\n","import { Button, Menu, MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport React from \"react\";\nimport { UndoContext } from \"../lib/undo/UndoContext\";\nimport Markdown from \"./Markdown\";\n\n/** Button showing a 'Edit' menu */\nexport function EditMenuButton() {\n  const undoContext = React.useContext(UndoContext);\n  const { undoHistory } = undoContext;\n\n  const lastCommand = undoHistory.commands[undoHistory.index];\n  const lastCommandDescription = lastCommand?.description;\n  const nextCommand = undoHistory.commands[undoHistory.index + 1];\n  const nextCommandDescription = nextCommand?.description;\n\n  const menu = (\n    <Menu>\n      <MenuItem\n        text={\n          <Markdown\n            inline={true}\n          >{`Undo ‘${lastCommandDescription}’`}</Markdown>\n        }\n        onClick={undoContext.undo}\n      />\n      <MenuItem\n        text={\n          nextCommand ? (\n            <Markdown\n              inline={true}\n            >{`Redo ‘${nextCommandDescription}’`}</Markdown>\n          ) : (\n            \"Redo\"\n          )\n        }\n        onClick={undoContext.redo}\n        disabled={!nextCommand}\n      />\n      <MenuDivider />\n      <MenuItem text=\"History\">\n        {undoHistory.commands.map((command, i) => (\n          <MenuItem\n            key={i}\n            active={i === undoHistory.index}\n            text={<Markdown inline={true}>{command.description}</Markdown>}\n            onClick={() => undoContext.gotoIndex(i)}\n          />\n        ))}\n      </MenuItem>\n    </Menu>\n  );\n\n  const button = (\n    <Button className=\"bp3-minimal\" rightIcon=\"caret-down\" text=\"Edit\" />\n  );\n\n  return (\n    <>\n      <Popover2\n        content={menu}\n        lazy={true}\n        placement={\"bottom-end\"}\n        minimal={true}\n      >\n        {button}\n      </Popover2>\n    </>\n  );\n}\n","import * as ExcelJS from \"exceljs\";\nimport { get } from \"lodash\";\nimport { WorksheetName, XLSForm } from \"../../types/XLSForm\";\nimport {\n  localizableColumnNames,\n  normalizeColumnNames,\n} from \"../loadSurveyFromXLSX\";\n\n/** Creates an XLSForm Excel file and starts its download in the browser.  */\nexport async function saveXLSForm(xlsForm: XLSForm) {\n  const workbook = new ExcelJS.Workbook();\n  workbook.modified = workbook.created = new Date();\n  workbook.creator = \"Sozialheld*innen Survey Editor\";\n\n  const worksheetNames: WorksheetName[] = [\"survey\", \"choices\", \"settings\"];\n  worksheetNames.forEach((worksheetName) => {\n    const internalWorksheet = xlsForm?.worksheets[worksheetName];\n    if (!internalWorksheet) {\n      return;\n    }\n\n    const excelWorksheet = workbook.addWorksheet(worksheetName);\n    const rows = [...(internalWorksheet?.rows || [])];\n\n    const columnNames = normalizeColumnNames(\n      internalWorksheet.columnNames\n    ).map((cn) => cn.replace(/::/, \".\"));\n\n    excelWorksheet.columns = columnNames.map((columnName) => ({\n      header: columnName,\n      key: columnName,\n      width: 10,\n    })) as ExcelJS.Column[];\n\n    excelWorksheet.addRows(\n      rows.map((row) =>\n        columnNames.map((cn) => {\n          if (localizableColumnNames.includes(cn)) {\n            cn = `${cn}.English (en)`;\n          }\n          return get(row, cn);\n        })\n      )\n    );\n  });\n\n  const title =\n    xlsForm?.worksheets.settings?.rows[0].form_title ||\n    \"Untitled XLSForm survey\";\n  workbook.model.title = title;\n\n  const buffer = await workbook.xlsx.writeBuffer();\n  const blob = new Blob([buffer], {\n    type: \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  });\n  var a = document.createElement(\"a\");\n  document.body.appendChild(a);\n  const url = window.URL.createObjectURL(blob);\n  a.href = url;\n  a.download = title;\n  a.click();\n\n  setTimeout(() => {\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(a);\n  }, 0);\n}\n","import { Button, Menu, MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport React from \"react\";\nimport { Patch } from \"../lib/undo/useUndoHistory\";\nimport { saveXLSForm } from \"../xlsform-simple-schema/functions/editing/saveXLSForm\";\nimport { XLSForm } from \"../xlsform-simple-schema/index\";\nimport { useWorkbookFromFile } from \"./ExcelFileInput\";\n\n/** Button showing a 'File' menu */\nexport function FileMenuButton({\n  xlsForm,\n  setXLSFormWithPatches,\n  setLanguage,\n}: {\n  xlsForm: XLSForm | undefined;\n  setXLSFormWithPatches: (\n    description: string,\n    value: XLSForm | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  setLanguage: (language: string) => void;\n}) {\n  const inputFieldRef = React.createRef<HTMLInputElement>();\n  const { onFileChange } = useWorkbookFromFile({\n    setXLSFormWithPatches,\n    setLanguage,\n  });\n\n  const closeFile = React.useCallback(() => {\n    setXLSFormWithPatches(\"Close current workbook\", undefined, [], []);\n  }, [setXLSFormWithPatches]);\n\n  const saveFileAs = React.useCallback(async () => {\n    if (xlsForm) {\n      await saveXLSForm(xlsForm);\n    }\n  }, [xlsForm]);\n\n  const menu = (\n    <Menu>\n      <label htmlFor=\"open-file-input\">\n        <MenuItem icon=\"import\" text=\"Import file…\" />\n      </label>\n      <MenuItem text=\"Export\" icon=\"export\">\n        <MenuItem\n          text=\"Microsoft Excel (.xlsx)\"\n          onClick={saveFileAs}\n          disabled={!xlsForm}\n        />\n      </MenuItem>\n      <MenuDivider />\n      <MenuItem text=\"Close\" onClick={closeFile} />\n    </Menu>\n  );\n\n  const button = (\n    <Button className=\"bp3-minimal\" rightIcon=\"caret-down\" text=\"File\" />\n  );\n\n  return (\n    <>\n      <input\n        id=\"open-file-input\"\n        type=\"file\"\n        onChange={onFileChange}\n        ref={inputFieldRef}\n        style={{ display: \"none\" }}\n      />\n      <Popover2\n        content={menu}\n        lazy={true}\n        placement={\"bottom-end\"}\n        minimal={true}\n      >\n        {button}\n      </Popover2>\n    </>\n  );\n}\n","import { Button, MenuItem } from \"@blueprintjs/core\";\nimport { ItemRenderer, Select } from \"@blueprintjs/select\";\nimport * as React from \"react\";\n\nconst LanguageSelect = Select.ofType<string>();\n\ntype Props = {\n  language: string;\n  languages: string[];\n  onChange: (language: string) => void;\n};\n\nconst renderItem: ItemRenderer<string> = (language: string, options) => {\n  const [, name, code] = language.match(/^(.*) \\((.*)\\)$/) || [];\n  return (\n    <MenuItem\n      text={name}\n      label={code}\n      // active={true}\n      onClick={options.handleClick}\n      shouldDismissPopover={false}\n    />\n  );\n};\n\nexport default function LanguageSelector(props: Props) {\n  const onItemSelect = React.useCallback(\n    (language: string) => {\n      props.onChange(language);\n    },\n    [props]\n  );\n\n  const [, name] = props.language.match(/^(.*) \\((.*)\\)$/) || [];\n\n  return (\n    <LanguageSelect\n      items={props.languages}\n      itemRenderer={renderItem}\n      activeItem={props.language}\n      noResults={<MenuItem disabled={true} text=\"No languages loaded yet.\" />}\n      onItemSelect={onItemSelect}\n      filterable={false}\n    >\n      {/* children become the popover target; render value here */}\n      <Button\n        text={name}\n        rightIcon=\"double-caret-vertical\"\n        icon=\"globe\"\n        minimal={true}\n      />\n    </LanguageSelect>\n  );\n}\n","import { HTMLDivProps } from '@blueprintjs/core';\nimport * as React from 'react';\n\nexport default function OverflowScrollContainer(props: HTMLDivProps) {\n    return <div {...props} style={{ overflow: 'auto', flex: 1, ...props.style }}>\n        {props.children}\n    </div>;\n}","import { Button, ButtonGroup, Navbar } from \"@blueprintjs/core\";\nimport React from \"react\";\n\nexport type ViewOption = \"table\" | \"debug\" | \"json\";\nconst defaultViewOptions: Record<ViewOption, boolean> = {\n  table: false,\n  debug: true,\n  json: false,\n};\n\n/** Custom React hook returning app's main view options and a button to configure these options. */\nexport default function useViewOptionsButton() {\n  const [viewOptions, setViewOptions] = React.useState<\n    Record<ViewOption, boolean>\n  >(defaultViewOptions);\n\n  const onDebugChange = React.useCallback(() => {\n    setViewOptions({ ...viewOptions, debug: !viewOptions.debug });\n  }, [viewOptions]);\n\n  const onShowTableChange = React.useCallback(() => {\n    setViewOptions({ ...viewOptions, table: !viewOptions.table });\n  }, [viewOptions]);\n\n  const onShowResultChange = React.useCallback(() => {\n    setViewOptions({ ...viewOptions, json: !viewOptions.json });\n  }, [viewOptions]);\n\n  const viewMenuButton = (\n    <>\n      <ButtonGroup>\n        <Button\n          icon=\"join-table\"\n          text=\"Excel\"\n          active={viewOptions.table}\n          onClick={onShowTableChange}\n        />\n        <Button\n          icon=\"diagram-tree\"\n          text=\"JSON\"\n          active={viewOptions.json}\n          onClick={onShowResultChange}\n        />\n      </ButtonGroup>\n      <Navbar.Divider />\n      <ButtonGroup>\n        <Button\n          icon=\"settings\"\n          text=\"Develop\"\n          active={viewOptions.debug}\n          onClick={onDebugChange}\n        />\n        <Button\n          icon=\"presentation\"\n          text=\"Preview\"\n          active={!viewOptions.debug}\n          onClick={onDebugChange}\n        />\n      </ButtonGroup>\n    </>\n  );\n\n  return { viewMenuButton, viewOptions };\n}\n","import { isEqual } from \"lodash\";\nimport { isGroupNode, ODKNode } from \"../types/ODKNode\";\nimport { XLSForm } from \"../types/XLSForm\";\n\n/**\n * Returns the last row index of a given node in the given XLSForm. For normal fields, this is the\n * field's row index, for groups/repeats, this is the `end_group` or `end_repeat` row index.\n */\nexport default function getLastRowIndexOfNode(xlsForm: XLSForm, node: ODKNode) {\n  const isGroup = isGroupNode(node);\n\n  if (!isGroup) {\n    return node.rowIndex;\n  }\n  // The end_group or end_repeat marker is associated to the node, too.\n  const indexOfGroupOrRepeatEnd = xlsForm.flatNodes.findIndex(\n    (n, i) => i > node.rowIndex && isEqual(n, node)\n  );\n  return indexOfGroupOrRepeatEnd;\n}\n","import { fieldTypeNames } from \"../../field-types/fieldTypeNames\";\nimport { QuestionRow } from \"../../types/RowTypes\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport { createLocalizedString } from \"./createLocalizedString\";\n\nlet untitledFieldIndex = 0;\n\n/** Creates an untitled new field in the survey, with an auto-incremented number suffix. */\nexport function createEmptyFieldRow(\n  xlsForm: XLSForm,\n  fieldType: keyof typeof fieldTypeNames = \"text\"\n): QuestionRow {\n  return {\n    type: fieldType,\n    name: `untitled_field_${untitledFieldIndex++}`,\n    label: createLocalizedString(\"\", xlsForm.languages),\n  };\n}\n","import {\n  BeginMarkerRow,\n  IEndGroupMarkerRow,\n} from \"../../types/BeginOrEndMarkerRow\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport { createLocalizedString } from \"./createLocalizedString\";\n\nlet untitledGroupIndex = 0;\n\n/** Creates an untitled new field group in the survey, with an auto-incremented number suffix. */\nexport function createEmptyGroupRows(xlsForm: XLSForm) {\n  untitledGroupIndex += 1;\n  const beginMarkerRow: BeginMarkerRow = {\n    type: \"begin_group\",\n    name: `untitled_group_${untitledGroupIndex}`,\n    label: createLocalizedString(\"\", xlsForm.languages),\n  };\n  const endMarkerRow: IEndGroupMarkerRow = { type: \"end_group\" };\n  return { beginMarkerRow, endMarkerRow };\n}\n","import { fieldTypeNames } from \"../../field-types/fieldTypeNames\";\nimport { isGroupNode, ODKNode } from \"../../types/ODKNode\";\nimport { QuestionRow } from \"../../types/RowTypes\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport getLastRowIndexOfNode from \"../getLastRowIndexOfNode\";\nimport { createEmptyFieldRow } from \"./createUntitledFieldRow\";\nimport { createEmptyGroupRows } from \"./createUntitledGroupRows\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/**\n * Add a new unnamed field/group/repeat at given position (next to, or inside of another field)\n */\nexport function addNodeToXLSForm({\n  xlsForm,\n  group,\n  node,\n  position,\n  fieldType,\n}: {\n  xlsForm: XLSForm;\n  group: boolean;\n  node?: ODKNode;\n  position: \"after\" | \"before\" | \"inside\";\n  fieldType: keyof typeof fieldTypeNames;\n}) {\n  const row: QuestionRow = createEmptyFieldRow(xlsForm, fieldType);\n  const { beginMarkerRow, endMarkerRow } = createEmptyGroupRows(xlsForm);\n  const rowsToInsert = group ? [beginMarkerRow, row, endMarkerRow] : [row];\n\n  let rowIndex = 0;\n  const currentNodeIsGroup = node && isGroupNode(node);\n  if (node && currentNodeIsGroup) {\n    rowIndex = {\n      after: getLastRowIndexOfNode(xlsForm, node) + 1,\n      before: node.rowIndex,\n      inside: node.rowIndex + 1,\n    }[position];\n  } else {\n    rowIndex = {\n      after: node ? node.rowIndex + 1 : 0,\n      before: node ? node.rowIndex : 0,\n      inside: 0,\n    }[position];\n  }\n  return spliceRowsInWorksheet(xlsForm, \"survey\", [\n    {\n      rowIndex,\n      numberOfRowsToRemove: 0,\n      rowsToAdd: rowsToInsert,\n    },\n  ]);\n}\n","import { ordinalize } from \"inflection\";\nimport {\n  FunctionNotImplementedError,\n  SemanticError,\n} from \"../../../types/Errors\";\nimport { ODKNodeWithoutRuntimeInfo } from \"../../../types/ODKNode\";\nimport ODKNodeValue from \"../../../types/ODKNodeValue\";\nimport ODKFormulaExecutionContext from \"./ODKFormulaEvaluationContext\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\ntype Value = ODKNodeValue;\n\nexport type FormulaFunction = (\n  this: {\n    context: ODKFormulaExecutionContext;\n    scope: ODKNodeWithoutRuntimeInfo;\n  },\n  ...args: Value[]\n) => Value;\n\nfunction assertString(value: unknown, argNo: number): asserts value is string {\n  if (typeof value !== \"string\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a string value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\nfunction assertNumber(value: unknown, argNo: number): asserts value is number {\n  if (typeof value !== \"number\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a number value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\nfunction assertBoolean(\n  value: unknown,\n  argNo: number\n): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a boolean value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\n// TODO: Could use reflection or code generation to find argument types automatically and avoid bugs\n\n/**\n * Map of function names to their JS implementations.\n *\n * Documentation / specification: https://docs.getodk.org/form-operators-functions/\n */\nexport const functions: Record<string, FormulaFunction> = {\n  if<T, U>(expression: unknown, then: T, elseExpression: U): T | U {\n    assertBoolean(expression, 0);\n    return expression ? then : elseExpression;\n  },\n\n  true(): boolean {\n    return true;\n  },\n\n  false(): boolean {\n    return false;\n  },\n\n  not(arg: unknown): boolean {\n    assertBoolean(arg, 0);\n    return !arg;\n  },\n\n  coalesce<T extends Value, U extends Value>(arg: T, arg2: U): T | U | string {\n    if (typeof arg !== \"undefined\" && arg !== \"\") {\n      return arg;\n    }\n    if (typeof arg2 !== \"undefined\" && arg2 !== \"\") {\n      return arg2;\n    }\n    return \"\";\n  },\n\n  boolean(arg: Value): boolean {\n    if (typeof arg === \"number\") {\n      return arg !== 0;\n    }\n    if (typeof arg === \"string\") {\n      return arg !== \"\";\n    }\n    if (arg instanceof Array) {\n      return arg.length > 0;\n    }\n    if (typeof arg === \"boolean\") {\n      return arg;\n    }\n    return false;\n  },\n\n  /**\n    Returns an integer equal to the 1-indexed position of the current node within the node defined by xpath.\n    Most often this is used in the form position(..) to identify the current iteration index within a repeat group.\n  */\n  position(_xpath: Value): number {\n    throw new FunctionNotImplementedError(\"position\");\n  },\n  /**\n   * Returns the value expression if the question's value is empty. Otherwise, returns the current value of the question.\n   * This can be used to ensure that a random number is only generated once, or to store the first value entered for a question in a way that is retrievable even if the response is changed later.\n   *   Warning This function is often misunderstood. Read when expressions are evaluated to learn more.\n   */\n  once(_expression: Value): Value {\n    throw new FunctionNotImplementedError(\"once\");\n  },\n\n  /**\n   * Returns True if string is a member of space_delimited_array, otherwise returns False. Commonly used to determined if a specific choice was selected in a select question. (This is possible because a reference to a select question returns a space-delimited array of choice names.)\n   */\n  selected(space_delimited_array: Value, string: Value): boolean {\n    if (space_delimited_array === undefined) {\n      return false;\n    }\n    assertString(space_delimited_array, 0);\n    assertString(string, 1);\n    if (space_delimited_array.length === 0 || string.length === 0) {\n      return false;\n    }\n    return space_delimited_array.split(\" \").includes(string);\n  },\n\n  // Returns the string at the n th position of the space_delimited_array. (The array is zero-indexed.) Returns an empty string if the index does not exist.\n  // This can be used to get the name of a selected choice from a multi-select question. (This is possible because a reference to a select question returns a space-delimited array of choice names.)\n  // Note\n  // If used to get a choice name from a select question, this function returns the name, not the label, of the selected choice. To get the label in the current language, use jr:choice-name().\n  \"selected-at\"(_space_delimited_array: Value, _n): string {\n    throw new FunctionNotImplementedError(\"selected-at\");\n  },\n\n  // Returns the number of choices selected in multi_select_question.\n  \"count-selected\"(_multi_select_question: Value): number {\n    throw new FunctionNotImplementedError(\"count-selected\");\n  },\n\n  // Returns the label value, in the active language, associated with the choice_name in the list of choices for the select_question.\n  // Note\n  // You have to wrap the select_question reference in quotes.\n  // '${question_name}'\n  \"jr:choice-name\"(_choice_name: Value, _select_question: Value): string {\n    throw new FunctionNotImplementedError(\"jr:choice-name\");\n  },\n\n  // Repeat groups\n  // Helpful terms\n  // nodeset\n  // A collection of XML nodes. In XLSForms, this is typically a collection of response values.\n  // Outside a repeat group, referring to a question by name will return a nodeset containing all the responses to that question.\n  // Nodesets can also be created by joining two or more nodes with pipes: /data/age | /data/name.\n\n  // Returns the response value of question name from the repeat-group group, in iteration i.\n  // Nested repeat groups can be accessed using the sub and sub_sub parameters.\n  // See also\n  // Referencing repeated questions from inside the repeat\n  \"indexed-repeat\"(\n    _name: Value,\n    _group: Value,\n    _i: Value,\n    _sub_grp: Value,\n    _sub_i: Value,\n    _sub_sub_grp: Value,\n    _sub_sub_i: Value\n  ): string {\n    throw new FunctionNotImplementedError(\"):\");\n  },\n\n  // Returns the number of items in nodeset. This can be used to count the number of repetitions in a repeat group.\n  count(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"count\");\n  },\n\n  // Returns the number of non-empty members of nodeset.\n  \"count-non-empty\"(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"count-non-empty\");\n  },\n\n  // Returns the sum of the members of nodeset.\n  // Can be used to tally responses to a repeated select question.\n  sum(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"sum\");\n  },\n\n  // Returns the largest member of nodeset.\n  // Warning\n  // The min() and max() functions only work sets of numbers. Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n  // Strings\n  max(_nodeset: Value): Value {\n    throw new FunctionNotImplementedError(\"max\");\n  },\n\n  // Returns the smallest member of nodeset.\n  // Warning\n  // The min() and max() functions only work sets of numbers. Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n  // Strings\n  min(_nodeset: Value): Value {\n    throw new FunctionNotImplementedError(\"min\");\n  },\n\n  // Searching and matching strings\n\n  // Returns True if string is an exact and complete match for expression.\n  // See also\n  // Using regular expressions\n  regex(string: Value, expression: Value): boolean {\n    assertString(string, 0);\n    assertString(expression, 0);\n    return !!string.match(new RegExp(expression));\n  },\n\n  // Returns True if the string contains the substring.\n  contains(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return !!string.match(substring);\n  },\n\n  // Returns True if string begins with substring.\n  \"starts-with\"(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return string.startsWith(substring);\n  },\n\n  // Returns True if the string ends with substring.\n  \"ends-with\"(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return string.endsWith(substring);\n  },\n\n  // Returns the substring of string beginning at the index start and extending to (but not including) index end (or to the termination of string, if end is not provided). Members of string are zero-indexed.\n  substr(string: Value, start: Value, end: Value): string {\n    assertString(string, 0);\n    assertNumber(start, 1);\n    assertNumber(end, 2);\n    return string.substring(start, end);\n  },\n\n  // Returns the substring of string before the first occurrence of the target substring. If the target is not found, or string begins with the target substring, then this will return an empty string.\n  \"substring-before\"(_string: Value, _target): string {\n    throw new FunctionNotImplementedError(\"substring-before\");\n  },\n\n  // Returns the substring of string after the first occurrence of the target substring. If the target is not found this will return an empty string.\n  \"substring-after\"(_string: Value, _target): string {\n    throw new FunctionNotImplementedError(\"substring-after\");\n  },\n\n  // Returns a copy of string, where every occurrence of a character in fromchars is replaced by the corresponding character in tochars. If fromchars is longer than tochars then every occurrence of a character in fromchars that does not have a corresponding character in tochars will be removed.\n  translate(_string: Value, _fromchars: Value, _tochars: Value): string {\n    throw new FunctionNotImplementedError(\"translate\");\n  },\n\n  // Returns the number of characters in string. If no value is passed in, returns the number of characters in the value of the question that this function call is tied to which can be useful in a constraint expression.\n  \"string-length\"(string: Value): number {\n    assertString(string, 0);\n    return string.length;\n  },\n\n  // Returns a string with normalized whitespace by stripping leading and trailing whitespace of string and replacing sequences of whitespace characters with a single space. If no value is passed in, normalizes whitespace of the value of the question that this function call is tied to.\n  \"normalize-space\"(string?: Value): string {\n    assertString(string, 0);\n    return string.trim();\n  },\n\n  // Combining strings\n\n  // Concatenates one or more arguments into a single string. If any arg is a nodeset, the values within the set are concatenated into a string.\n  concat(...args: Value[]): string {\n    return args.join(\"\");\n  },\n\n  // Joins the members of nodeset, using the string separator.\n  join(_separator: Value, _nodeset: ODKNodeValue): string {\n    throw new FunctionNotImplementedError(\"join\");\n  },\n\n  // Converting to and from strings\n\n  // Returns True if string is \"true\" or \"1\". Otherwise, False.\n  \"boolean-from-string\"(string: Value): boolean {\n    return string === \"true\" || string === \"1\";\n  },\n\n  // Converts arg to a string.\n  string(arg: Value): string {\n    return String(arg);\n  },\n\n  // Math\n  // Warning\n  // Math functions (except number()) only work with number values.\n  // You can use number() to convert a string of digits to a number, but it is usually better to get a number value directly.\n  // Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n\n  // Number handling\n\n  // Rounds a decimal number to some number of decimal places.\n  round(number: Value, places: Value): number {\n    assertNumber(number, 0);\n    assertNumber(places, 1);\n    return Math.round(number * 10 ** places) / 10 ** places;\n  },\n\n  // Truncates the fractional portion of a decimal number to return an integer.\n  int(number: Value) {\n    assertNumber(number, 0);\n    return Math.floor(number);\n  },\n\n  // Converts arg to number value.\n  // If arg is a string of digits, returns the number value.\n  // If arg is True, returns 1. If arg is False, returns 0.\n  // If arg cannot be converted, returns NaN (not a number).\n  number(arg: Value): number {\n    if (typeof arg === \"boolean\") {\n      return arg ? 1 : 0;\n    }\n    if (typeof arg === \"string\") {\n      if (arg.trim().match(/-?\\d+(\\.\\d+)?/)) {\n        return Number(arg);\n      }\n    }\n    if (typeof arg === \"number\") {\n      return arg;\n    }\n    return NaN;\n  },\n\n  // Computes and returns the hash value of the data string using the indicated hash algorithm string, and encoding this hash value using the optional encoding string.\n  // Options for the algorithm are MD5, SHA-1, SHA-256, SHA-384, SHA-512.\n  // If the third parameter is not specified, the encoding is base64. Valid options for the encoding are base64 and hex.\n  // This function can be useful if, for example, someone wants to build a unique identifier from sensitive data like a national ID number without compromising that data.\n  // See also\n  // count(), max(), min(), number()\n  digest(_data: Value, _algorithm: Value, _encodingMethod: Value): string {\n    throw new FunctionNotImplementedError(\"digest\");\n  },\n\n  // Calculation\n  pow(number: Value, exponent: Value): number {\n    assertNumber(number, 0);\n    assertNumber(exponent, 1);\n    return Math.pow(number, exponent);\n  },\n  log(number: Value): number {\n    assertNumber(number, 0);\n    return Math.log(number);\n  },\n  log10(number: Value): number {\n    assertNumber(number, 0);\n    return Math.log10(number);\n  },\n  abs(number: Value): number {\n    assertNumber(number, 0);\n    return Math.abs(number);\n  },\n  sin(number: Value): number {\n    assertNumber(number, 0);\n    return Math.sin(number);\n  },\n  cos(number: Value): number {\n    assertNumber(number, 0);\n    return Math.cos(number);\n  },\n  tan(number: Value): number {\n    assertNumber(number, 0);\n    return Math.tan(number);\n  },\n  asin(number: Value): number {\n    assertNumber(number, 0);\n    return Math.asin(number);\n  },\n  acos(number: Value): number {\n    assertNumber(number, 0);\n    return Math.acos(number);\n  },\n  atan(number: Value): number {\n    assertNumber(number, 0);\n    return Math.atan(number);\n  },\n  atan2(y: Value, x: Value): number {\n    assertNumber(y, 0);\n    assertNumber(x, 1);\n    return Math.atan2(y, x);\n  },\n  sqrt(number: Value): number {\n    assertNumber(number, 0);\n    return Math.sqrt(number);\n  },\n  exp(number: Value): number {\n    assertNumber(number, 0);\n    return Math.exp(number);\n  },\n  exp10: (number: Value): number => {\n    assertNumber(number, 0);\n    return 10 ** number;\n  },\n  pi: (): number => {\n    return Math.PI;\n  },\n\n  // Date and time\n\n  // Returns the current date without a time component.\n  today(): Date {\n    const now = new Date();\n    now.setHours(0, 0, 0, 0);\n    return now;\n  },\n\n  // Returns the current datetime in ISO 8601 format, including the timezone.\n  // Warning\n  // This function is often misused. Read when expressions are evaluated to learn more.\n  now(): string {\n    return new Date().toISOString();\n  },\n\n  // Converting dates and time\n\n  // Converts dateTime value to the number of days since January 1, 1970 (the Unix Epoch).\n  // This is the inverse of date().\n  \"decimal-date-time\"(_dateTime: Value): number {\n    throw new FunctionNotImplementedError(\"decimal-date-time\");\n  },\n\n  // Converts an integer representing a number of days from January 1, 1970 (the Unix Epoch) to a standard date value.\n\n  // This is the inverse of decimal-date-time().\n  date(_days: Value): Date {\n    throw new FunctionNotImplementedError(\"date\");\n  },\n\n  // Converts time to a number representing a fractional day. For example, noon is 0.5 and 6:00 PM is 0.75.\n  \"decimal-time\"(_time: Value): number {\n    throw new FunctionNotImplementedError(\"decimal-time\");\n  },\n\n  // Formatting dates and times for display\n\n  // Returns date as a string formatted as defined by format.\n  \"format-date\"(_date: Value, _format: Value): string {\n    throw new FunctionNotImplementedError(\"format-date\");\n  },\n\n  // Returns dateTime as a string formatted as defined by format.\n  \"format-date-time\"(_dateTime: Value, _format: Value): string {\n    throw new FunctionNotImplementedError(\"format-date-time\");\n  },\n\n  // Geography\n\n  // Returns the area, in square meters, of either a nodeset of geopoints or a geoshape value.\n  // It takes into account the circumference of the Earth around the Equator but does not take altitude into account.\n  area(_nodesetOrGeoshape: Value | Value): number {\n    throw new FunctionNotImplementedError(\"area\");\n  },\n\n  // Returns the distance, in meters, of either:\n\n  // a nodeset of geopoints\n  // the perimeter of a geoshape\n  // the length of a geotrace value\n  // It takes into account the circumference of the Earth around the Equator and does not take altitude into account.\n  distance(_nodesetOrGeoshapeOrGeotrace: Value): number {\n    throw new FunctionNotImplementedError(\"distance\");\n  },\n\n  // Utility\n\n  // Returns a random number between 0.0 (inclusive) and 1.0 (exclusive).\n  // Warning\n  // This function is often misused. Read when expressions are evaluated to learn more.\n  random: Math.random,\n\n  // Returns a shuffled nodeset.\n  // A shuffle with a numeric seed is deterministic and reproducible.\n  // The primary use for this function is to randomize the order of choices for a select question. The documentation on select widgets describes how this is done in XLSForm.\n  // randomize() can only be used in a context where a nodeset is accepted. Note that questions of type calculate cannot reference a nodeset.\n  randomize(_nodeset: Value, _seed: Value): ODKNodeValue {\n    throw new FunctionNotImplementedError(\"randomize\");\n  },\n\n  // Without argument, returns a random RFC 4122 version 4 compliant UUID.\n  // With an argument it returns a random GUID of specified length.\n  uuid(_length: Value): string {\n    throw new FunctionNotImplementedError(\"uuid\");\n  },\n\n  // Returns True if the number of response s that are exactly the string \"yes\" is between min and max, inclusive.\n  // Set min or max to -1 to make the argument not applicable.\n  checklist(_min: Value, _max: Value, ..._responses: Value[]): boolean {\n    throw new FunctionNotImplementedError(\"checklist\");\n  },\n\n  // Returns True if the sum of the weight s of each response that is exactly the string \"yes\" is between min and max, inclusive.\n  // Set min or max to -1 to make the argument not\n  \"weighted-checklist\"(\n    _min: Value,\n    _max: Value,\n    _response: Value,\n    ..._weightResponsePairs: Value[]\n  ): boolean {\n    throw new FunctionNotImplementedError(\"weighted-checklist\");\n  },\n};\n\nexport default functions;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ordinalize } from \"inflection\";\nimport { EvaluationError } from \"../../../types/Errors\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport ODKNodeValue from \"../../../types/ODKNodeValue\";\nimport {\n  CallExpression,\n  Expression,\n  NameExpression,\n  OperatorExpression,\n} from \"../pratt-parser-base\";\nimport LiteralExpression from \"../pratt-parser-base/expressions/LiteralExpression\";\nimport SelectorExpression from \"../pratt-parser-base/expressions/SelectorExpression\";\nimport evaluateNodeColumn from \"./evaluateNodeColumn\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport functions from \"./ODKFormulaFunctions\";\nimport {\n  findNodeByNameInCurrentAndAncestorScopes,\n  findNodeByNameInsideScope,\n  findNodeByPathRelativeToScope,\n} from \"./XPath\";\n\n/**\n * Evaluates a parsed expression / AST, returning the end result as JavaScript value.\n *\n * @param expression The parsed expression / AST to evaluate.\n * @param context the global context in which the formula should be evaluated. This context contains\n *   information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n * @param scope\n *   For resolving XPaths and relative node references correctly, the evaluation process needs to\n *   know the node in which the evaluation should begin. Use this parameter to supply the node that\n *   contained the formula string.\n */\nexport default function evaluateExpression(\n  expression: Expression,\n  context: ODKFormulaEvaluationContext,\n  scope: Readonly<ODKNode>\n): unknown {\n  let result: unknown;\n\n  if (context.stackDepth > 10000) {\n    throw new EvaluationError(\n      `Stack overflow while evaluating \\`${JSON.stringify(expression)}\\``,\n      \"stackOverflow\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  const deeperContext = {\n    ...context,\n    stackDepth: context.stackDepth + 1,\n  };\n\n  // This looks as if it could be caseless, for example by having Expression subclasses that have\n  // their own evaluator. This would complicate the design though, and make the expression\n  // implementation dependent on an expressions use - a two-way dependency to rather avoid.\n  if (expression instanceof LiteralExpression) {\n    result = evaluateLiteralExpression(expression);\n  } else if (expression instanceof NameExpression) {\n    result = evaluateNameExpression(expression, deeperContext, scope);\n  } else if (expression instanceof SelectorExpression) {\n    result = evaluateSelectorExpression(expression, deeperContext, scope);\n  } else if (expression instanceof OperatorExpression) {\n    result = evaluateOperatorExpression(expression, deeperContext, scope);\n  } else if (expression instanceof CallExpression) {\n    result = evaluateCallExpression(expression, deeperContext, scope);\n  } else {\n    throw new EvaluationError(\n      `Don’t know how to evaluate \\`${expression}\\`.`,\n      \"unsupportedExpressionType\",\n      expression,\n      deeperContext,\n      scope\n    );\n  }\n\n  context.stackDepth -= 1;\n\n  return result;\n}\n\n/**\n * A literal contains a defined value already. Return this value.\n */\nfunction evaluateLiteralExpression(\n  expression: LiteralExpression<ODKNodeValue>\n): ODKNodeValue {\n  return expression.value;\n}\n\nfunction stringFromStringOrExpression(n: string | Expression) {\n  if (typeof n === \"string\") {\n    return n;\n  }\n  let string = \"\";\n  n.print((str: string) => (string += str));\n  return string;\n}\n\n/**\n * Evaluate a CallExpression's (dynamic) function name, then each of its arguments. Then, call the\n * referred function (in this source code) by name. This evaluation does not use eval(), so it\n * shouldn't be possible to break out of this sandbox (fingers crossed)\n */\n\nfunction evaluateCallExpression(\n  expression: CallExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): unknown {\n  const nameExpressionOrString =\n    expression.fn instanceof NameExpression\n      ? expression.fn\n      : String(evaluateExpression(expression.fn, context, scope));\n  let fn: unknown = undefined;\n\n  const error = (\n    message: string,\n    name: string,\n    underlyingEvaluationError?: EvaluationError\n  ) => {\n    throw new EvaluationError(\n      message,\n      name,\n      expression,\n      context,\n      scope,\n      underlyingEvaluationError\n    );\n  };\n\n  // Allow to determine a function name dynamically by using an expression to allow things like\n  // (get-function-name())()\n  if (nameExpressionOrString instanceof NameExpression) {\n    fn = evaluateNameExpression(\n      nameExpressionOrString,\n      context,\n      scope,\n      true,\n      functions\n    );\n  } else if (typeof nameExpressionOrString === \"string\") {\n    fn = functions[nameExpressionOrString];\n  } else {\n    error(\n      `Can’t call a function without knowing its name — the name must be either defined as string, return a name string or a function reference.`,\n      \"functionNotFound\"\n    );\n  }\n\n  if (!fn) {\n    const name = stringFromStringOrExpression(nameExpressionOrString);\n    error(`Could not find a function named \\`${name}\\`().`, \"functionNotFound\");\n  }\n\n  const evaluatedArgs = expression.args.map((arg, i) => {\n    try {\n      return evaluateExpression(arg, context, scope);\n    } catch (e) {\n      const number = ordinalize(String(i + 1));\n      const name = stringFromStringOrExpression(nameExpressionOrString);\n      error(\n        `Error in ${number} argument in \\`${name}() function call\\`: ${e.message}`,\n        \"functionEvalError\",\n        e\n      );\n    }\n    return undefined; // can't be reached but necessary for typecheck\n  });\n\n  if (typeof fn !== \"function\") {\n    error(\n      `Found name \\`${fn}\\`, but it is not a function.`,\n      \"functionNotFound\"\n    );\n    return; // will never be reached because error() throws\n  }\n\n  try {\n    const result = fn.apply(context, evaluatedArgs);\n    return result;\n  } catch (e) {\n    let string = \"\";\n    expression.print((s) => (string += s));\n    error(\n      `Error while calling \\`${string}\\`: ${e.message}`,\n      \"functionEvalError\",\n      e\n    );\n  }\n}\n\nfunction assertBoolean(\n  value: unknown,\n  valueBeforeCasting: unknown,\n  expression: OperatorExpression | undefined,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    throw new EvaluationError(\n      `Found operand \\`${JSON.stringify(\n        valueBeforeCasting\n      )}\\` that is no boolean value, but ${\n        [\"a\", \"e\", \"i\", \"o\", \"u\"].includes(\n          (typeof valueBeforeCasting).slice(0, 1)\n        )\n          ? \"an\"\n          : \"a\"\n      } ${typeof valueBeforeCasting}. Boolean operators like \\`${\n        expression?.operatorToken.text\n      }\\` only work with values that are \\`true\\` or \\`false\\`.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n}\n\n/**\n * Evaluates operands of the expression, and calculates the result from combining them with the\n * operator referenced by the expression's operator string.\n */\nfunction evaluateOperatorExpression(\n  expression: OperatorExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): ODKNodeValue {\n  const leftBeforeCasting = evaluateExpression(expression.left, context, scope);\n  const rightBeforeCasting = evaluateExpression(\n    expression.right,\n    context,\n    scope\n  );\n\n  const operator = expression.operatorToken.text;\n\n  if (operator === \"=\") {\n    // eslint-disable-next-line eqeqeq\n    return leftBeforeCasting == rightBeforeCasting;\n  }\n  if (operator === \"!=\") {\n    // eslint-disable-next-line eqeqeq\n    return leftBeforeCasting != rightBeforeCasting;\n  }\n\n  let left;\n  let right;\n  if (operator === \"and\" || operator === \"or\") {\n    if (typeof leftBeforeCasting === \"boolean\") {\n      left = leftBeforeCasting;\n    }\n    if (typeof leftBeforeCasting === \"number\") {\n      left = Boolean(leftBeforeCasting);\n    }\n\n    if (typeof rightBeforeCasting === \"boolean\") {\n      right = rightBeforeCasting;\n    }\n    if (typeof rightBeforeCasting === \"number\") {\n      right = Boolean(rightBeforeCasting);\n    }\n\n    assertBoolean(left, leftBeforeCasting, expression, context, scope);\n    assertBoolean(right, rightBeforeCasting, expression, context, scope);\n\n    switch (operator) {\n      case \"or\":\n        return left || right;\n      case \"and\":\n        return left && right;\n    }\n  }\n\n  if (typeof leftBeforeCasting === \"number\") {\n    left = leftBeforeCasting;\n  }\n  if (typeof leftBeforeCasting === \"string\") {\n    left = parseFloat(leftBeforeCasting);\n  }\n\n  if (typeof rightBeforeCasting === \"number\") {\n    right = rightBeforeCasting;\n  }\n  if (typeof rightBeforeCasting === \"string\") {\n    right = parseFloat(rightBeforeCasting);\n  }\n\n  if (typeof left !== \"number\") {\n    throw new EvaluationError(\n      `Left operand is \\`${JSON.stringify(\n        leftBeforeCasting\n      )}\\`, which is no number. Arithmetic and relative comparison operators only work with operands that are numeric.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n  if (typeof right !== \"number\") {\n    throw new EvaluationError(\n      `Right operand is \\`${JSON.stringify(\n        rightBeforeCasting\n      )}\\`, which no number. Arithmetic and relative comparison operators only work with operands that are numeric.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  switch (operator) {\n    case \"+\":\n      return left + right;\n    case \"-\":\n      return left - right;\n    case \"*\":\n      return left * right;\n    case \"div\":\n      return left / right;\n    case \"mod\":\n      return left % right;\n    case \">\":\n      return left > right;\n    case \">=\":\n      return left >= right;\n    case \"<\":\n      return left < right;\n    case \"<=\":\n      return left <= right;\n    default:\n      throw new EvaluationError(\n        `The \\`${operator}\\` operator is not supported`,\n        \"unsupportedOperator\",\n        expression,\n        context,\n        scope\n      );\n  }\n}\n\n/**\n * Returns the value of a scoped NameExpression in a given evaluation context.\n *\n * Handled cases:\n *\n * - The name references a single node: Returns the node's answer or `calculation` value in this case.\n * - The name references a node set: Returns the answers/calculations of all nodes, as list.\n * - The name has no dollar sign: Look up the name as key in the supplied `literalBag` map, and return its value.\n */\nfunction evaluateNameExpression(\n  expression: NameExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode,\n  /** By default, throw if the name is not defined somewhere. */\n  allowUndefinedNames = false,\n  /**\n   * Hand over a mapping of literal names to values. These literals can be used legally inside\n   * the formula, and will be evaluated to their values in the map.\n   */\n  literalBag: Record<string, unknown> = context.knownLiteralsWithoutDollarSign\n): unknown {\n  if (expression.text.startsWith(\"$\")) {\n    const nodeOrNodes =\n      findNodeByNameInCurrentAndAncestorScopes(\n        expression.name,\n        context,\n        scope\n      ) || findNodeByNameInsideScope(expression.name, context);\n\n    if (!nodeOrNodes) {\n      throw new EvaluationError(\n        `Could not find a node with name \\`${expression.name}\\`.`,\n        \"nodeNotFound\",\n        expression,\n        context,\n        scope\n      );\n    }\n\n    if (nodeOrNodes instanceof Array) {\n      // Return a list of the values of all nodes referenced by this name.\n      // TODO: Check specs and examples if this is standard + correct ODK behavior.\n      return nodeOrNodes.map((node) =>\n        evaluateNodeColumn(\n          node,\n          context,\n          \"calculation\",\n          context.nodesToAnswers.get(node)\n        )\n      );\n    }\n\n    const evaluationResult = evaluateNodeColumn(\n      nodeOrNodes,\n      context,\n      \"calculation\",\n      context.nodesToAnswers.get(nodeOrNodes)\n    );\n\n    if (evaluationResult.error) {\n      throw new EvaluationError(\n        `Error in expression ${expression.text}.`,\n        \"unsupportedNameExpression\",\n        expression,\n        context,\n        scope,\n        evaluationResult.error instanceof EvaluationError\n          ? evaluationResult.error\n          : undefined\n      );\n    }\n\n    return evaluationResult.result;\n  } else if (expression.text === expression.name) {\n    const value = context.evaluateNonDollarNameFn\n      ? context.evaluateNonDollarNameFn({ expression, context, scope })\n      : literalBag[expression.name];\n\n    if (value !== undefined || allowUndefinedNames) {\n      return value;\n    }\n\n    let tip: string = \"\";\n    const node = findNodeByNameInCurrentAndAncestorScopes(\n      expression.name,\n      context,\n      scope\n    );\n    if (node) {\n      tip = `— did you mean to type \\`\\${${expression.name}}\\` instead of \\`${expression.name}\\`?`;\n    }\n\n    throw new EvaluationError(\n      `\\`${expression.text}\\` is not a known name or reference. ${tip}`,\n      \"unknownNameWithoutDollarSign\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  throw new EvaluationError(\n    `Don’t know how to evaluate ${expression}.`,\n    \"unsupportedNameExpression\",\n    expression,\n    context,\n    scope\n  );\n}\n\n/**\n * Finds a single node or multiple nodes that match the given node selector, then returns their\n * value(s).\n */\nexport function evaluateSelectorExpression(\n  expression: SelectorExpression<string[]>,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): unknown {\n  const selector = expression.selector;\n  const node = findNodeByPathRelativeToScope(selector, context, scope);\n  if (node instanceof Array) {\n    return node.map((childNode) =>\n      evaluateNodeColumn(\n        childNode,\n        context,\n        \"calculation\",\n        context.nodesToAnswers.get(childNode)\n      )\n    );\n  }\n  return (\n    node &&\n    evaluateNodeColumn(\n      node,\n      context,\n      \"calculation\",\n      context.nodesToAnswers.get(node)\n    )\n  );\n}\n","import {\n  ODKFormulaError,\n  SemanticError,\n  SyntaxError,\n} from \"../../../types/Errors\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport ODKFormulaLexer from \"../odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../odk-formula-parser/ODKFormulaParser\";\nimport { Expression } from \"../pratt-parser-base\";\nimport evaluateExpression from \"./evaluateExpression\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\nfunction assertExpressionAfterEvaluation(\n  expression: unknown\n): asserts expression is Expression {\n  if (!expression) {\n    throw new SemanticError(\n      \"Formula was not evaluated to an expression, but no error was encountered. This means an error handler is missing for this case.\"\n    );\n  }\n}\n\n/**\n * Evaluates a formula string.\n *\n * @returns The resulting value, the AST, and detailed error information if the evaluation fails.\n *\n * @param formula the formula string to evaluate, e.g. '1 + 1'\n * @param context the global context in which the formula should be evaluated. This context contains\n *   information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n * @param scope\n *   For resolving XPaths and relative node references correctly, the evaluation process needs to\n *   know the node in which the evaluation should begin. Use this parameter to supply the node that\n *   contained the formula string.\n */\nexport default function evaluateODKFormula(\n  formula: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKFormulaEvaluationResult {\n  let error;\n  let result;\n  let expression;\n  const lexer = new ODKFormulaLexer(formula);\n  const parser = new ODKFormulaParser({ tokens: lexer });\n  try {\n    expression = parser.parseExpression();\n\n    if (!expression) {\n      throw new SyntaxError(\n        `Parsing given formula \\`${formula}\\` returned an empty expression.`\n      );\n    }\n    result = evaluateExpression(expression, context, scope);\n    assertExpressionAfterEvaluation(expression);\n    return {\n      parser,\n      state: \"success\",\n      expression,\n      result,\n      error: undefined,\n    };\n  } catch (e) {\n    if (e instanceof ODKFormulaError) {\n      error = e;\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    parser,\n    state: \"error\",\n    expression,\n    error,\n    result: null,\n  };\n}\n","import { EvaluatableColumnName, ODKNode } from \"../../../types/ODKNode\";\nimport createLiteralExpressionFromValue from \"./createLiteralExpressionFromValue\";\nimport evaluateODKFormula from \"./evaluateODKFormula\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\n/**\n * @returns the JavaScript value of a survey node, returning either a user answer or a calculated\n * formula result.\n *\n * @param node The node containing the survey answer / calculation to evaluate.\n * @param context the global context in which the node's result should be evaluated. This context\n *   contains information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n */\nexport default function evaluateNodeColumn(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  columnName: EvaluatableColumnName,\n  fallback: unknown,\n  overrideFormula?: string\n): ODKFormulaEvaluationResult {\n  const originalFormula = overrideFormula\n    ? overrideFormula\n    : node.row?.[columnName];\n  if (originalFormula !== undefined && typeof originalFormula !== \"string\") {\n    debugger;\n    throw new Error(\"Sorry, multilingual formulas are not supported yet.\");\n  }\n  const formula = originalFormula?.trim();\n  if (formula === \"\" || formula === undefined) {\n    const fallbackValue = fallback;\n    const isMultiSelectResult = node.type === \"select_multiple\";\n    const value =\n      isMultiSelectResult && fallbackValue instanceof Array\n        ? fallbackValue.join(\" \")\n        : fallbackValue;\n    return {\n      state: \"success\",\n      result: value,\n      expression: createLiteralExpressionFromValue(value),\n      error: undefined,\n    };\n  }\n  // const row = node.row;\n  let evaluationResult: ODKFormulaEvaluationResult | undefined = undefined;\n  evaluationResult = evaluateODKFormula(formula, context, node);\n  // try {\n  // } catch (error) {\n  //   debugger;\n  //   throw new EvaluationError(\n  //     `Error in \\`${columnName}\\` column of the ‘${row?.name}’ question (row #${node.rowIndex}). It contains the formula \\`${row?.[columnName]}\\`. Please ensure the formula is valid. The error was: ${error}`,\n  //     \"calculationError\",\n  //     evaluationResult?.expression,\n  //     context,\n  //     node,\n  //     error\n  //   );\n  // }\n  return evaluationResult;\n}\n","import {\n  EvaluatableColumnName,\n  evaluatableColumnNames,\n  ODKNode,\n} from \"../../../types/ODKNode\";\nimport { XLSForm } from \"../../../types/XLSForm\";\nimport evaluateNodeColumn from \"./evaluateNodeColumn\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\n/**\n * @returns the calculated or answered value of a given branch (incl. children) or leaf in the node\n * tree. Calls a callback function for each found result.\n */\nexport function evaluateNodeAndChildren(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  onEval: (\n    node: ODKNode,\n    columnName: EvaluatableColumnName,\n    result: ODKFormulaEvaluationResult\n  ) => void\n): void {\n  const fallbacks: Record<EvaluatableColumnName, unknown> = {\n    relevant: true,\n    calculation: context.nodesToAnswers.get(node),\n    required: false,\n    readonly: false,\n    constraint: true,\n  };\n\n  evaluatableColumnNames.forEach((columnName) => {\n    onEval(\n      node,\n      columnName,\n      evaluateNodeColumn(node, context, columnName, fallbacks[columnName])\n    );\n  });\n  node.children?.forEach((child) =>\n    evaluateNodeAndChildren(child, context, onEval)\n  );\n}\n\n/**\n * @returns the calculated or answered value of all leaves in the node tree. Saves the calculated\n * results in the given evaluation context as a side effect.\n */\n\nexport default function getEvaluatedXLSFormResult(\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext\n) {\n  evaluateNodeAndChildren(\n    xlsForm.rootSurveyGroup,\n    context,\n    (node, columnName, result) => {\n      // console.log(\"Eval\", { name: node.row.name, columnName, result });\n      let columnNamesToResults = context.evaluationResults.get(node);\n      if (!columnNamesToResults) {\n        columnNamesToResults = new Map();\n        context.evaluationResults.set(node, columnNamesToResults);\n      }\n      columnNamesToResults?.set(columnName, result);\n    }\n  );\n}\n","import { ODKNode } from \"./ODKNode\";\n\nexport function describeNode(node: ODKNode) {\n  return node?.row.name || `node in row ${node.rowIndex}`;\n}\n","import * as React from \"react\";\nimport { useEffect, useState } from \"react\";\nimport HighlightedExpression from \"../components/HighlightedExpression/HighlightedODKExpression\";\nimport { FieldProps } from \"../survey/FieldProps\";\nimport { AppToaster } from \"../toaster\";\nimport { WorksheetName, XLSForm } from \"../xlsform-simple-schema\";\nimport { fieldTypeNames } from \"../xlsform-simple-schema/field-types/fieldTypeNames\";\nimport { addNodeToXLSForm } from \"../xlsform-simple-schema/functions/editing/addNodeToXLSForm\";\nimport { moveNode } from \"../xlsform-simple-schema/functions/editing/moveNode\";\nimport { nestNode } from \"../xlsform-simple-schema/functions/editing/nestNode\";\nimport patchXLSFormCell from \"../xlsform-simple-schema/functions/editing/patchXLSFormCell\";\nimport { removeNodeAndChildren } from \"../xlsform-simple-schema/functions/editing/removeNodeAndChildren\";\nimport { renameNode } from \"../xlsform-simple-schema/functions/editing/renameNode\";\nimport spliceRowsInWorksheet, {\n  RowSpliceOperation,\n} from \"../xlsform-simple-schema/functions/editing/spliceRowsInWorksheet\";\nimport { ungroupNode } from \"../xlsform-simple-schema/functions/editing/ungroupNode\";\nimport createLiteralExpressionFromValue from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/createLiteralExpressionFromValue\";\nimport getEvaluatedXLSFormResult from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeAndChildren\";\nimport ODKFormulaEvaluationContext, {\n  getEmptyEvaluationContext,\n  knownLiteralsWithoutDollarSign,\n} from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeIndexPath } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { describeNode } from \"../xlsform-simple-schema/types/describeNode\";\nimport { ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { Patch } from \"./undo/useUndoHistory\";\n\n/** Custom React hooks to change / edit the current survey model. */\nexport default function useChangeHooks({\n  xlsForm,\n  setXLSFormWithPatches,\n  language,\n  debug,\n}: {\n  /** The XLSForm model to edit */\n  xlsForm?: XLSForm;\n  /** A React setState method to set a new XLSForm model */\n  setXLSFormWithPatches: (\n    description: string,\n    value: XLSForm | undefined,\n    patches: Patch[],\n    inversePatches: Patch[]\n  ) => void;\n  /** Currently set XLSForm language */\n  language?: string;\n  /** `true` if in development mode, `false` if not. */\n  debug: boolean;\n}) {\n  const [context, setContext] = useState<ODKFormulaEvaluationContext>();\n\n  /** Sets a new evaluation context whenever the underlying XLSForm changes */\n  useEffect(() => {\n    if (!xlsForm) {\n      setContext(undefined);\n      return;\n    }\n\n    setContext((context: ODKFormulaEvaluationContext | undefined) => {\n      if (context && context.survey === xlsForm.rootSurveyGroup) {\n        console.log(\n          \"Context exists already and survey model is identical, keeping context.\"\n        );\n        return context;\n      }\n\n      const newContext = getEmptyEvaluationContext(xlsForm.rootSurveyGroup);\n      newContext.nodesToAnswers = new Map();\n      newContext.survey = xlsForm.rootSurveyGroup;\n      newContext.stackDepth = 0;\n      newContext.knownLiteralsWithoutDollarSign = knownLiteralsWithoutDollarSign;\n      getEvaluatedXLSFormResult(xlsForm, newContext);\n      console.log(\"Setting up new evaluation context\", newContext);\n      return newContext;\n    });\n  }, [xlsForm, xlsForm?.rootSurveyGroup]);\n\n  /** Use this function to change a survey answer value. */\n  const onChangeAnswer = React.useCallback(\n    (value: unknown, fieldProps: FieldProps) => {\n      if (debug) {\n        AppToaster.show(\n          {\n            message: (\n              <>\n                {fieldProps.schemaKey} →{\" \"}\n                <HighlightedExpression\n                  node={fieldProps.node}\n                  expression={createLiteralExpressionFromValue(value)}\n                />\n              </>\n            ),\n          },\n          \"changeField\"\n        );\n      }\n      if (xlsForm && context) {\n        setContext((context) => {\n          if (!context) {\n            return;\n          }\n          const nodesToAnswers = new Map<ODKNode, unknown>(\n            context.nodesToAnswers.entries()\n          );\n          nodesToAnswers.set(fieldProps.node, value);\n          const newContext: ODKFormulaEvaluationContext = {\n            ...context,\n            nodesToAnswers,\n          };\n          getEvaluatedXLSFormResult(xlsForm, newContext);\n          return newContext;\n        });\n      }\n    },\n    [context, debug, xlsForm]\n  );\n\n  /** Use this function to change XLSForm cell content. */\n  const onChangeCell = React.useCallback(\n    (\n      worksheetName: WorksheetName,\n      rowIndex: number,\n      columnName: string,\n      value: unknown,\n      node?: ODKNode,\n      overrideLanguage?: string\n    ) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const languageToUse = overrideLanguage || language;\n      if (!languageToUse) {\n        return;\n      }\n      setXLSFormWithPatches(\n        `Change \\`${columnName}\\` cell in \\`${worksheetName}\\` worksheet (Row #${rowIndex})`,\n        ...patchXLSFormCell({\n          worksheetName,\n          xlsForm,\n          node,\n          rowIndex,\n          columnName,\n          language: languageToUse,\n          value,\n          context,\n        })\n      );\n    },\n    [xlsForm, context, language, setXLSFormWithPatches]\n  );\n\n  const onSpliceRows = React.useCallback(\n    (\n      worksheetName: WorksheetName,\n      operations: RowSpliceOperation[],\n      description: string\n    ) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n\n      // const removeCount = sumBy(operations, (op) => op.numberOfRowsToRemove);\n      // const addCount = sumBy(operations, (op) => op.rowsToAdd.length);\n      // const description: string = `Change rows (${addCount} added / ${removeCount} removed)`;\n      setXLSFormWithPatches(\n        description,\n        ...spliceRowsInWorksheet(xlsForm, worksheetName, operations)\n      );\n    },\n    [context, setXLSFormWithPatches, xlsForm]\n  );\n\n  const onRemoveRowAndChildren = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const indexPath = getNodeIndexPath(node, context);\n      if (!indexPath) {\n        throw new Error(\n          \"Can’t remove a node that isn’t reachable from survey root. Please ensure the node is actually part of the survey.\"\n        );\n      }\n\n      setXLSFormWithPatches(\n        `Remove \\`${describeNode(node)}\\` node and its children`,\n        ...removeNodeAndChildren(xlsForm, node)\n      );\n    },\n    [context, setXLSFormWithPatches, xlsForm]\n  );\n\n  const onRenameNode = React.useCallback(\n    (node: ODKNode, newName: string) => {\n      if (!xlsForm) {\n        return;\n      }\n\n      setXLSFormWithPatches(\n        `Rename \\`${describeNode(node)}\\` to \\`${newName}\\``,\n        ...renameNode(xlsForm, node, newName)\n      );\n    },\n    [setXLSFormWithPatches, xlsForm]\n  );\n\n  const onNestNode = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm) {\n        return;\n      }\n      setXLSFormWithPatches(\n        `Nest \\`${describeNode(node)}\\``,\n        ...nestNode(xlsForm, node)\n      );\n    },\n    [setXLSFormWithPatches, xlsForm]\n  );\n\n  const onUngroupNode = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm) {\n        return;\n      }\n      setXLSFormWithPatches(\n        `Ungroup \\`${describeNode(node)}\\``,\n        ...ungroupNode({ node, xlsForm })\n      );\n    },\n    [setXLSFormWithPatches, xlsForm]\n  );\n\n  const onAddNode = React.useCallback(\n    ({\n      position,\n      node,\n      group,\n      fieldType,\n    }: {\n      position: \"before\" | \"after\" | \"inside\";\n      node?: ODKNode;\n      group: boolean;\n      fieldType: keyof typeof fieldTypeNames;\n    }) => {\n      if (!xlsForm) {\n        return;\n      }\n\n      const typeDescription = group ? \"group\" : `\\`${fieldType}\\` field`;\n      const description = node\n        ? `Add new ${typeDescription} ${position} \\`${describeNode(node)}\\``\n        : `Add new ${typeDescription}`;\n      setXLSFormWithPatches(\n        description,\n        ...addNodeToXLSForm({ xlsForm, group, node, position, fieldType })\n      );\n    },\n    [setXLSFormWithPatches, xlsForm]\n  );\n\n  const onMoveNode = React.useCallback(\n    ({\n      sourcePath,\n      sourceNode,\n      destinationNode,\n      position,\n    }: {\n      sourcePath: string;\n      sourceNode: ODKNode;\n      destinationNode: ODKNode;\n      position: \"before\" | \"after\" | \"inside\";\n    }) => {\n      if (!xlsForm || !context || !language) {\n        return;\n      }\n\n      const onError = (message: string) =>\n        AppToaster.show(\n          {\n            intent: \"warning\",\n            icon: \"error\",\n            message,\n          },\n          \"cant-drop-node-on-itself\"\n        );\n\n      const moveResult = moveNode({\n        xlsForm,\n        evaluationContext: context,\n        sourceNode,\n        destinationNode,\n        onError,\n      });\n      if (moveResult) {\n        setXLSFormWithPatches(\n          `Move \\`${describeNode(sourceNode)}\\` before \\`${describeNode(\n            destinationNode\n          )}\\``,\n          ...moveResult\n        );\n      }\n    },\n    [context, language, setXLSFormWithPatches, xlsForm]\n  );\n\n  return {\n    evaluationContext: context,\n    setEvaluationContext: setContext,\n    setXLSFormWithPatches,\n    onChangeAnswer,\n    onChangeCell,\n    onMoveNode,\n    onSpliceRows,\n    onRemoveRowAndChildren,\n    onRenameNode,\n    onNestNode,\n    onUngroupNode,\n    onAddNode,\n  };\n}\n","import { produceWithPatches } from \"immer\";\nimport { set } from \"lodash\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { WorksheetName, XLSForm } from \"../../types/XLSForm\";\nimport {\n  localizableColumnNames,\n  normalizeColumnNames,\n} from \"../loadSurveyFromXLSX\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeIndexPath } from \"../odk-formulas/evaluation/XPath\";\n\n/**\n * Changes the content of a single XLSForm cell.\n *\n * @returns a new XLSForm reference with the applied patch.\n */\nexport default function patchXLSFormCell({\n  worksheetName,\n  xlsForm,\n  rowIndex,\n  node,\n  context,\n  language,\n  columnName,\n  value,\n}: {\n  xlsForm: XLSForm;\n  worksheetName: WorksheetName;\n  node?: ODKNode;\n  rowIndex: number;\n  context: ODKFormulaEvaluationContext;\n  language: string;\n  columnName: string;\n  value: unknown;\n}) {\n  const changeIsInSurveyWorksheet = worksheetName === \"survey\";\n  if (changeIsInSurveyWorksheet && !node) {\n    throw new Error(\n      \"This is a bug: Tried to change the `survey` worksheet, but no node was supplied.\"\n    );\n  }\n\n  const valuePathInRow = localizableColumnNames.includes(columnName)\n    ? [columnName, language]\n    : [columnName];\n\n  // This creates a new object for each parent of a changed property inside the whole object tree\n  // of the given XLSForm.\n\n  // https://immerjs.github.io/immer/docs/introduction\n\n  return produceWithPatches(xlsForm, (draft) => {\n    set(\n      draft,\n      [\"worksheets\", worksheetName, \"rows\", rowIndex, ...valuePathInRow],\n      value\n    );\n\n    if (changeIsInSurveyWorksheet) {\n      set(draft, [\"flatNodes\", rowIndex, \"row\", ...valuePathInRow], value);\n      const indexPath = node && getNodeIndexPath(node, context);\n      if (indexPath) {\n        set(\n          draft,\n          [\n            \"rootSurveyGroup\",\n            ...indexPath.map((i) => [\"children\", i]).flat(),\n            \"row\",\n            ...valuePathInRow,\n          ],\n          value\n        );\n      }\n    }\n\n    // Update cached column names if necessary\n    if (language !== undefined && !draft.languages.has(language)) {\n      draft.languages.add(language);\n    }\n\n    const worksheet = draft.worksheets[worksheetName];\n    if (worksheet) {\n      if (language !== undefined && !worksheet.languages.has(language)) {\n        worksheet.languages.add(language);\n      }\n      if (!worksheet.columnNames.includes(columnName)) {\n        worksheet.columnNames.push(columnName);\n      }\n      const normalizedColumnName = normalizeColumnNames([columnName])[0];\n      if (!worksheet.columnNamesNormalized.includes(normalizedColumnName)) {\n        worksheet.columnNamesNormalized.push(normalizedColumnName);\n      }\n    }\n  });\n}\n","import { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport getLastRowIndexOfNode from \"../getLastRowIndexOfNode\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/** Removes a field's row (and all descendent field rows if it is a group or repeat) */\n\nexport function removeNodeAndChildren(xlsForm: XLSForm, node: ODKNode) {\n  const numberOfRowsToRemove =\n    getLastRowIndexOfNode(xlsForm, node) - node.rowIndex + 1;\n  const { rowIndex } = node;\n  const newXLSForm = spliceRowsInWorksheet(xlsForm, \"survey\", [\n    {\n      rowIndex,\n      numberOfRowsToRemove,\n      rowsToAdd: [],\n    },\n  ]);\n  return newXLSForm;\n}\n","import { Patch } from \"../../../lib/undo/useUndoHistory\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport findOrReplaceFieldReferences from \"./findOrReplaceFieldReferences\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/**\n * Renames a field in the XLSForm model.\n * @returns a new XLSForm reference with the renamed field.\n */\n\nexport function renameNode(\n  previousState: XLSForm,\n  node: ODKNode,\n  newName: string\n): [nextState: XLSForm, patches: Patch[], inversePatches: Patch[]] {\n  let finalNextState = previousState;\n  const finalPatches = [];\n  const finalInversePatches = [];\n\n  findOrReplaceFieldReferences(previousState, node, newName).forEach(\n    ({ index: rowIndex, row }) => {\n      const [nextState, patches, inversePatches] = spliceRowsInWorksheet(\n        finalNextState,\n        \"survey\",\n        [\n          {\n            rowIndex,\n            numberOfRowsToRemove: 1,\n            rowsToAdd: [{ ...row }],\n          },\n        ]\n      );\n      finalPatches.push(...patches);\n      finalInversePatches.push(...inversePatches);\n      finalNextState = nextState;\n    }\n  );\n\n  const [nextState, patches, inversePatches] = spliceRowsInWorksheet(\n    finalNextState,\n    \"survey\",\n    [\n      {\n        rowIndex: node.rowIndex,\n        numberOfRowsToRemove: 1,\n        rowsToAdd: [{ ...node.row, name: newName }],\n      },\n    ]\n  );\n  finalNextState = nextState;\n  finalPatches.push(...patches);\n  finalInversePatches.push(...inversePatches);\n\n  return [finalNextState, finalPatches, finalInversePatches];\n}\n","import { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport getLastRowIndexOfNode from \"../getLastRowIndexOfNode\";\nimport { createEmptyGroupRows } from \"./createUntitledGroupRows\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/** Nests a given node in a new, untitled group. */\n\nexport function nestNode(xlsForm: XLSForm, node: ODKNode) {\n  const { beginMarkerRow, endMarkerRow } = createEmptyGroupRows(xlsForm);\n  const firstIndex = node.rowIndex;\n  const lastIndex = getLastRowIndexOfNode(xlsForm, node);\n  const newXLSForm = spliceRowsInWorksheet(xlsForm, \"survey\", [\n    // Note that splicing changes indexes, so splicing the last row first is important.\n    {\n      rowIndex: lastIndex + 1,\n      numberOfRowsToRemove: 0,\n      rowsToAdd: [endMarkerRow],\n    },\n    {\n      rowIndex: firstIndex,\n      numberOfRowsToRemove: 0,\n      rowsToAdd: [beginMarkerRow],\n    },\n  ]);\n  return newXLSForm;\n}\n","import { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport getLastRowIndexOfNode from \"../getLastRowIndexOfNode\";\nimport spliceRowsInWorksheet from \"./spliceRowsInWorksheet\";\n\n/**\n * Remove a given group/repeat nesting, causing the nodes to be moved one hierarchy level\n * higher.\n */\nexport function ungroupNode({\n  node,\n  xlsForm,\n}: {\n  node: ODKNode;\n  xlsForm: XLSForm;\n}) {\n  const firstIndex = node.rowIndex;\n  const lastIndex = getLastRowIndexOfNode(xlsForm, node);\n  return spliceRowsInWorksheet(xlsForm, \"survey\", [\n    // Note that splicing changes indexes, so removing last row first is important.\n    {\n      rowIndex: lastIndex,\n      numberOfRowsToRemove: 1,\n      rowsToAdd: [],\n    },\n    {\n      rowIndex: firstIndex,\n      numberOfRowsToRemove: 1,\n      rowsToAdd: [],\n    },\n  ]);\n}\n","import { isEqual } from \"lodash\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport getLastRowIndexOfNode from \"../getLastRowIndexOfNode\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getAncestors } from \"../odk-formulas/evaluation/XPath\";\nimport spliceRowsInWorksheet, {\n  RowSpliceOperation,\n} from \"./spliceRowsInWorksheet\";\n\n/** Moves a node to a new position (next to, or inside of another field) */\nexport function moveNode({\n  xlsForm,\n  evaluationContext,\n  sourceNode,\n  destinationNode,\n  onError,\n}: {\n  xlsForm: XLSForm;\n  evaluationContext: ODKFormulaEvaluationContext;\n  sourceNode: ODKNode;\n  destinationNode: ODKNode;\n  onError: (message: string) => void;\n}) {\n  if (\n    getAncestors(destinationNode, evaluationContext)?.find((ancestor) =>\n      isEqual(ancestor, sourceNode)\n    )\n  ) {\n    onError(\"Can’t move a node into itself.\");\n    return;\n  }\n\n  const lastRowIndexOfSourceNode = getLastRowIndexOfNode(xlsForm, sourceNode);\n  const numberOfSourceNodeRows =\n    lastRowIndexOfSourceNode - sourceNode.rowIndex + 1;\n  const rowsOfSourceNode = [...xlsForm.worksheets.survey.rows].slice(\n    sourceNode.rowIndex,\n    sourceNode.rowIndex + numberOfSourceNodeRows\n  );\n  const destinationIsBeforeSource =\n    destinationNode.rowIndex < sourceNode.rowIndex;\n  const insertOperation: RowSpliceOperation = {\n    rowIndex: destinationNode.rowIndex,\n    numberOfRowsToRemove: 0,\n    rowsToAdd: rowsOfSourceNode,\n  };\n  const removeOperation: RowSpliceOperation = {\n    rowIndex:\n      sourceNode.rowIndex +\n      (destinationIsBeforeSource ? numberOfSourceNodeRows : 0),\n    numberOfRowsToRemove: numberOfSourceNodeRows,\n    rowsToAdd: [],\n  };\n\n  return spliceRowsInWorksheet(xlsForm, \"survey\", [\n    insertOperation,\n    removeOperation,\n  ]);\n}\n","import { Classes, EditableText } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\n\n/** Displays the survey’s configured title (and file name), editable. */\n\nexport default function EditableSurveyTitle() {\n  const context = React.useContext(ODKSurveyContext);\n  const surveyName = context.xlsForm?.worksheets.settings?.rows[0].form_title;\n  const [editedSurveyName, setEditedSurveyName] = React.useState<string>();\n\n  const onChangeSurveyName = React.useCallback(\n    (text: string) => {\n      if (editedSurveyName === undefined || editedSurveyName === \"\") {\n        return;\n      }\n      context.onChangeCell(\"settings\", 0, \"form_title\", editedSurveyName);\n      setEditedSurveyName(undefined);\n    },\n    [editedSurveyName, context]\n  );\n\n  const surveyTitleString =\n    context.xlsForm?.worksheets.settings?.rows[0].form_title;\n  const hasTitle =\n    surveyTitleString !== undefined && surveyTitleString.trim() !== \"\";\n  // const surveyTitle = (\n  //   <Text\n  // className={[!hasTitle && Classes.TEXT_MUTED, Classes.TEXT_LARGE]\n  //   .filter(Boolean)\n  //   .join(\" \")}\n  //   >\n  //     {surveyTitleString || \"Untitled survey\"}\n  //   </Text>\n  // );\n\n  return (\n    <EditableText\n      onChange={setEditedSurveyName}\n      onConfirm={onChangeSurveyName}\n      confirmOnEnterKey={true}\n      className={[!hasTitle && Classes.TEXT_MUTED, Classes.TEXT_LARGE]\n        .filter(Boolean)\n        .join(\" \")}\n      placeholder={`Enter a survey title…`}\n      value={editedSurveyName === undefined ? surveyName : editedSurveyName}\n      minWidth={100}\n    />\n  );\n}\n","import { Button, NonIdealState } from \"@blueprintjs/core\";\nimport { useCallback, useContext } from \"react\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\n\nexport default function NoSurveyFieldsState() {\n  const context = useContext(ODKSurveyContext);\n\n  const addNode = useCallback(() => {\n    context.onAddNode({ position: \"after\", group: false, fieldType: \"text\" });\n  }, [context]);\n\n  const addGroup = useCallback(() => {\n    context.onAddNode({ position: \"after\", group: true, fieldType: \"text\" });\n  }, [context]);\n\n  const actions = (\n    <>\n      <p>\n        <Button\n          text=\"Add a field\"\n          large={true}\n          intent=\"primary\"\n          onClick={addNode}\n        />\n      </p>\n      <p>\n        <Button text=\"Add a group of fields\" intent=\"none\" onClick={addGroup} />\n      </p>\n    </>\n  );\n\n  return <NonIdealState title=\"This survey is empty.\" action={actions} />;\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\nclass ErrorBoundary extends React.Component<\n  { children: React.ReactNode },\n  { error: Error | null }\n> {\n  constructor(props: { children: React.ReactNode }) {\n    super(props);\n    this.state = { error: null };\n  }\n\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n\n  componentDidCatch(error: unknown, info: unknown) {\n    console.error(error, info);\n  }\n\n  render() {\n    if (this.state.error) {\n      // You can render any custom fallback UI\n      return <Callout intent=\"danger\">{String(this.state.error)}</Callout>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import { Callout, Checkbox, Code } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function BooleanField(props: Props) {\n  const { value, labelElement, relevant, readonly } = props;\n\n  //   const context = React.useContext(ODKSurveyContext);\n  if (value !== undefined && typeof value !== \"boolean\") {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>boolean</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n  return (\n    <Checkbox\n      large={true}\n      disabled={relevant === false || readonly}\n      labelElement={labelElement}\n      onChange={props.onInputChange}\n      defaultChecked={\n        typeof props.defaultValue === \"boolean\" ? props.defaultValue : undefined\n      }\n    />\n  );\n}\n","import { Colors, ControlGroup, EditableText, Icon } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport evaluateNodeColumn from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeColumn\";\nimport { ExpressionPanel } from \"../FieldPopoverButton/ExpressionPanel\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function CalculateField(props: Props) {\n  const { node } = props;\n  const { evaluationContext } = React.useContext(ODKSurveyContext);\n  const { nodeEvaluationResults } = React.useContext(ODKNodeContext);\n  const surveyContext = React.useContext(ODKSurveyContext);\n  const [editedFormula, setEditedFormula] = React.useState<string>();\n\n  const formula = node.row.calculation;\n  const value = editedFormula === undefined ? formula : editedFormula;\n  const shownValue = value?.trim() === \"\" ? undefined : value;\n\n  const nodeEvaluationResult =\n    editedFormula === undefined\n      ? nodeEvaluationResults?.get(\"calculation\")\n      : evaluationContext &&\n        evaluateNodeColumn(\n          node,\n          evaluationContext,\n          \"calculation\",\n          \"\",\n          shownValue\n        );\n\n  const onCancel = React.useCallback(() => {\n    setEditedFormula(undefined);\n  }, []);\n\n  const changeFormula = React.useCallback(\n    (newFormula?: string) => {\n      surveyContext.onChangeCell(\n        \"survey\",\n        node.rowIndex,\n        \"calculation\",\n        newFormula,\n        node\n      );\n      setEditedFormula(undefined);\n    },\n    [node, surveyContext]\n  );\n\n  return (\n    <ControlGroup vertical={true}>\n      <ControlGroup\n        style={{\n          fontFamily:\n            'SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace',\n          background: Colors.WHITE,\n          padding: \"8px\",\n          border: `1px solid ${Colors.LIGHT_GRAY2}`,\n        }}\n        fill={true}\n      >\n        <Icon icon=\"function\" style={{ marginRight: \"16px\" }} />\n        <ControlGroup fill={true}>\n          <EditableText\n            placeholder=\"Enter a literal or a formula…\"\n            onChange={setEditedFormula}\n            onCancel={onCancel}\n            onConfirm={changeFormula}\n            value={shownValue}\n            multiline={true}\n          />\n        </ControlGroup>\n      </ControlGroup>\n      <ExpressionPanel\n        node={node}\n        columnName=\"calculation\"\n        nodeEvaluationResult={nodeEvaluationResult}\n        style={{}}\n      ></ExpressionPanel>\n    </ControlGroup>\n  );\n}\n","import { compact } from \"lodash\";\nimport { SemanticError } from \"../../types/Errors\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { evaluateDynamicChoiceListName } from \"./evaluateDynamicChoiceListName\";\nimport { evaluateFilteredChoiceNames } from \"./evaluateFilteredChoiceNames\";\n\n/**\n * @returns An array of strings (or functions returning strings) with the names of the choices that\n * are allowed as answers in a `select_one` or `select_multiple` survey field.\n */\n\nexport default function getAllowedChoiceValues({\n  node,\n  xlsForm,\n  context,\n  key,\n}: {\n  /** The node of the `select_one` or `select_multiple` survey field. */\n  node: ODKNode;\n  /** The XLSForm in which the node is included. */\n  xlsForm: XLSForm;\n  /** The context to use if the list of allowed choices is defined using a formula. */\n  context: ODKFormulaEvaluationContext;\n  /** Key path of the node. */\n  key: string;\n}): string[] | (() => string[]) {\n  const choiceListStrings = node.typeParameters;\n  const availableListNames = Object.keys(xlsForm.choicesByName);\n  const { type } = node.row;\n  const firstList = availableListNames[0];\n  const hasAvailableChoiceList = firstList !== undefined;\n  if (!hasAvailableChoiceList) {\n    throw new SemanticError(\n      `Node \\`${key}\\` uses \\`${type}\\` as its \\`type\\`, but the ‘choices’ worksheet seems to be empty or invalid. Please define some valid choice lists first.`\n    );\n  }\n\n  const { choicesByName } = xlsForm;\n\n  let choiceListNames = compact(\n    choiceListStrings.map((choiceListString) => {\n      if (choiceListString.trim().startsWith(\"$\")) {\n        return evaluateDynamicChoiceListName(\n          choiceListString,\n          { node, xlsForm, context, key },\n          choicesByName\n        );\n      } else {\n        return choiceListString;\n      }\n    })\n  ).filter((n) => n !== undefined && n !== \"\");\n\n  const choiceObjects = choiceListNames\n    .map((n) => choicesByName[n])\n    .filter((o) => o !== undefined);\n  if (choiceObjects.length !== choiceListNames.length) {\n    throw new SemanticError(\n      `Node \\`${key}\\` (row #${\n        node.rowIndex + 2\n      }) refers to list names \\`${choiceListNames}\\`. One of these lists is either not defined in the ‘choices’ worksheet, or could not be loaded correctly. Found list names:\\n\\n${availableListNames\n        .map((n) => `\\`${n}\\``)\n        .join(\", \")}`\n    );\n  }\n\n  const choiceFilterString = node.row.choice_filter?.trim();\n  if (!choiceFilterString || choiceFilterString === \"\") {\n    return choiceObjects.flatMap((choiceObject) => Object.keys(choiceObject));\n  }\n\n  return evaluateFilteredChoiceNames(\n    choiceFilterString,\n    choiceObjects,\n    node,\n    context\n  );\n}\n","import { EvaluationError } from \"../../types/Errors\";\nimport { ChoiceRow } from \"../../types/RowTypes\";\nimport evaluateODKFormula from \"../odk-formulas/evaluation/evaluateODKFormula\";\nimport { NodeToDefinitionFunctionOptions } from \"./createLeafNodeSchemaDefinition\";\n\n/**\n * Determine the name of a referenced choice list dynamically at runtime, allowing to calculate the\n * name of the choice list by using a formula.\n */\nexport function evaluateDynamicChoiceListName(\n  /** Choice list name, or a formula that evaluates to a choice list name */\n  choiceListString: string,\n  /** Context information needed for evaluating a formula, if applicable */\n  options: NodeToDefinitionFunctionOptions,\n  /** Map of available choice lists */\n  choiceListsByName: Record<string, Record<string, ChoiceRow>>\n) {\n  const evaluationResult = evaluateODKFormula(\n    choiceListString,\n    options.context,\n    options.node\n  );\n  if (evaluationResult.state === \"error\") {\n    throw new EvaluationError(\n      `Error evaluating \\`${choiceListString}\\` to determine available selection choices.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  if (typeof evaluationResult.result !== \"string\") {\n    throw new EvaluationError(\n      `Evaluating \\`${choiceListString}\\` did not yield a \\`string\\`. Please ensure the referenced field returns a string.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  const choiceListName = evaluationResult.result;\n  if (!choiceListsByName[choiceListName]) {\n    throw new EvaluationError(\n      `Evaluating \\`${choiceListString}\\` yielded string \\`'${choiceListName}'\\`, but the according choices list does not exist. Please ensure that the field calculates an existing list name.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  return choiceListName;\n}\n","import { EvaluationError } from \"../../types/Errors\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { ChoiceRow } from \"../../types/RowTypes\";\nimport evaluateExpression from \"../odk-formulas/evaluation/evaluateExpression\";\nimport ODKFormulaEvaluationContext, {\n  knownLiteralsWithoutDollarSign,\n} from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport ODKFormulaLexer from \"../odk-formulas/odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../odk-formulas/odk-formula-parser/ODKFormulaParser\";\nimport { Expression } from \"../odk-formulas/pratt-parser-base\";\n\n/**\n * @returns dynamically filtered choices available for a given `select_one` or `select_multiple`\n * node.\n *\n * Choices from a choice list can be filtered using a formula to make only a subset of the available\n * choices visible to the user. For this, the `choice_filter` column can contain a formula.\n *\n * The survey component checks all available choices in a list against this formula, which has to\n * return a boolean indicating if the choice should be included or not.\n *\n * The formula functions has access to extra columns defined in the `choices` worksheet to allow\n * tagging choices with meta information. To access a value in such a cell, you can refer to its\n * column name like a variable, but without the wrapping `${...}` construct.\n */\n\nexport function evaluateFilteredChoiceNames(\n  /** The condition formula specifying which choices to include in the list. */\n  choiceFilterFormula: string,\n  /** Applicable array of rows from the `choices` worksheet. */\n  choiceObjects: Record<string, ChoiceRow>[],\n  /** Node in which the choices are to be shown. */\n  node: ODKNode,\n  /** Context in which the formula should be evaluated. */\n  context: ODKFormulaEvaluationContext\n) {\n  const lexer = new ODKFormulaLexer(choiceFilterFormula);\n  const parser = new ODKFormulaParser({ tokens: lexer });\n\n  const choiceFilterExpression: Expression = parser.parseExpression();\n\n  const result = function filteredChoiceValues() {\n    return choiceObjects\n      .flatMap((choiceObject) => Object.values(choiceObject))\n      .filter((choiceRow) => {\n        const evalResult = evaluateExpression(\n          choiceFilterExpression,\n          {\n            ...context,\n            evaluateNonDollarNameFn: (options) =>\n              choiceRow[options.expression.name] ||\n              knownLiteralsWithoutDollarSign[options.expression.name],\n          },\n          node\n        );\n        if (typeof evalResult !== \"boolean\") {\n          throw new EvaluationError(\n            `\\`choice_filter\\` formula did not evaluate to a \\`boolean\\`. Please ensure the formula returns a \\`boolean\\`.`,\n            \"invalidDynamicChoices\",\n            choiceFilterExpression,\n            context,\n            node\n          );\n        }\n        return evalResult;\n      })\n      .map((choiceRow) => choiceRow.name);\n  };\n  return result;\n}\n","import { Callout, Checkbox, Code, ControlGroup } from \"@blueprintjs/core\";\nimport { compact } from \"lodash\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport getAllowedChoiceValues from \"../../xlsform-simple-schema/functions/schema-creation/getAllowedChoiceValues\";\nimport { FieldTypeButtonGroup } from \"../FieldPopoverButton/FieldTypeButtonGroup\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  value: unknown;\n};\n\nexport default function CheckboxGroupField(props: Props) {\n  const { value, node, relevant, readonly } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { language, onChangeAnswer, xlsForm } = context;\n\n  const valueIsInvalid =\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    (!(value instanceof Array) ||\n      value.find((element) => typeof element !== \"string\"));\n\n  const choices = React.useMemo<Set<string>>(() => {\n    if (typeof value === \"string\") {\n      return new Set<string>(value === \"\" ? [] : value?.split(\" \"));\n    }\n    if (value instanceof Array || value instanceof Set) {\n      return new Set<string>(value);\n    }\n    return new Set<string>();\n  }, [value]);\n\n  const onChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const choice = event.currentTarget.name;\n      const newChoices = new Set(choices);\n      if (event.currentTarget.checked) {\n        newChoices.add(choice);\n      } else {\n        newChoices.delete(choice);\n      }\n      onChangeAnswer(Array.from(newChoices), props);\n    },\n    [props, onChangeAnswer, choices]\n  );\n\n  if (\n    typeof language !== \"string\" ||\n    context.evaluationContext === undefined ||\n    xlsForm === undefined\n  ) {\n    return null;\n  }\n\n  if (valueIsInvalid) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> or Array of <Code>string</Code>s\n          for this field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  if (context.debug && node.typeParameters.length === 0) {\n    return (\n      <Callout intent=\"warning\" title=\"No choice list set.\">\n        <FieldTypeButtonGroup node={node} showType={false} />\n      </Callout>\n    );\n  }\n\n  const choiceLists = compact(\n    node.typeParameters.map(\n      (choiceListName) => context.xlsForm?.choicesByName[choiceListName]\n    )\n  );\n  const key = getNodeAbsolutePathString(node, context.evaluationContext, \".\");\n  let allowedValues = getAllowedChoiceValues({\n    node,\n    xlsForm,\n    context: context.evaluationContext,\n    key,\n  });\n  if (!(allowedValues instanceof Array)) {\n    allowedValues = allowedValues();\n  }\n  const allowedValuesSet = new Set(allowedValues);\n\n  return (\n    <ControlGroup vertical={true}>\n      {choiceLists.flatMap((choiceList) => {\n        return Object.keys(choiceList).map((value) => {\n          if (!allowedValuesSet.has(value)) {\n            return null;\n          }\n          const choiceRow = choiceList[value];\n\n          const definedLabel = choiceRow?.label?.[language];\n          const shownLabel =\n            definedLabel === \"undefined\" ? choiceRow?.name : definedLabel;\n          return (\n            <Checkbox\n              disabled={relevant === false || readonly}\n              label={shownLabel}\n              checked={typeof value === \"string\" && choices.has(value)}\n              name={value}\n              inline={true}\n              large={true}\n              onChange={onChange}\n            />\n          );\n        });\n      })}\n    </ControlGroup>\n  );\n}\n","import { Callout, Code } from \"@blueprintjs/core\";\nimport { DateInput, IDateFormatProps } from \"@blueprintjs/datetime\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nconst jsDateFormatter: IDateFormatProps = {\n  // note that the native implementation of Date functions differs between browsers\n  formatDate: (date: Date) => date.toLocaleDateString(),\n  parseDate: (str: string) => (str.length ? new Date(str) : null),\n  placeholder: \"YYYY-MM-DD\",\n};\n\nexport default function DateField(props: Props) {\n  const { value, relevant, readonly } = props;\n  const { onChangeAnswer } = React.useContext(ODKSurveyContext);\n\n  const onChange = React.useCallback(\n    (selectedDate: Date, isUserChange: boolean) => {\n      if (isUserChange) {\n        onChangeAnswer(selectedDate, props);\n      }\n    },\n    [props, onChangeAnswer]\n  );\n\n  if (value !== undefined && !(value instanceof Date)) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>Date</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n\n  let defaultValue = undefined;\n  if (typeof props.defaultValue === \"string\") {\n    defaultValue = jsDateFormatter.parseDate(props.defaultValue);\n  } else if (props.defaultValue instanceof Date) {\n    defaultValue = props.defaultValue;\n  }\n\n  return (\n    <DateInput\n      {...jsDateFormatter}\n      onChange={onChange}\n      defaultValue={defaultValue || undefined}\n      disabled={relevant === false || readonly}\n    />\n  );\n}\n","import { Callout, EditableText } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\n\nexport function EditableFieldHint({\n  node,\n  debug,\n}: {\n  node: ODKNode;\n  debug: boolean;\n}) {\n  const context = React.useContext(ODKSurveyContext);\n  const { onChangeCell, language } = context;\n\n  const [editedHintString, setEditedHintString] = React.useState<string>();\n\n  const onChangeHint = React.useCallback(\n    (value) => {\n      onChangeCell(\"survey\", node.rowIndex, \"hint\", value, node);\n      setEditedHintString(undefined);\n    },\n    [node, onChangeCell]\n  );\n\n  if (language === undefined) {\n    return null;\n  }\n\n  const hintString = node.row.hint?.[language];\n  const value = editedHintString === undefined ? hintString : editedHintString;\n  const shownValue = value?.trim() === \"\" ? undefined : value;\n  const hintElement = hintString !== undefined && hintString !== \"\" && (\n    <Callout intent=\"primary\">\n      {debug && (\n        <EditableText\n          multiline={true}\n          onChange={setEditedHintString}\n          onConfirm={onChangeHint}\n          placeholder={`Enter a hint text in ${context.languageName}…`}\n          value={shownValue}\n          minWidth={100}\n        />\n      )}\n      {!debug && hintString}\n    </Callout>\n  );\n\n  return hintElement || null;\n}\n","import { Classes, ControlGroup, EditableText } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport StyledMarkdown from \"../../components/StyledMarkdown\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { FieldProps } from \"../FieldProps\";\n\n/**\n * Displays an editable field label. Supports Markdown when rendering the result.\n */\nexport function EditableFieldLabel(\n  props: FieldProps & {\n    debug: boolean;\n    minimal?: boolean;\n    children: React.ReactNode;\n    isEditable: boolean;\n  }\n) {\n  const {\n    schema,\n    schemaKey,\n    node,\n    debug,\n    relevant,\n    isEditable,\n    children,\n  } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const labelString = node.row.label?.[context.language || \"English (en)\"];\n  const evaluatedLabel = schema.get(schemaKey, \"label\");\n  const { onChangeCell } = React.useContext(ODKSurveyContext);\n  const path =\n    context.evaluationContext &&\n    getNodeAbsolutePath(node, context.evaluationContext).join(\"/\");\n  const [editedLabelString, setEditedLabelString] = React.useState<string>();\n\n  const onConfirmLabel = React.useCallback(\n    (text: string) => {\n      if (text === labelString || (labelString === undefined && text === \"\")) {\n        return;\n      }\n      onChangeCell(\"survey\", node.rowIndex, \"label\", text, node);\n      setEditedLabelString(undefined);\n    },\n    [labelString, node, onChangeCell]\n  );\n\n  let labelInput =\n    isEditable && debug ? (\n      <EditableText\n        onChange={setEditedLabelString}\n        onConfirm={onConfirmLabel}\n        placeholder={`Enter a title for \\`${node.row.name}\\` in ${context.languageName}…`}\n        value={\n          editedLabelString === undefined ? labelString : editedLabelString\n        }\n        minWidth={100}\n        confirmOnEnterKey={true}\n        multiline={true}\n      />\n    ) : (\n      evaluatedLabel\n    );\n\n  if (children) {\n    return (\n      <ControlGroup\n        style={{ alignItems: \"center\" }}\n        lang={context.languageCode}\n      >\n        {\n          <span\n            id={path}\n            className={relevant ? \"\" : Classes.TEXT_DISABLED}\n            style={{ flex: 1 }}\n          >\n            {debug ? (\n              labelInput\n            ) : (\n              <StyledMarkdown>{evaluatedLabel}</StyledMarkdown>\n            )}\n          </span>\n        }\n        {children}\n      </ControlGroup>\n    );\n  } else {\n    return (\n      <span\n        id={path}\n        className={relevant ? \"\" : Classes.TEXT_DISABLED}\n        style={{ flex: 1 }}\n        lang={context.languageCode}\n      >\n        {debug ? labelInput : <StyledMarkdown>{evaluatedLabel}</StyledMarkdown>}\n      </span>\n    );\n  }\n}\n","/*\n\nCopyright (c) 2012 Ross Turner and contributors (https://github.com/zsinj)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nBased on code from these repositories:\n\n- https://github.com/rossturner/HTML5-ImageUploader\n- https://github.com/ericnograles/browser-image-resizer\n\nConverted to TypeScript, added some error handling, use blobs instead of data URLs.\n\n*/\n\nimport ExifReader from \"exifreader\";\n\nexport type Configuration = {\n  quality: number;\n  maxWidth: number;\n  maxHeight: number;\n  outputWidth?: number;\n  maxSize?: number;\n  scaleRatio?: number;\n  autoRotate: boolean;\n  debug: boolean;\n  mimeType: string;\n};\n\nconst DEFAULT_CONFIG: Configuration = {\n  quality: 0.5,\n  maxWidth: 800,\n  maxHeight: 600,\n  autoRotate: true,\n  debug: false,\n  mimeType: \"image/jpeg\",\n};\n\nexport function readAndCompressImage(\n  file: File,\n  userConfig: Configuration\n): Promise<Blob> {\n  return new Promise((resolve) => {\n    const img = document.createElement(\"img\");\n    const config = Object.assign({}, DEFAULT_CONFIG, userConfig);\n\n    img.src = URL.createObjectURL(file);\n    img.onload = function () {\n      if (config.autoRotate) {\n        if (config.debug)\n          console.log(\"browser-image-resizer: detecting image orientation...\");\n        const fileReader = new FileReader();\n        fileReader.onload = () => {\n          let orientation: ExifReader.NumberTag | undefined;\n          try {\n            const buffer = fileReader.result;\n            if (!(buffer instanceof ArrayBuffer)) {\n              throw new Error(\n                \"Buffer was not defined as Buffer object after reading.\"\n              );\n            }\n            const Result = ExifReader.load(buffer);\n            orientation = Result.Orientation;\n          } catch (err) {\n            console.log(\"Could not determine image orientation:\", err);\n            throw new Error(\"Could not determine image orientation.\");\n          }\n          if (config.debug) {\n            console.log(\n              \"browser-image-resizer: image orientation from EXIF tag = \" +\n                orientation\n            );\n          }\n          resolve(scaleImage(img, config, orientation?.value));\n          URL.revokeObjectURL(img.src);\n        };\n        fileReader.readAsArrayBuffer(file);\n      } else {\n        if (config.debug)\n          console.log(\n            \"browser-image-resizer: ignoring EXIF orientation tag because autoRotate is false...\"\n          );\n        resolve(scaleImage(img, config));\n        URL.revokeObjectURL(img.src);\n      }\n    };\n  });\n}\n\nasync function scaleImage(\n  img: HTMLImageElement,\n  config: Configuration,\n  orientation = 1\n): Promise<Blob> {\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n\n  // EXIF\n  exifApplied(canvas, orientation, img);\n\n  const maxWidth = findMaxWidth(config, canvas);\n\n  while (canvas.width >= 2 * maxWidth) {\n    canvas = getHalfScaleCanvas(canvas);\n  }\n\n  if (canvas.width > maxWidth) {\n    canvas = scaleCanvasWithAlgorithm(canvas, maxWidth);\n  }\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      (result) => {\n        if (result == null) {\n          reject();\n        } else {\n          resolve(result);\n        }\n      },\n      config.mimeType,\n      config.quality\n    );\n  });\n}\n\nfunction findMaxWidth(config: Configuration, canvas: HTMLCanvasElement) {\n  //Let's find the max available width for scaled image\n  let ratio = canvas.width / canvas.height;\n  let mWidth = Math.min(\n    canvas.width,\n    config.maxWidth,\n    ratio * config.maxHeight\n  );\n  if (\n    config.maxSize !== undefined &&\n    config.maxSize > 0 &&\n    config.maxSize < (canvas.width * canvas.height) / 1000\n  )\n    mWidth = Math.min(\n      mWidth,\n      Math.floor((config.maxSize * 1000) / canvas.height)\n    );\n  if (!!config.scaleRatio)\n    mWidth = Math.min(mWidth, Math.floor(config.scaleRatio * canvas.width));\n\n  if (config.debug) {\n    console.log(\n      \"browser-image-resizer: original image size = \" +\n        canvas.width +\n        \" px (width) X \" +\n        canvas.height +\n        \" px (height)\"\n    );\n    console.log(\n      \"browser-image-resizer: scaled image size = \" +\n        mWidth +\n        \" px (width) X \" +\n        Math.floor(mWidth / ratio) +\n        \" px (height)\"\n    );\n  }\n  if (mWidth <= 0) {\n    throw new Error(\"Image size is too small.\");\n  }\n\n  return mWidth;\n}\n\nfunction exifApplied(\n  canvas: HTMLCanvasElement,\n  orientation: number,\n  img: HTMLImageElement\n) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return;\n  }\n\n  ctx.save();\n  let width = canvas.width;\n  let styleWidth = canvas.style.width;\n  let height = canvas.height;\n  let styleHeight = canvas.style.height;\n  if (orientation > 4) {\n    canvas.width = height;\n    canvas.style.width = styleHeight;\n    canvas.height = width;\n    canvas.style.height = styleWidth;\n  }\n  switch (orientation) {\n    case 2:\n      ctx.translate(width, 0);\n      ctx.scale(-1, 1);\n      break;\n    case 3:\n      ctx.translate(width, height);\n      ctx.rotate(Math.PI);\n      break;\n    case 4:\n      ctx.translate(0, height);\n      ctx.scale(1, -1);\n      break;\n    case 5:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.scale(1, -1);\n      break;\n    case 6:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.translate(0, -height);\n      break;\n    case 7:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.translate(width, -height);\n      ctx.scale(-1, 1);\n      break;\n    case 8:\n      ctx.rotate(-0.5 * Math.PI);\n      ctx.translate(-width, 0);\n      break;\n  }\n  ctx.drawImage(img, 0, 0);\n  ctx.restore();\n}\n\nfunction scaleCanvasWithAlgorithm(\n  canvas: HTMLCanvasElement,\n  outputWidth: number\n) {\n  const scaledCanvas = document.createElement(\"canvas\");\n  const scale = outputWidth / canvas.width;\n\n  scaledCanvas.width = canvas.width * scale;\n  scaledCanvas.height = canvas.height * scale;\n\n  const srcImgData = canvas\n    .getContext(\"2d\")\n    ?.getImageData(0, 0, canvas.width, canvas.height);\n  if (!srcImgData) {\n    throw new Error(\n      \"Could not reduce image size (Could not get original image data).\"\n    );\n  }\n\n  const destImgData = scaledCanvas\n    .getContext(\"2d\")\n    ?.createImageData(scaledCanvas.width, scaledCanvas.height);\n  if (!destImgData) {\n    throw new Error(\n      \"Could not reduce image size (Could not get resized image data).\"\n    );\n  }\n\n  applyBilinearInterpolation(srcImgData, destImgData, scale);\n\n  scaledCanvas.getContext(\"2d\")?.putImageData(destImgData, 0, 0);\n\n  return scaledCanvas;\n}\n\nfunction getHalfScaleCanvas(canvas: HTMLCanvasElement) {\n  let halfCanvas = document.createElement(\"canvas\");\n  halfCanvas.width = canvas.width / 2;\n  halfCanvas.height = canvas.height / 2;\n\n  const ctx = halfCanvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"Could not reduce image size (<canvas> error).\");\n  }\n  ctx.drawImage(canvas, 0, 0, halfCanvas.width, halfCanvas.height);\n\n  return halfCanvas;\n}\n\nfunction applyBilinearInterpolation(\n  srcCanvasData: ImageData,\n  destCanvasData: ImageData,\n  scale: number\n) {\n  function inner(\n    f00: number,\n    f10: number,\n    f01: number,\n    f11: number,\n    x: number,\n    y: number\n  ) {\n    let un_x = 1.0 - x;\n    let un_y = 1.0 - y;\n    return f00 * un_x * un_y + f10 * x * un_y + f01 * un_x * y + f11 * x * y;\n  }\n  let i, j;\n  let iyv, iy0, iy1, ixv, ix0, ix1;\n  let idxD, idxS00, idxS10, idxS01, idxS11;\n  let dx, dy;\n  let r, g, b, a;\n  for (i = 0; i < destCanvasData.height; ++i) {\n    iyv = i / scale;\n    iy0 = Math.floor(iyv);\n    // Math.ceil can go over bounds\n    iy1 =\n      Math.ceil(iyv) > srcCanvasData.height - 1\n        ? srcCanvasData.height - 1\n        : Math.ceil(iyv);\n    for (j = 0; j < destCanvasData.width; ++j) {\n      ixv = j / scale;\n      ix0 = Math.floor(ixv);\n      // Math.ceil can go over bounds\n      ix1 =\n        Math.ceil(ixv) > srcCanvasData.width - 1\n          ? srcCanvasData.width - 1\n          : Math.ceil(ixv);\n      idxD = (j + destCanvasData.width * i) * 4;\n      // matrix to vector indices\n      idxS00 = (ix0 + srcCanvasData.width * iy0) * 4;\n      idxS10 = (ix1 + srcCanvasData.width * iy0) * 4;\n      idxS01 = (ix0 + srcCanvasData.width * iy1) * 4;\n      idxS11 = (ix1 + srcCanvasData.width * iy1) * 4;\n      // overall coordinates to unit square\n      dx = ixv - ix0;\n      dy = iyv - iy0;\n      // I let the r, g, b, a on purpose for debugging\n      r = inner(\n        srcCanvasData.data[idxS00],\n        srcCanvasData.data[idxS10],\n        srcCanvasData.data[idxS01],\n        srcCanvasData.data[idxS11],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD] = r;\n\n      g = inner(\n        srcCanvasData.data[idxS00 + 1],\n        srcCanvasData.data[idxS10 + 1],\n        srcCanvasData.data[idxS01 + 1],\n        srcCanvasData.data[idxS11 + 1],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 1] = g;\n\n      b = inner(\n        srcCanvasData.data[idxS00 + 2],\n        srcCanvasData.data[idxS10 + 2],\n        srcCanvasData.data[idxS01 + 2],\n        srcCanvasData.data[idxS11 + 2],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 2] = b;\n\n      a = inner(\n        srcCanvasData.data[idxS00 + 3],\n        srcCanvasData.data[idxS10 + 3],\n        srcCanvasData.data[idxS01 + 3],\n        srcCanvasData.data[idxS11 + 3],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 3] = a;\n    }\n  }\n}\n","import { ImageObject } from \"../../xlsform-simple-schema/functions/schema-creation/MediaSchemas\";\nimport { AccessibilityCloudImage } from \"./AccessibilityCloudImage\";\nimport { readAndCompressImage } from \"./ImageResizer\";\n\nconst imageResizeConfig = {\n  quality: 0.8,\n  maxWidth: 1600,\n  maxHeight: 1600,\n  autoRotate: true,\n  debug: true,\n  mimeType: \"image/jpeg\",\n};\n\nconst uncachedBaseUrl =\n  process.env.REACT_APP_ACCESSIBILITY_CLOUD_UNCACHED_BASE_URL || \"\";\nconst baseUrl = process.env.REACT_APP_ACCESSIBILITY_CLOUD_BASE_URL || \"\";\nconst appToken = process.env.REACT_APP_ACCESSIBILITY_CLOUD_APP_TOKEN;\n\nexport function getImageSourceUrl(\n  image: AccessibilityCloudImage,\n  size: number\n) {\n  return `${\n    process.env.REACT_APP_ACCESSIBILITY_CLOUD_BASE_URL || \"\"\n  }/images/scale/${image.remotePath}?fitw=${size}&fith=${size}`;\n}\n\nexport function getAccessibilityCloudImageUrl(\n  context: string,\n  objectId: string,\n  appToken: string,\n  useCache: boolean = true\n): string {\n  return `${\n    useCache ? baseUrl : uncachedBaseUrl\n  }/images.json?context=${context}&surveyResultId=${objectId}&appToken=${appToken}`;\n}\n\n/** @returns a Schema.org JSON-LD object for a given remotely stored image. */\nexport function createImageObjectFromRemoteImage(\n  image: AccessibilityCloudImage\n): ImageObject {\n  return {\n    \"@type\": \"ImageObject\",\n    contentSize: String(image.contentSize),\n    contentUrl: getImageSourceUrl(image, 1600),\n    encodingFormat: \"image/jpeg\",\n    height: `${image.dimensions.height}px`,\n    width: `${image.dimensions.width}px`,\n    thumbnail: {\n      \"@type\": \"ImageObject\",\n      contentUrl: getImageSourceUrl(image, 256),\n      encodingFormat: \"image/jpeg\",\n      height: `256px`,\n      width: `256px`,\n    },\n  };\n}\n\n/** @returns a Schema.org JSON-LD object for a given local File object. */\nexport function createImageObjectFromFile(file: File): ImageObject {\n  return {\n    \"@type\": \"ImageObject\",\n    contentSize: String(file.size),\n    contentUrl: URL.createObjectURL(file),\n    encodingFormat: \"image/jpeg\",\n  };\n}\n\n/**\n * Uploads a photo to accessibility.cloud, returning accessibility.cloud's internal JSON\n * representation of the image.\n */\nexport async function uploadPhoto(\n  /** The survey result's ID to attach the image to. */\n  surveyResultId: string,\n  /** the image's local File object. */\n  file: File\n): Promise<AccessibilityCloudImage> {\n  const url = `${uncachedBaseUrl}/image-upload/survey-result/image?surveyResultId=${surveyResultId}&appToken=${appToken}`;\n  const resizedImage = await readAndCompressImage(file, imageResizeConfig);\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"image/jpeg\",\n    },\n    body: resizedImage,\n  });\n\n  const json = await response.json();\n\n  if (!response.ok) {\n    throw new Error(json.error?.reason || json.error);\n  }\n\n  if (!json.success) {\n    const message = `Sorry, your upload failed: ${String(json.error)}`;\n    throw new Error(message);\n  }\n  if (!json.result) {\n    const message = \"Sorry, your upload failed: Empty server response.\";\n    throw new Error(message);\n  }\n\n  return json.result;\n}\n","import {\n  Button,\n  Card,\n  ControlGroup,\n  Elevation,\n  FileInput,\n  FormGroup,\n  InputGroup,\n  Spinner,\n} from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { uuid as getUUID } from \"uuidv4\";\nimport {\n  createImageObjectFromFile,\n  createImageObjectFromRemoteImage,\n  uploadPhoto,\n} from \"../../lib/images/uploadPhoto\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { AppToaster } from \"../../toaster\";\nimport { ImageObject } from \"../../xlsform-simple-schema/functions/schema-creation/MediaSchemas\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: ImageObject;\n  defaultValue: unknown;\n};\n\n/** Displays the uploaded image, with an editable caption and a 'remove' button. */\nfunction ImageCard({\n  contentUrl,\n  uuid,\n  onChangeCaption,\n  onRemoveImage,\n}: {\n  contentUrl: string;\n  uuid: string;\n  onChangeCaption: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  onRemoveImage: () => void;\n}) {\n  return (\n    <Card interactive={false} elevation={Elevation.ONE}>\n      {/* eslint-disable-next-line jsx-a11y/img-redundant-alt*/}\n      <img\n        src={contentUrl}\n        alt=\"The image you uploaded\"\n        style={{\n          maxWidth: \"100%\",\n          maxHeight: \"calc(40vh)\",\n          boxShadow: \"0 0 1px rgba(0, 0, 0, 0.5)\",\n          marginBottom: \"16px\",\n        }}\n      />\n      <ControlGroup fill={true}>\n        <FormGroup\n          label={`Please describe what is on this image.`}\n          labelFor={`imagecaption-${uuid}`}\n          style={{ display: \"flex\" }}\n        >\n          <InputGroup\n            id={`imagecaption-${uuid}`}\n            placeholder=\"\"\n            large={true}\n            onChange={onChangeCaption}\n            pattern=\"[\\w\\d_-]+\"\n          />\n        </FormGroup>\n      </ControlGroup>\n      <ControlGroup style={{}}>\n        <Button\n          intent=\"danger\"\n          icon=\"trash\"\n          outlined={true}\n          onClick={onRemoveImage}\n          large={true}\n        >\n          Remove image\n        </Button>\n      </ControlGroup>\n    </Card>\n  );\n}\n\nfunction showUploadingState(uuid: string) {\n  AppToaster.show(\n    {\n      message: <>Uploading image</>,\n      icon: (\n        <ControlGroup style={{ alignSelf: \"center\", marginLeft: \"8px\" }}>\n          <Spinner size={Spinner.SIZE_SMALL} />\n        </ControlGroup>\n      ),\n      timeout: 0,\n    },\n    uuid\n  );\n}\n\nfunction showPersistentErrorToast(message: string, uuid: string) {\n  AppToaster.show({ message, intent: \"danger\", timeout: 0 }, uuid);\n}\n\nexport default function FileUploadField(props: Props) {\n  const { value, schemaKey, relevant, readonly } = props;\n\n  const context = React.useContext(ODKSurveyContext);\n  const { onChangeAnswer } = context;\n  const [uuid] = React.useState(getUUID());\n\n  const onChangeCaption = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const caption = event.currentTarget.value;\n      onChangeAnswer({ ...value, caption }, props);\n    },\n    [onChangeAnswer, props, value]\n  );\n\n  const onRemoveImage = React.useCallback(() => {\n    onChangeAnswer(undefined, props);\n  }, [onChangeAnswer, props]);\n\n  const onInputChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const file = event.currentTarget.files?.[0];\n      if (!file) {\n        onRemoveImage();\n        return;\n      }\n\n      showUploadingState(uuid);\n\n      onChangeAnswer(createImageObjectFromFile(file), props);\n\n      uploadPhoto(uuid, file)\n        .then((response) => {\n          onChangeAnswer(createImageObjectFromRemoteImage(response), props);\n          AppToaster.show(\n            { message: \"Upload successful!\", intent: \"success\", timeout: 5000 },\n            uuid\n          );\n        })\n        .catch((reason) => {\n          debugger;\n          const message = `Sorry, your upload failed: ${reason}`;\n          console.error(message);\n          showPersistentErrorToast(message, uuid);\n          onRemoveImage();\n        });\n    },\n    [uuid, onChangeAnswer, props, onRemoveImage]\n  );\n\n  const image = value && (\n    <ImageCard\n      {...{\n        contentUrl: value.contentUrl,\n        onChangeCaption,\n        onRemoveImage,\n        uuid,\n      }}\n    />\n  );\n\n  return (\n    <>\n      {!value && (\n        <FileInput\n          id={schemaKey}\n          disabled={relevant === false || readonly}\n          large={true}\n          onInputChange={onInputChange}\n          inputProps={{ multiple: false, accept: \"image/jpeg, image/png\" }}\n        />\n      )}\n\n      {image}\n    </>\n  );\n}\n","import SimpleSchema, { SchemaDefinition } from \"simpl-schema\";\n\n/**\n * The geographic coordinates of a place or event.\n * @see https://schema.org/GeoCoordinates\n */\nexport interface SchemaOrgPointGeometry {\n  \"@type\": \"GeoCoordinates\";\n  latitude: number;\n  longitude: number;\n}\n\nexport function assertSchemaOrgPointGeometry(\n  point: unknown\n): asserts point is SchemaOrgPointGeometry | undefined {\n  if (point === undefined) {\n    return;\n  }\n  const schema = new SimpleSchema(getSchemaOrgPointGeometrySchema(\"point\"));\n  schema.validate({ point });\n}\n\n/**\n * A line string as Schema.org type.\n *\n * @see https://schema.org/GeoShape\n */\n\nexport interface SchemaOrgLineStringGeometry {\n  \"@type\": \"GeoShape\";\n  line: string;\n}\n\n/**\n * A polygon string as Schema.org type.\n *\n * @see https://schema.org/GeoShape\n */\nexport interface SchemaOrgPolygonGeometry {\n  \"@type\": \"GeoShape\";\n  polygon: string;\n}\n\n/** @returns a SimpleSchema definition for a Schema.org point geometry. */\nexport const getSchemaOrgPointGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"GeoCoordinates\"],\n    defaultValue: \"GeoCoordinates\",\n  },\n  [`${key}.latitude`]: {\n    type: Number,\n  },\n  [`${key}.longitude`]: {\n    type: Number,\n  },\n});\n\n/** @returns a SimpleSchema definition for a Schema.org line string geometry. */\nexport const getSchemaOrgLineStringGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"GeoShape\"],\n    defaultValue: \"GeoShape\",\n  },\n  [`${key}.line`]: {\n    type: String,\n  },\n});\n\n/** @returns a SimpleSchema definition for a Schema.org polygon geometry. */\nexport const getSchemaOrgPolygonGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"GeoShape\"],\n    defaultValue: \"GeoShape\",\n  },\n  [`${key}.polygon`]: {\n    type: String,\n  },\n});\n\nexport type SchemaoOrgGeometry =\n  | SchemaOrgPointGeometry\n  | SchemaOrgLineStringGeometry\n  | SchemaOrgPolygonGeometry;\n","import { Colors, ControlGroup, NumericInput } from \"@blueprintjs/core\";\nimport { throttle } from \"lodash\";\nimport \"mapbox-gl/dist/mapbox-gl.css\";\nimport * as React from \"react\";\nimport ReactMapGL, { GeolocateControl, ViewportProps } from \"react-map-gl\";\nimport styled from \"styled-components\";\nimport { useDarkMode } from \"../../components/DarkModeContainer\";\nimport { alpha } from \"../../lib/colors\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport {\n  assertSchemaOrgPointGeometry,\n  SchemaOrgPointGeometry,\n} from \"../../xlsform-simple-schema/functions/schema-creation/geometry/SchemaOrgGeometry\";\nimport { FieldProps } from \"../FieldProps\";\n\nconst FieldContainer = styled.section`\n  .mapboxgl-ctrl-group.geolocateControl {\n    display: inline-block;\n    margin: 8px;\n  }\n\n  > footer {\n    width: 100%;\n    margin-top: 8px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: space-between;\n    label {\n      margin: 0.5rem;\n    }\n    input {\n      width: 8rem !important;\n    }\n  }\n`;\n\nconst MapContainer = styled.section`\n  width: 100%;\n  height: 500px;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  overflow: hidden;\n  position: relative;\n`;\n\nconst CenteredPoint = styled.div`\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 15px;\n  height: 15px;\n  border: 3px solid white;\n  border-radius: 10px;\n  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.4);\n  background-color: ${Colors.FOREST3};\n`;\n\nfunction getPointForCoordinates(\n  coordinates: [number, number]\n): SchemaOrgPointGeometry {\n  // return {\n  //   type: \"Point\",\n  //   coordinates: [Number(coordinates[0].toFixed(6)), Number(coordinates[1].toFixed(6))],\n  // };\n  return {\n    \"@type\": \"GeoCoordinates\",\n    longitude: Number(coordinates[0].toFixed(6)),\n    latitude: Number(coordinates[1].toFixed(6)),\n  };\n}\n\nfunction getLatitudeFromValue(value: SchemaOrgPointGeometry) {\n  return value.latitude;\n}\n\nfunction getLongitudeFromValue(value: SchemaOrgPointGeometry) {\n  return value.longitude;\n}\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nfunction GeoPointField(props: Props) {\n  const { value } = props;\n  assertSchemaOrgPointGeometry(value);\n\n  const context = React.useContext(ODKSurveyContext);\n  const { onChangeAnswer } = context;\n\n  const [viewport, setViewport] = React.useState<\n    Partial<ViewportProps> & { width: number; height: number }\n  >({\n    width: 100,\n    height: 100,\n    latitude: (value && getLatitudeFromValue(value)) || 37.7577,\n    longitude: (value && getLongitudeFromValue(value)) || -122.4376,\n    zoom: 10,\n  });\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const onChangeAnswerDebounced = React.useCallback(\n    throttle((value: unknown, props: FieldProps) => {\n      onChangeAnswer(value, props);\n    }, 500),\n    [onChangeAnswer]\n  );\n\n  const setViewportCallback = React.useCallback(\n    (viewState, interactionState) => {\n      setViewport({ ...viewport, ...viewState });\n      if (!viewport.longitude || !viewport.latitude) {\n        return;\n      }\n      const newPoint = getPointForCoordinates([\n        viewport.longitude,\n        viewport.latitude,\n      ]);\n      onChangeAnswerDebounced(newPoint, props);\n    },\n    [viewport, onChangeAnswerDebounced, props]\n  );\n\n  const changeLatitude = React.useCallback(\n    (newLatitudeNumber: number, newLatitudeString: string) => {\n      if (!viewport.longitude || !viewport.latitude) {\n        return;\n      }\n      setViewport({ ...viewport, latitude: newLatitudeNumber });\n      const newPoint = getPointForCoordinates([\n        viewport.longitude,\n        newLatitudeNumber,\n      ]);\n      onChangeAnswer(newPoint, props);\n    },\n    [viewport, onChangeAnswer, props]\n  );\n\n  const changeLongitude = React.useCallback(\n    (newLongitudeNumber: number, newLongitudeString: string) => {\n      if (!viewport.longitude || !viewport.latitude) {\n        return;\n      }\n      setViewport({ ...viewport, longitude: newLongitudeNumber });\n      const newPoint = getPointForCoordinates([\n        newLongitudeNumber,\n        viewport.latitude,\n      ]);\n      onChangeAnswer(newPoint, props);\n    },\n    [viewport, onChangeAnswer, props]\n  );\n\n  const isDarkMode = useDarkMode();\n  const latitude = value && getLatitudeFromValue(value);\n  const longitude = value && getLongitudeFromValue(value);\n  const inputs = (\n    <FieldContainer>\n      <MapContainer>\n        <ReactMapGL\n          longitude={longitude}\n          latitude={latitude}\n          {...viewport}\n          mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n          width=\"100%\"\n          height=\"100%\"\n          onViewportChange={setViewportCallback}\n          mapStyle={\n            isDarkMode\n              ? \"mapbox://styles/mapbox/streets-dark-v10\"\n              : \"mapbox://styles/mapbox/streets-v10\"\n          }\n        >\n          <GeolocateControl\n            style={{\n              margin: \"8px\",\n              boxShadow: `0 2px 2px ${alpha(\n                Colors.DARK_GRAY4,\n                0.2\n              )}, 0 2px 10px ${alpha(Colors.DARK_GRAY4, 0.3)}`,\n            }}\n            className=\"geolocateControl\"\n            positionOptions={{ enableHighAccuracy: true }}\n            trackUserLocation={false}\n            showUserLocation={true}\n          />\n        </ReactMapGL>\n        <CenteredPoint />\n      </MapContainer>\n\n      {context.debug && (\n        <ControlGroup style={{ alignItems: \"center\", margin: \"8px 0\" }}>\n          <ControlGroup vertical={true}>\n            <label htmlFor={`${props.schemaKey}-latitude`}>{\"Latitude\"}</label>\n            <NumericInput\n              style={{ width: \"8em\" }}\n              stepSize={0.001}\n              minorStepSize={0.0001}\n              majorStepSize={0.01}\n              min={-90}\n              max={90}\n              value={latitude}\n              asyncControl={true}\n              disabled={props.readonly}\n              id={`${props.schemaKey}-latitude`}\n              onValueChange={changeLatitude}\n            />\n          </ControlGroup>\n\n          <ControlGroup vertical={true} style={{ marginLeft: \"16px\" }}>\n            <label htmlFor={`${props.schemaKey}-longitude`}>\n              {\"Longitude\"}\n            </label>\n            <NumericInput\n              style={{ width: \"8em\" }}\n              stepSize={0.001}\n              minorStepSize={0.0001}\n              majorStepSize={0.01}\n              min={-180}\n              max={180}\n              asyncControl={true}\n              value={longitude}\n              disabled={props.readonly}\n              id={`${props.schemaKey}-longitude`}\n              onValueChange={changeLongitude}\n            />\n          </ControlGroup>\n        </ControlGroup>\n      )}\n    </FieldContainer>\n  );\n\n  return inputs;\n}\n\nexport default GeoPointField;\n","import { Callout, Code, NumericInput } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\n/** An input field for a decimal or integer number. */\nexport default function NumberField(props: Props) {\n  const { value, schemaKey, relevant, readonly } = props;\n  const { onChangeAnswer } = React.useContext(ODKSurveyContext);\n  const onChange = React.useCallback(\n    (valueAsNumber: number) => {\n      onChangeAnswer(valueAsNumber, props);\n    },\n    [props, onChangeAnswer]\n  );\n\n  if (\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    typeof value !== \"number\"\n  ) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>number</Code> for this field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  return (\n    <NumericInput\n      id={schemaKey}\n      disabled={relevant === false || readonly}\n      name={schemaKey}\n      large={true}\n      allowNumericCharactersOnly={false}\n      placeholder=\"Enter a number…\"\n      value={value}\n      onValueChange={onChange}\n      defaultValue={\n        typeof props.defaultValue === \"number\" ||\n        typeof props.defaultValue === \"string\"\n          ? props.defaultValue\n          : undefined\n      }\n    />\n  );\n}\n","import {\n  Callout,\n  Code,\n  ControlGroup,\n  H4,\n  Radio,\n  RadioGroup,\n} from \"@blueprintjs/core\";\nimport { FLEX_EXPANDER } from \"@blueprintjs/core/lib/esm/common/classes\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport getAllowedChoiceValues from \"../../xlsform-simple-schema/functions/schema-creation/getAllowedChoiceValues\";\nimport { FieldTypeButtonGroup } from \"../FieldPopoverButton/FieldTypeButtonGroup\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function RadioGroupField(props: Props) {\n  const { value, onInputChange, node, relevant, readonly } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { language, xlsForm, evaluationContext: evaluationContext } = context;\n\n  if (value !== undefined && typeof value !== \"string\") {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n\n  if (\n    language === undefined ||\n    xlsForm === undefined ||\n    context === undefined ||\n    evaluationContext === undefined\n  ) {\n    return null;\n  }\n\n  if (context.debug && node.typeParameters.length === 0) {\n    return (\n      <Callout intent=\"warning\">\n        <ControlGroup fill={true}>\n          <H4>No choice list set.</H4>\n          <div className={FLEX_EXPANDER} />\n          <FieldTypeButtonGroup node={node} showType={false} />\n        </ControlGroup>\n      </Callout>\n    );\n  }\n\n  const choiceLists = node.typeParameters.map(\n    (choiceListName) => context.xlsForm?.choicesByName[choiceListName]\n  );\n  const key = getNodeAbsolutePathString(node, evaluationContext, \".\");\n  let allowedValues = getAllowedChoiceValues({\n    node,\n    xlsForm,\n    context: evaluationContext,\n    key,\n  });\n  if (!(allowedValues instanceof Array)) {\n    allowedValues = allowedValues();\n  }\n  const allowedValuesSet = new Set(allowedValues);\n\n  return (\n    <RadioGroup\n      onChange={onInputChange}\n      selectedValue={\n        value !== undefined && allowedValuesSet.has(value) ? value : undefined\n      }\n      inline={true}\n      disabled={relevant === false || readonly}\n    >\n      {choiceLists.flatMap(\n        (choiceList) =>\n          choiceList &&\n          Object.keys(choiceList)\n            .flatMap((choiceName) => {\n              if (!allowedValuesSet.has(choiceName)) {\n                return null;\n              }\n              const choiceRow =\n                choiceName === undefined ? undefined : choiceList?.[choiceName];\n              const definedLabel = choiceRow?.label?.[language];\n              const shownLabel =\n                definedLabel === \"undefined\" ? choiceRow?.name : definedLabel;\n              return (\n                <Radio\n                  key={choiceRow?.name}\n                  label={shownLabel}\n                  value={choiceRow?.name}\n                  inline={true}\n                  large={true}\n                />\n              );\n            })\n            .filter(Boolean)\n      )}\n    </RadioGroup>\n  );\n}\n","import { Callout, Code, InputGroup } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function TextField(props: Props) {\n  const { value, schemaKey, relevant, readonly } = props;\n\n  if (\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    typeof value !== \"number\"\n  ) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> or <Code>number</Code> for this\n          field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  return (\n    <InputGroup\n      id={schemaKey}\n      disabled={relevant === false || readonly}\n      name={schemaKey}\n      placeholder=\"\"\n      large={true}\n      onChange={props.onInputChange}\n      defaultValue={\n        typeof props.defaultValue === \"string\" ? props.defaultValue : undefined\n      }\n    />\n  );\n}\n","import { Callout, FormGroup } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport ErrorBoundary from \"../../components/ErrorBoundary\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { internalFieldTypes } from \"../../xlsform-simple-schema/field-types/internalFieldTypes\";\nimport FieldPopoverButton from \"../FieldPopoverButton/FieldPopoverButton\";\nimport { FieldProps } from \"../FieldProps\";\nimport BooleanField from \"./BooleanField\";\nimport CalculateField from \"./CalculateField\";\nimport CheckboxGroupField from \"./CheckboxGroupField\";\nimport DateField from \"./DateField\";\nimport { EditableFieldHint } from \"./EditableFieldHint\";\nimport { EditableFieldLabel } from \"./EditableFieldLabel\";\nimport FileUploadField from \"./FileUploadField\";\nimport GeoPointField from \"./GeoPointField\";\nimport NumberField from \"./NumberField\";\nimport RadioGroupField from \"./RadioGroupField\";\nimport TextField from \"./TextField\";\n\ntype AutoFieldProps = FieldProps & {\n  value: any;\n  defaultValue: unknown;\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: JSX.Element;\n};\n\nexport function AutoField(props: AutoFieldProps) {\n  const { node } = props;\n\n  const FieldComponentMap: Record<\n    string,\n    React.FunctionComponent<AutoFieldProps>\n  > = {\n    integer: NumberField,\n    decimal: NumberField,\n    range: NumberField,\n    text: TextField,\n    select_one: RadioGroupField,\n    select_one_from_file: RadioGroupField,\n    select_multiple: CheckboxGroupField,\n    select_multiple_from_file: CheckboxGroupField,\n    rank: TextField,\n    note: TextField,\n    geopoint: GeoPointField,\n    geotrace: TextField,\n    geoshape: TextField,\n    date: DateField,\n    time: DateField,\n    datetime: DateField,\n    image: FileUploadField,\n    audio: FileUploadField,\n    video: FileUploadField,\n    file: FileUploadField,\n    barcode: TextField,\n    calculate: CalculateField,\n    acknowledge: BooleanField,\n    hidden: TextField,\n    \"xml-external\": TextField,\n    start: DateField,\n    end: DateField,\n    today: DateField,\n    deviceid: TextField,\n    simserial: TextField,\n    subscriberid: TextField,\n    phonenumber: TextField,\n    username: TextField,\n    email: TextField,\n    audit: TextField,\n  };\n\n  const FieldComponent = FieldComponentMap[node.type] || TextField;\n\n  return <FieldComponent {...props} />;\n}\n\nexport default function AnyValueField(props: FieldProps) {\n  const { node } = props;\n  const isBoolean = props.node.type === \"acknowlege\";\n  const context = React.useContext(ODKSurveyContext);\n  const { language, debug, evaluationContext, onChangeAnswer } = context;\n\n  const onInputChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const target = event.currentTarget;\n      const values: Record<string, unknown> = {\n        checkbox: target.checked,\n        date: target.valueAsDate,\n        number: target.valueAsNumber,\n        text: target.value,\n        radio: target.value,\n      };\n      const value = values[target.type];\n      onChangeAnswer(value, props);\n    },\n    [onChangeAnswer, props]\n  );\n\n  if (!language || !evaluationContext) {\n    return null;\n  }\n\n  const isInternalField = internalFieldTypes.includes(node.type);\n  if (isInternalField && !context.debug) {\n    return null;\n  }\n  const detailsButton = (\n    <FieldPopoverButton {...{ ...props }} editable={true} />\n  );\n\n  const hint = <EditableFieldHint {...{ node, debug }} />;\n  const labelElement = (\n    <EditableFieldLabel\n      {...{ ...props, debug, isEditable: !isBoolean && !isInternalField }}\n    >\n      {!isBoolean && debug && detailsButton}\n    </EditableFieldLabel>\n  );\n  // const evaluationResult = evaluateNodeColumn(\n  //   node,\n  //   evaluationContext,\n  //   \"calculation\",\n  //   evaluationContext.nodesToAnswers.get(node)\n  // );\n\n  const nodeEvaluationResults = context.evaluationContext?.evaluationResults.get(\n    node\n  );\n\n  const autoFieldProps = {\n    ...props,\n    labelElement,\n    onInputChange,\n    value: nodeEvaluationResults?.get(\"calculation\")?.result,\n    defaultValue: node.row.default,\n  };\n\n  let input = <AutoField {...autoFieldProps} />;\n  if (isBoolean) {\n    return (\n      <FormGroup labelFor={node.row.name} style={{ display: \"flex\" }}>\n        {debug && detailsButton}\n        {input}\n        {hint}\n      </FormGroup>\n    );\n  }\n\n  if (node.type === \"note\") {\n    return (\n      <Callout intent=\"primary\" style={{ marginBottom: \"16px\" }}>\n        {labelElement}\n      </Callout>\n    );\n  }\n\n  return (\n    <ODKNodeContext.Provider value={{ node, nodeEvaluationResults }}>\n      <FormGroup label={labelElement} labelFor={node.row.name}>\n        <ErrorBoundary>\n          {input}\n          <EditableFieldHint {...{ node, debug }} />\n        </ErrorBoundary>\n      </FormGroup>\n    </ODKNodeContext.Provider>\n  );\n}\n","import {\n  ControlGroup,\n  EditableText,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n} from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { isNodeRelevant } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport FieldPopoverButton from \"../FieldPopoverButton/FieldPopoverButton\";\nimport { FieldProps } from \"../FieldProps\";\nimport { SurveyField } from \"../SurveyField\";\nimport { EditableFieldHint } from \"./EditableFieldHint\";\n\nexport default function FieldGroup(props: FieldProps) {\n  const { onChangeCell } = React.useContext(ODKSurveyContext);\n  const { schema, schemaKey, node } = props;\n  const isComplexType = [\n    \"image\",\n    \"audio\",\n    \"video\",\n    \"geopoint\",\n    \"geotrace\",\n    \"geoshape\",\n  ].includes(node.type);\n  const subKeys = isComplexType ? [] : schema.objectKeys(schemaKey);\n  const context = React.useContext(ODKSurveyContext);\n  const { debug } = context;\n\n  const labelString = schema.get(schemaKey, \"label\");\n  const path =\n    context.evaluationContext &&\n    getNodeAbsolutePath(node, context.evaluationContext).join(\"/\");\n\n  const [editedLabelString, setEditedLabelString] = React.useState<string>();\n\n  const onChangeLabel = React.useCallback(\n    (text: string) => {\n      if (text === labelString || (labelString === undefined && text === \"\")) {\n        return;\n      }\n      onChangeCell(\"survey\", node.rowIndex, \"label\", text, node);\n      setEditedLabelString(undefined);\n    },\n    [node, onChangeCell, labelString]\n  );\n\n  const labelInput = node !== context.evaluationContext?.survey && (\n    <EditableText\n      multiline={true}\n      onChange={setEditedLabelString}\n      onConfirm={onChangeLabel}\n      confirmOnEnterKey={true}\n      placeholder={`Enter a title for \\`${node.row.name}\\`in ${context.languageName}…`}\n      value={editedLabelString === undefined ? labelString : editedLabelString}\n      minWidth={100}\n    />\n  );\n\n  const HeadingClass = [H1, H2, H3, H4, H5][node.indentationLevel] || H5;\n\n  const isRelevant = isNodeRelevant(node, context.evaluationContext);\n  if (!isRelevant && !debug) {\n    return null;\n  }\n  return (\n    <ControlGroup\n      vertical={true}\n      style={{ padding: `${6 / (node.indentationLevel + 1)}rem 0` }}\n    >\n      <ControlGroup\n        fill={false}\n        style={{\n          alignItems: \"baseline\",\n        }}\n      >\n        <HeadingClass\n          style={{\n            flex: 1,\n          }}\n          id={path}\n        >\n          {debug ? <>{labelInput}</> : labelString}\n        </HeadingClass>\n        {debug && node !== context.evaluationContext?.survey && (\n          <FieldPopoverButton {...{ ...props }} editable={true} />\n        )}\n      </ControlGroup>\n      <EditableFieldHint {...{ node, debug }} />\n      {subKeys.map((subkey) => (\n        <SurveyField\n          key={subkey}\n          schemaKey={[schemaKey, subkey].join(\".\")}\n          relevant={props.relevant}\n          readonly={props.readonly}\n        />\n      ))}\n    </ControlGroup>\n  );\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\n/** Displays a 'begin repeat' group of fields. */\nexport default function RepeatField(props: FieldProps) {\n  return (\n    <Callout intent={\"warning\"}>\n      <h4>Object arrays are not implemented yet.</h4>\n    </Callout>\n  );\n}\n","import {\n  Callout,\n  Classes,\n  Code,\n  Colors,\n  H4,\n  Menu,\n  MenuDivider,\n} from \"@blueprintjs/core\";\nimport { ContextMenu2, Popover2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport { alpha } from \"../lib/colors\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { findNodeByPathRelativeToScope } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport AddFieldOrGroupMenuItem from \"./AddFieldMenuItem\";\nimport { useNodeActionMenuItems } from \"./FieldPopoverButton/NodeActionMenuItems\";\nimport { FieldProps } from \"./FieldProps\";\nimport AnyValueField from \"./fields/AnyValueField\";\nimport FieldGroup from \"./fields/FieldGroup\";\nimport RepeatField from \"./fields/RepeatField\";\n\nconst Stripe = styled.div`\n  &:after {\n    content: \"\";\n    position: absolute;\n    left: 0px;\n    width: 1px;\n    bottom: 0;\n    top: 0;\n    background-color: transparent;\n  }\n`;\n\nconst CornerButton = styled.div`\n  position: absolute;\n  left: 0px;\n  height: 44px;\n  width: 44px;\n  background-color: transparent;\n  cursor: pointer;\n`;\n\nconst TopCornerButton = styled(CornerButton)`\n  top: 0;\n  &:hover {\n    background: linear-gradient(\n      135deg,\n      ${alpha(Colors.BLUE3, 0.3)},\n      ${alpha(Colors.BLUE3, 0.0)} 50%\n    );\n  }\n`;\n\nconst BottomCornerButton = styled(CornerButton)`\n  bottom: 0;\n  &:hover {\n    background: linear-gradient(\n      45deg,\n      ${alpha(Colors.BLUE3, 0.3)},\n      ${alpha(Colors.BLUE3, 0.0)} 50%\n    );\n  }\n`;\n\nconst Hoverable = styled.div`\n  padding: 16px 16px 8px;\n  margin: 0;\n  position: relative;\n\n  &:not(:hover):not(:focus-within) {\n    ${Stripe} {\n      background: none;\n    }\n  }\n  &:hover,\n  :focus-within {\n    background: ${alpha(Colors.BLUE3, 0.03)};\n\n    ${Stripe} {\n      &:after {\n        background: ${alpha(Colors.BLUE3, 0.1)};\n      }\n    }\n  }\n`;\n\nexport function SurveyField(props: {\n  schemaKey: string;\n  relevant?: boolean;\n  readonly?: boolean;\n}) {\n  const { schemaKey } = props;\n  const { schema, evaluationContext: context, debug } = React.useContext(\n    ODKSurveyContext\n  );\n\n  const schemaKeyPath = [\".\", ...schemaKey.replace(/\\.\\$/g, \"\").split(\".\")];\n\n  const node =\n    context?.survey &&\n    findNodeByPathRelativeToScope(schemaKeyPath, context, context.survey);\n\n  const { nodeActionMenuItems, nodeActionDialogs } = useNodeActionMenuItems(\n    node instanceof Array ? undefined : node\n  );\n\n  if (!context || !schema) {\n    return null;\n  }\n\n  if (node instanceof Array) {\n    if (!debug) {\n      return null;\n    }\n    return (\n      <Callout intent=\"warning\">\n        <H4>\n          Found multiple nodes with path <Code>{schemaKeyPath.join(\"/\")}</Code>.\n          This should not happen.\n        </H4>\n      </Callout>\n    );\n  }\n\n  if (!node) {\n    if (!debug) {\n      return null;\n    }\n    return (\n      <Callout intent=\"warning\">\n        <H4>\n          No node found for{\" \"}\n          <Code>{schemaKeyPath[schemaKeyPath.length - 1]}</Code>\n        </H4>\n        {/* <p></p> */}\n      </Callout>\n    );\n  }\n\n  let relevant = props.relevant;\n  if (typeof relevant !== \"boolean\" || relevant === true) {\n    const evaluationResult = context.evaluationResults\n      .get(node)\n      ?.get(\"relevant\");\n\n    if (typeof evaluationResult?.result === \"boolean\") {\n      relevant = evaluationResult.result;\n    } else if (evaluationResult?.result === null) {\n      relevant = false;\n    } else {\n      relevant = true;\n    }\n  }\n\n  let readonly = false;\n  if (typeof props.readonly !== \"undefined\" || props.readonly === true) {\n    const evaluationResult = context.evaluationResults\n      .get(node)\n      ?.get(\"readonly\");\n    readonly =\n      typeof evaluationResult?.result === \"boolean\"\n        ? evaluationResult.result\n        : props.readonly;\n  }\n  // TODO: Add warning for evaluation failure\n\n  const fieldProps: FieldProps = {\n    schema,\n    node,\n    schemaKey,\n    relevant,\n    readonly,\n  };\n\n  if (!debug && !relevant) {\n    return null;\n  }\n\n  let field;\n\n  switch (node.type) {\n    case undefined:\n    case \"\":\n      field = <FieldGroup {...fieldProps} />;\n      break;\n    case \"begin_group\":\n      field = <FieldGroup {...fieldProps} />;\n      break;\n    case \"begin_repeat\":\n      field = <RepeatField {...fieldProps} />;\n      break;\n    default:\n      field = <AnyValueField {...fieldProps} />;\n      break;\n  }\n\n  if (debug && node !== context.survey) {\n    const nodeActionMenu = <Menu>{nodeActionMenuItems}</Menu>;\n    return (\n      <>\n        {nodeActionDialogs}\n        <ContextMenu2 content={nodeActionMenu}>\n          <Hoverable>\n            <Stripe />\n\n            <Popover2\n              content={\n                <ul className={Classes.LIST_UNSTYLED}>\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-up\"\n                    node={node}\n                    position=\"before\"\n                    group={false}\n                  />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-up\"\n                    node={node}\n                    position=\"before\"\n                    group={true}\n                  />\n                  <MenuDivider />\n                  {nodeActionMenuItems}\n                </ul>\n              }\n              lazy={true}\n              interactionKind=\"click\"\n              placement=\"left\"\n              renderTarget={({ isOpen, ref, ...targetProps }) => (\n                <TopCornerButton {...targetProps} ref={ref} />\n              )}\n              hoverOpenDelay={0}\n              hoverCloseDelay={0}\n            />\n\n            <Popover2\n              content={\n                <ul className={Classes.LIST_UNSTYLED}>\n                  {nodeActionMenuItems}\n                  <MenuDivider />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-down\"\n                    node={node}\n                    position=\"after\"\n                    group={false}\n                  />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-down\"\n                    node={node}\n                    position=\"after\"\n                    group={true}\n                  />\n                </ul>\n              }\n              lazy={true}\n              interactionKind=\"click\"\n              placement=\"left\"\n              renderTarget={({ isOpen, ref, ...targetProps }) => (\n                <BottomCornerButton {...targetProps} ref={ref} />\n              )}\n              hoverOpenDelay={0}\n              hoverCloseDelay={0}\n            />\n\n            {field}\n          </Hoverable>\n        </ContextMenu2>\n      </>\n    );\n  }\n\n  return field;\n}\n","import * as React from \"react\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport NoSurveyFieldsState from \"./NoSurveyFieldsState\";\nimport { SurveyField } from \"./SurveyField\";\n\nfunction PaddedContainer(\n  props: React.HTMLAttributes<HTMLDivElement> & {\n    horizontal: number;\n    vertical: number;\n  }\n) {\n  return (\n    <div\n      {...{ props }}\n      style={{\n        margin: `${props.horizontal}rem ${props.vertical}rem`,\n        ...props.style,\n      }}\n    >\n      {props.children}\n    </div>\n  );\n}\n\nexport default function XLSFormSurvey(props: {\n  xlsForm: XLSForm;\n  language: string;\n  debug: boolean;\n  className?: string;\n}) {\n  const { languageCode, debug } = React.useContext(ODKSurveyContext);\n\n  // const fieldSets = schema\n  //   ?.objectKeys()\n  //   .map((k) => <FieldSetForKey key={k} schemaKey={k} />);\n  const isSurveyEmpty = props.xlsForm.flatNodes.length === 0;\n  const noSurveyFieldsState = <NoSurveyFieldsState />;\n\n  return (\n    <PaddedContainer\n      horizontal={2}\n      vertical={2}\n      className={props.className}\n      style={{\n        maxWidth: debug ? \"60rem\" : \"50rem\",\n        padding: \"4rem\",\n        margin: \"auto\",\n      }}\n      lang={languageCode}\n    >\n      {isSurveyEmpty ? (\n        noSurveyFieldsState\n      ) : (\n        <SurveyField key={\"data\"} schemaKey={\"data\"} />\n      )}\n    </PaddedContainer>\n  );\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport { Column, EditableCell, Table } from \"@blueprintjs/table\";\nimport { uniq } from \"lodash\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport OverflowScrollContainer from \"../components/OverflowScrollContainer\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { WorksheetName, XLSForm } from \"../xlsform-simple-schema\";\nimport { localizableColumnNames } from \"../xlsform-simple-schema/functions/loadSurveyFromXLSX\";\n\ntype Props = {\n  xlsForm: XLSForm;\n  language: string;\n  debug: boolean;\n  worksheetName: WorksheetName;\n  style?: React.CSSProperties;\n};\n\nconst FlexTable = styled(Table)`\n  flex: 1;\n  width: 33.33333vw;\n`;\n\n/**\n * Displays a single XLSForm worksheet as a table - like in Excel.\n */\nexport default function XLSFormWorksheet(props: Props) {\n  const { language, xlsForm, worksheetName } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { onChangeCell } = context;\n  const worksheet = xlsForm.worksheets[props.worksheetName];\n\n  const numRows = worksheet?.rows.length;\n  const columnNames = React.useMemo(\n    () =>\n      uniq(worksheet?.columnNamesNormalized.map((n) => n.replace(/::.*$/, \"\"))),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [xlsForm, worksheet, worksheet?.columnNamesNormalized, worksheet?.rows]\n  );\n\n  const onConfirmCellEdit = React.useCallback(\n    (\n      value: string,\n      rowIndex?: number | undefined,\n      columnIndex?: number | undefined\n    ) => {\n      if (columnIndex === undefined || rowIndex === undefined) {\n        return;\n      }\n\n      const row = worksheet?.rows[rowIndex];\n      if (!row) {\n        throw new Error(\"Tried to change a row that doesn’t exist\");\n      }\n      const columnName = columnNames[columnIndex];\n      const oldValue = row[columnName];\n      if (oldValue === value) {\n        return;\n      }\n      onChangeCell(\n        worksheetName,\n        rowIndex,\n        columnName,\n        value,\n        xlsForm.flatNodes[rowIndex]\n      );\n    },\n    [\n      columnNames,\n      onChangeCell,\n      worksheet?.rows,\n      worksheetName,\n      xlsForm.flatNodes,\n    ]\n  );\n\n  const cellRenderer = React.useMemo(() => {\n    return (rowIndex: number, columnIndex: number) => {\n      const row = worksheet?.rows[rowIndex];\n      if (!row) {\n        return <></>;\n      }\n      const columnName = columnNames[columnIndex];\n      const value = row[columnName];\n      const node =\n        worksheetName === \"survey\" ? xlsForm.flatNodes[rowIndex] : undefined;\n      const key = [worksheetName, rowIndex, columnName].join(\"-\");\n      if (value !== undefined && typeof value !== \"string\") {\n        if (localizableColumnNames.includes(columnName)) {\n          return (\n            <EditableCell\n              {...{ rowIndex, columnIndex }}\n              onConfirm={onConfirmCellEdit}\n              value={value[language]}\n              key={key}\n            />\n          );\n        } else {\n          return (\n            <EditableCell\n              {...{ rowIndex, columnIndex }}\n              onConfirm={onConfirmCellEdit}\n              value={JSON.stringify(value)}\n              key={key}\n            />\n          );\n        }\n      }\n\n      return (\n        <EditableCell\n          {...{ rowIndex, columnIndex }}\n          onConfirm={onConfirmCellEdit}\n          value={value}\n          key={key}\n          style={\n            [\"type\", \"name\"].includes(columnName)\n              ? { paddingLeft: `${4 + (node?.indentationLevel || 0) * 8}px` }\n              : {}\n          }\n        >\n          {value}\n        </EditableCell>\n      );\n    };\n  }, [\n    worksheet?.rows,\n    columnNames,\n    worksheetName,\n    xlsForm.flatNodes,\n    onConfirmCellEdit,\n    language,\n  ]);\n\n  if (!worksheet) {\n    return (\n      <OverflowScrollContainer style={{ ...props.style }}>\n        <Callout intent=\"warning\">\n          No {props.worksheetName} sheet defined\n        </Callout>\n      </OverflowScrollContainer>\n    );\n  }\n\n  return (\n    <FlexTable\n      numRows={numRows}\n      enableRowResizing={false}\n      // numFrozenColumns={worksheetName === \"survey\" ? 2 : 0}\n    >\n      {columnNames.map((columnName) => (\n        <Column\n          key={columnName}\n          name={columnName}\n          cellRenderer={cellRenderer}\n        />\n      ))}\n    </FlexTable>\n  );\n}\n","import { Tab, Tabs } from \"@blueprintjs/core\";\nimport { CSSProperties, useCallback, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport XLSFormWorksheet from \"./XLSFormWorksheet\";\n\ntype Props = {\n  xlsForm: XLSForm;\n  language: string;\n  debug: boolean;\n  style?: CSSProperties;\n};\n\nconst Container = styled.div`\n  /* background-color: #d5e0e7; */\n  .bp3-tabs {\n    display: flex;\n    flex-direction: column-reverse;\n    flex: 1;\n    overflow: hidden;\n    .bp3-tab-list {\n      padding: 0px 16px 0 16px;\n      .bp3-tab-indicator-wrapper {\n        background: #f6f7f7;\n        @media (prefers-color-scheme: dark) {\n          background: #30404d;\n        }\n        .bp3-tab-indicator {\n          /* bottom: unset; */\n          border-bottom-left-radius: 4px;\n          border-bottom-right-radius: 4px;\n          box-shadow: 0 0 0 1px rgba(16, 22, 26, 0.1),\n            0 2px 4px rgba(16, 22, 26, 0.2), 0 8px 24px rgba(16, 22, 26, 0.2);\n        }\n      }\n      [role=\"tab\"] {\n        padding: 4px 16px 4px;\n        margin-bottom: 8px;\n        border-bottom-left-radius: 4px;\n        border-bottom-right-radius: 4px;\n      }\n    }\n    .bp3-tab-panel {\n      margin: 0;\n      overflow: auto;\n      flex: 1;\n      &[aria-hidden=\"false\"] {\n        box-shadow: 0 0 0 1px rgba(159, 183, 194, 0.1),\n          0 2px 4px rgba(159, 183, 194, 0.2), 0 4px 8px rgba(159, 183, 194, 0.1);\n        @media (prefers-color-scheme: dark) {\n          box-shadow: 0 0 0 1px rgba(12, 20, 24, 0.1),\n            0 2px 4px rgba(12, 20, 24, 0.2), 0 4px 8px rgba(12, 20, 24, 0.1);\n        }\n        display: flex;\n      }\n    }\n  }\n`;\n\n/**\n * Displays a XLSForm workbook as a table - like in Excel.\n */\nexport default function XLSFormWorkbook(props: Props) {\n  const [worksheetName, setWorksheetName] = useState<\n    keyof XLSForm[\"worksheets\"]\n  >(\"survey\");\n  const handleTabChange = useCallback((id: keyof XLSForm[\"worksheets\"]) => {\n    setWorksheetName(id);\n  }, []);\n\n  return (\n    <Container style={props.style}>\n      <Tabs\n        id=\"TabsExample\"\n        onChange={handleTabChange}\n        selectedTabId={worksheetName}\n        renderActiveTabPanelOnly={false}\n      >\n        <Tab\n          id=\"survey\"\n          title=\"Survey\"\n          panel={\n            <XLSFormWorksheet {...{ ...props, worksheetName: \"survey\" }} />\n          }\n        />\n        <Tab\n          id=\"choices\"\n          title=\"Choices\"\n          panel={\n            <XLSFormWorksheet {...{ ...props, worksheetName: \"choices\" }} />\n          }\n        />\n        <Tab\n          id=\"settings\"\n          title=\"Settings\"\n          panel={\n            <XLSFormWorksheet {...{ ...props, worksheetName: \"settings\" }} />\n          }\n        />\n        {/* <Tabs.Expander /> */}\n        {/* <input className=\"bp3-input\" type=\"text\" placeholder=\"Search...\" /> */}\n      </Tabs>\n    </Container>\n  );\n}\n","import { ODKNode } from \"../../types/ODKNode\";\nimport evaluateODKFormula from \"../odk-formulas/evaluation/evaluateODKFormula\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\n\n/**\n * @returns a function that returns `true` if a given node is relevant in a context, or `false` if\n * it’s not.\n */\n\nexport function getNodeOptionalFunction(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n) {\n  return function isNodeIrrelevantOrNotRequired() {\n    const isRelevant =\n      node.row.relevant === undefined ||\n      node.row.relevant === \"\" ||\n      evaluateODKFormula(node.row.relevant, context, node);\n    if (!isRelevant) {\n      return true;\n    }\n    const isRequired =\n      node.row.required === undefined ||\n      node.row.required === \"\" ||\n      evaluateODKFormula(node.row.required, context, node);\n    return !isRequired;\n  };\n}\n","import { ODKFormulaError } from \"../../types/Errors\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport evaluateExpression from \"../odk-formulas/evaluation/evaluateExpression\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { NameExpression, TokenType } from \"../odk-formulas/pratt-parser-base\";\n\n/**\n * Allows to use `${...}` field references inside labels and texts. Each occurence of such a\n * reference is replaced by the value of the referenced field.\n *\n * @example\n * // Assuming there is a text input field called `user_name` with an answer value of 'Jon'...\n * getStringInterpolationFunctionOrString(\n *   'Hello ${user_name}!',\n *   context,\n *   node\n * ) // returns 'Hello Jon!'\n *\n * @returns The given input string, but with each occurrence of a field reference replaced with the value of its referenced field.\n */\nexport function getStringInterpolationFunctionOrString(\n  /** The string in which the field references should be replaced. */\n  inputString: string,\n  /** The evaluation context in which the referenced fields can be found. */\n  context: ODKFormulaEvaluationContext,\n  /** The node to which the string belongs. */\n  node: ODKNode\n) {\n  const hasInterpolation = !!inputString.match(/\\${([^}]+)}/);\n  if (!hasInterpolation) {\n    return inputString;\n  }\n  return function getInterpolatedString(): string {\n    return inputString.replaceAll(\n      /\\${([^}]+)}/g,\n      (match, name, offset): string => {\n        try {\n          const text = match;\n          const result = evaluateExpression(\n            new NameExpression(\n              [{ type: TokenType.NAME, text, index: offset }],\n              name,\n              match\n            ),\n            context,\n            node\n          );\n          return String(result);\n        } catch (e) {\n          if (e instanceof ODKFormulaError) {\n            return e.toMarkdown();\n          }\n          throw e;\n        }\n      }\n    );\n  };\n}\n","import SimpleSchema, { SchemaDefinition } from \"simpl-schema\";\n\n/**\n * @returns a `SimpleSchema` definition that validates a Schema.org `QuantitativeValue` JSON-LD\n * object.\n *\n * Inspired by https://schema.org/QuantitativeValue.\n */\n\nexport const getQuantitativeValueSchema = (\n  key: string,\n  rootDefinition?: SchemaDefinition<unknown>\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition,\n  },\n  [`${key}.maxValue`]: {\n    type: Number,\n    optional: true,\n  },\n  [`${key}.minValue`]: {\n    type: Number,\n    optional: true,\n  },\n  [`${key}.unitCode`]: {\n    type: Text,\n    optional: true,\n  },\n  [`${key}.unitText`]: {\n    type: Text,\n    optional: true,\n  },\n  [`${key}.value`]: {\n    type: SimpleSchema.oneOf(Number, String, Boolean),\n  },\n});\n\nexport interface IQuantitativeValue {\n  maxValue?: number;\n  minValue?: number;\n  unitCode?: string;\n  unitText?: string;\n  value: number | string | boolean;\n}\n","import SimpleSchema, { SchemaDefinition } from \"simpl-schema\";\nimport {\n  getQuantitativeValueSchema,\n  IQuantitativeValue,\n} from \"./getQuantitativeValueSchema\";\n\n/**\n * A Schema.org `MediaObject` JSON-LD object.\n *\n * @see https://schema.org/MediaObject\n */\n\nexport interface IMediaObject {\n  /** The bitrate of the media object. */\n  bitrate?: string;\n  /** File size in (mega/kilo) bytes. */\n  contentSize?: string;\n  /** Actual bytes of the media object, for example the image file or video file. */\n  contentUrl: string;\n  /** The duration of the item (movie, audio recording, event, etc.) in ISO 8601 date format. */\n  duration?: string;\n  /** A URL pointing to a player for a specific video. In general, this is the information in the src element of an embed tag and should not be the same as the content of the loc tag. */\n  embedUrl?: string;\n  /** Media type typically expressed using a MIME format (see IANA site and MDN reference) e.g. application/zip for a SoftwareApplication binary, audio/mpeg for .mp3 etc.). */\n  encodingFormat: string;\n  /** the time offset of the end of a clip within a larger file. */\n  endTime?: Date;\n  /** the time offset of the start of a clip within a larger file. */\n  startTime?: Date;\n  /** Date when this media object was uploaded to this site. */\n  uploadDate?: Date;\n  /** The height of the item. */\n  height?: string | IQuantitativeValue;\n  /** The width of the item. */\n  width?: string | IQuantitativeValue;\n}\n\ntype MediaObject = IMediaObject & {\n  \"@type\": \"MediaObject\";\n};\n\n/**\n * A Schema.org `MediaObject` JSON-LD object, as `SimpleSchema` definition.\n *\n * @see https://schema.org/MediaObject\n */\n\nexport const getMediaObjectSchema = (\n  key: string,\n  rootDefinition?: Partial<SchemaDefinition<unknown>>\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"MediaObject\"],\n    defaultValue: \"MediaObject\",\n  },\n  [`${key}.bitrate`]: {\n    type: String,\n    label: \"The bitrate of the media object.\",\n    optional: true,\n  },\n  [`${key}.contentSize`]: {\n    type: String,\n    label: \"File size in (mega/kilo) bytes.\",\n    optional: true,\n  },\n  [`${key}.contentUrl`]: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Url,\n    label:\n      \"Actual bytes of the media object, for example the image file or video file.\",\n  },\n  [`${key}.duration`]: {\n    type: String,\n    label:\n      \"The duration of the item (movie, audio recording, event, etc.) in ISO 8601 date format.\",\n    optional: true,\n  },\n  [`${key}.embedUrl`]: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Url,\n    label:\n      \"A URL pointing to a player for a specific video. In general, this is the information in the src element of an embed tag and should not be the same as the content of the loc tag.\",\n    optional: true,\n  },\n  [`${key}.encodingFormat`]: {\n    type: String,\n    label:\n      \"Media type typically expressed using a MIME format (see IANA site and MDN reference) e.g. application/zip for a SoftwareApplication binary, audio/mpeg for .mp3 etc.).\",\n  },\n  [`${key}.endTime`]: {\n    type: Date,\n    label: \"the time offset of the end of a clip within a larger file.\",\n    optional: true,\n  },\n  [`${key}.startTime`]: {\n    type: Date,\n    label: \"the time offset of the start of a clip within a larger file.\",\n    optional: true,\n  },\n  [`${key}.uploadDate`]: {\n    type: Date,\n    label: \"Date when this media object was uploaded to this site.\",\n    optional: true,\n  },\n  ...getQuantitativeValueSchema(`${key}.height`, {\n    type: SimpleSchema.oneOf(String, Object),\n    label: \"The height of the item.\",\n    optional: true,\n  }),\n  ...getQuantitativeValueSchema(`${key}.width`, {\n    type: SimpleSchema.oneOf(String, Object),\n    label: \"The width of the item.\",\n    optional: true,\n  }),\n});\n\n/**\n * A Schema.org `AudioObject` JSON-LD object.\n *\n * @see https://schema.org/AudioObject\n */\nexport type AudioObject = IMediaObject & {\n  \"@type\": \"AudioObject\";\n  transcript?: string;\n  caption?: string | MediaObject;\n};\n\n/**\n * A Schema.org `AudioObject` JSON-LD object, as `SimpleSchema` definition.\n *\n * @see https://schema.org/AudioObject\n */\nexport const getAudioObjectSchema = (\n  key: string,\n  rootDefinition?: Partial<SchemaDefinition<unknown>>\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"AudioObject\"],\n    defaultValue: \"AudioObject\",\n  },\n  ...getMediaObjectSchema(key),\n  [`${key}.transcript`]: {\n    type: String,\n    optional: true,\n  },\n  ...getMediaObjectSchema(`${key}.caption`, {\n    type: SimpleSchema.oneOf(String, Object),\n    label:\n      \"The caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.\",\n    optional: true,\n  }),\n});\n\n/**\n * A Schema.org `ImageObject` JSON-LD object.\n *\n * @see https://schema.org/ImageObject\n */\nexport type ImageObject = IMediaObject & {\n  \"@type\": \"ImageObject\";\n  exifData?: Record<string, unknown>;\n  representativeOfPage?: boolean;\n  caption?: string | MediaObject;\n  thumbnail?: string | ImageObject;\n};\n\n/**\n * A Schema.org `ImageObject` JSON-LD object, as `SimpleSchema` definition.\n *\n * @see https://schema.org/ImageObject\n */\nexport const getImageObjectSchema = (\n  key: string,\n  withThumbnail = true,\n  rootDefinition?: Partial<SchemaDefinition<unknown>>\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"ImageObject\"],\n    defaultValue: \"ImageObject\",\n  },\n  ...getMediaObjectSchema(key),\n  [`${key}.exifData`]: {\n    type: Object,\n    label: \"EXIF data for this object.\",\n    blackbox: true,\n    optional: true,\n  },\n  [`${key}.representativeOfPage`]: {\n    type: Boolean,\n    label:\n      \"Indicates whether this image is representative of the content of the page.\",\n    optional: true,\n  },\n  ...getMediaObjectSchema(`${key}.caption`, {\n    label:\n      \"The caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.\",\n    optional: true,\n  }),\n  ...(withThumbnail\n    ? getImageObjectSchema(`${key}.thumbnail`, false, {\n        label: \"Thumbnail image for an image or video.\",\n        optional: true,\n      })\n    : {}),\n});\n\n/**\n * A Schema.org `VideoObject` JSON-LD object.\n *\n * @see https://schema.org/VideoObject\n */\nexport type VideoObject = IMediaObject & {\n  \"@type\": \"VideoObject\";\n  exifData?: Record<string, unknown>;\n  representativeOfPage?: boolean;\n  caption?: string | MediaObject;\n  transcript?: string;\n  videoFrameSize?: string;\n  videoQuality?: string;\n  thumbnail?: string | ImageObject;\n};\n\n/**\n * A Schema.org `VideoObject` JSON-LD object, as `SimpleSchema` definition.\n *\n * @see https://schema.org/VideoObject\n */\nexport const getVideoObjectSchema = (\n  key: string,\n  rootDefinition?: Partial<SchemaDefinition<unknown>>\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition,\n  },\n  [`${key}.@type`]: {\n    type: String,\n    allowedValues: [\"VideoObject\"],\n  },\n  ...getMediaObjectSchema(key),\n  [`${key}.caption`]: {\n    type: getMediaObjectSchema(`${key}.caption`),\n    label:\n      \" or Text\tThe caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.\",\n    optional: true,\n  },\n  [`${key}.transcript`]: {\n    type: String,\n    label:\n      \"If this MediaObject is an AudioObject or VideoObject, the transcript of that object.\",\n    optional: true,\n  },\n  [`${key}.videoFrameSize`]: {\n    type: String,\n    label: \"The frame size of the video.\",\n    optional: true,\n  },\n  [`${key}.videoQuality`]: {\n    type: String,\n    optional: true,\n  },\n  ...getImageObjectSchema(`${key}.thumbnail`, true, {\n    label: \"Thumbnail image for an image or video.\",\n    optional: true,\n  }),\n});\n","import SimpleSchema from \"simpl-schema\";\nimport { NodeToDefinitionFunction } from \"./createLeafNodeSchemaDefinition\";\nimport {\n  getSchemaOrgLineStringGeometrySchema,\n  getSchemaOrgPointGeometrySchema,\n  getSchemaOrgPolygonGeometrySchema,\n} from \"./geometry/SchemaOrgGeometry\";\nimport getAllowedChoiceValues from \"./getAllowedChoiceValues\";\nimport {\n  getAudioObjectSchema,\n  getImageObjectSchema,\n  getMediaObjectSchema,\n  getVideoObjectSchema,\n} from \"./MediaSchemas\";\n\n/**\n * Map of survey question types to functions that generate a `SimpleSchema` definition.\n */\nexport const questionTypesToSchemaGenerators: Record<\n  string,\n  NodeToDefinitionFunction<unknown> | undefined\n> = {\n  \"\": () => ({}),\n  integer: (o) => ({ [o.key]: { type: SimpleSchema.Integer } }),\n  decimal: (o) => ({ [o.key]: { type: Number } }),\n  range: (o) => ({ [o.key]: { type: Number } }),\n  text: (o) => ({ [o.key]: { type: String } }),\n  select_one: (o) => ({\n    [o.key]: { type: String, allowedValues: getAllowedChoiceValues(o) },\n  }),\n  select_multiple: (o) => ({\n    [o.key]: { type: Array },\n    [o.key + \".$\"]: { type: String, allowedValues: getAllowedChoiceValues(o) },\n  }),\n  select_one_from_file: (o) => ({ [o.key]: { type: String } }),\n  select_multiple_from_file: (o) => ({\n    [o.key]: { type: Array },\n    [o.key + \".$\"]: { type: String },\n  }),\n  rank: (o) => ({ [o.key]: { type: String } }),\n  note: (o) => ({ [o.key]: { type: String } }),\n  geopoint: (o) => getSchemaOrgPointGeometrySchema(o.key),\n  geotrace: (o) => getSchemaOrgLineStringGeometrySchema(o.key),\n  geoshape: (o) => getSchemaOrgPolygonGeometrySchema(o.key),\n  date: (o) => ({ [o.key]: { type: Date } }),\n  time: (o) => ({ [o.key]: { type: Date } }),\n  datetime: (o) => ({ [o.key]: { type: Date } }),\n  image: (o) => getImageObjectSchema(o.key),\n  audio: (o) => getAudioObjectSchema(o.key),\n  video: (o) => getVideoObjectSchema(o.key),\n  file: (o) => getMediaObjectSchema(o.key),\n  barcode: (o) => ({ [o.key]: { type: String } }),\n  calculate: (o) => ({ [o.key]: { type: String } }),\n  acknowledge: (o) => ({ [o.key]: { type: Boolean } }),\n  hidden: (o) => ({ [o.key]: { type: String } }),\n  \"xml-external\": (o) => ({ [o.key]: { type: String } }),\n  start: (o) => ({ [o.key]: { type: Date } }),\n  end: (o) => ({ [o.key]: { type: Date } }),\n  today: (o) => ({ [o.key]: { type: Date } }),\n  deviceid: (o) => ({ [o.key]: { type: String } }),\n  simserial: (o) => ({ [o.key]: { type: String } }),\n  subscriberid: (o) => ({ [o.key]: { type: String } }),\n  phonenumber: (o) => ({ [o.key]: { type: String } }),\n  username: (o) => ({ [o.key]: { type: String } }),\n  email: (o) => ({\n    [o.key]: { type: String, regEx: SimpleSchema.RegEx.EmailWithTLD },\n  }),\n  audit: (o) => ({ [o.key]: { type: String } }),\n};\n","import { SchemaDefinition } from \"simpl-schema\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport createLeafNodeSchemaDefinition from \"./createLeafNodeSchemaDefinition\";\nimport { getNodeOptionalFunction } from \"./getNodeOptionalFunction\";\nimport { getStringInterpolationFunctionOrString } from \"./getStringInterpolationFunctionOrString\";\n\n/**\n * @returns a `SimpleSchema` definition of a nested tree of `ODKNode`s that you can use to validate\n * survey results at runtime.\n */\nexport default function createRecursiveNodeSchemaDefinition(options: {\n  node: ODKNode;\n  language: string;\n  xlsForm: XLSForm;\n  context: ODKFormulaEvaluationContext;\n  key: string;\n}): Record<string, SchemaDefinition<unknown>> {\n  const { node, language, xlsForm, context, key } = options;\n  let schemaDefinitions: Record<string, SchemaDefinition<unknown>>;\n  const labelString = node.row.label?.[language] || \"\";\n  const definition: Pick<SchemaDefinition<unknown>, \"label\" | \"optional\"> = {\n    label: getStringInterpolationFunctionOrString(labelString, context, node),\n    optional: getNodeOptionalFunction(node, context),\n  };\n  if (node.row?.type.match(/^begin_repeat$/)) {\n    // We're in a repeated section\n    const childrenSchemaDefinitions = node.children.map((child) =>\n      createRecursiveNodeSchemaDefinition({\n        ...options,\n        node: child,\n        key: key + \".$.\" + child.row.name,\n      })\n    );\n    schemaDefinitions = Object.assign(\n      { [key]: { ...definition, type: Array } },\n      ...childrenSchemaDefinitions\n    );\n  } else if (\n    node.row.type.match(/^begin_group$/) ||\n    node === xlsForm.rootSurveyGroup\n  ) {\n    // We're in a group section or in the root (a special case that has children, but is not of `begin_group` type)\n    const childrenSchemaDefinitions = node.children.map((child) => {\n      if (!child.row) {\n        debugger;\n      }\n      return createRecursiveNodeSchemaDefinition({\n        ...options,\n        node: child,\n        key: key + \".\" + child.row.name,\n      });\n    });\n\n    schemaDefinitions = Object.assign(\n      { [key]: { ...definition, type: Object } },\n      ...childrenSchemaDefinitions\n    );\n  } else {\n    schemaDefinitions = createLeafNodeSchemaDefinition(\n      node,\n      language,\n      xlsForm,\n      context,\n      key\n    );\n  }\n\n  // console.log(`Schema for key \\`${key}\\`:`, schemaDefinitions);\n  return schemaDefinitions;\n}\n","import { SchemaDefinition } from \"simpl-schema\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeOptionalFunction } from \"./getNodeOptionalFunction\";\nimport { getStringInterpolationFunctionOrString } from \"./getStringInterpolationFunctionOrString\";\nimport { questionTypesToSchemaGenerators } from \"./questionTypesToSchemaGenerators\";\n\nexport type NodeToDefinitionFunctionOptions = {\n  key: string;\n  node: ODKNode;\n  xlsForm: XLSForm;\n  context: ODKFormulaEvaluationContext;\n};\n\nexport type NodeToDefinitionFunction<T> = (\n  options: NodeToDefinitionFunctionOptions\n) => Record<string, SchemaDefinition<T>>;\n\n/**\n * @returns a `SimpleSchema` definition of a field node. Use this to validate a survey result at\n * runtime.\n */\nexport default function createLeafNodeSchemaDefinition(\n  node: ODKNode,\n  language: string,\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext,\n  key: string\n): Record<string, SchemaDefinition<unknown>> {\n  const { row } = node;\n\n  if (!row) {\n    throw new Error(\"Node needs an associated row for creating a schema.\");\n  }\n\n  const labelString = row.label?.[language] || \"\";\n  const defaults = {\n    type: String,\n    label: getStringInterpolationFunctionOrString(labelString, context, node),\n    optional: getNodeOptionalFunction(node, context),\n  };\n\n  const schemaGeneratorFunction = questionTypesToSchemaGenerators[node.type];\n  if (!schemaGeneratorFunction) {\n    throw new Error(\n      `Could not find schema generator for node type ${JSON.stringify(row)}`\n    );\n  }\n\n  const schema = schemaGeneratorFunction({ key, node, xlsForm, context });\n  const firstField = schema[Object.keys(schema)[0]];\n  Object.assign(firstField, defaults, { ...firstField });\n\n  return schema;\n}\n","import {\n  Alignment,\n  Colors,\n  FocusStyleManager,\n  HotkeysProvider,\n  HotkeysTarget2,\n  Navbar,\n} from \"@blueprintjs/core\";\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport \"./App.css\";\nimport ResultCodeTree from \"./code/ResultCodeTree\";\nimport { AppEmptyState } from \"./components/AppEmptyState\";\nimport DarkModeContainer, { useDarkMode } from \"./components/DarkModeContainer\";\nimport { EditMenuButton } from \"./components/EditMenuButton\";\nimport { FileMenuButton } from \"./components/FileMenuButton\";\nimport LanguageSelector from \"./components/LanguageSelector\";\nimport OverflowScrollContainer from \"./components/OverflowScrollContainer\";\nimport useViewOptionsButton from \"./components/useViewOptionsButton\";\nimport { alpha } from \"./lib/colors\";\nimport { ODKSurveyContext } from \"./lib/ODKSurveyContext\";\nimport { UndoContext } from \"./lib/undo/UndoContext\";\nimport useUndoHistory from \"./lib/undo/useUndoHistory\";\nimport useChangeHooks from \"./lib/useChangeHooks\";\nimport { useGlobalHotkeys } from \"./lib/useGlobalHotkeys\";\nimport EditableSurveyTitle from \"./survey/fields/EditableSurveyTitle\";\nimport { ODKNodeDragAndDropContext } from \"./survey/useNodeDragAndDrop\";\nimport XLSFormSurvey from \"./survey/XLSFormSurvey\";\nimport XLSFormWorkbook from \"./table/XLSFormWorkbook\";\nimport { createSurveySchemaFromXLSForm } from \"./xlsform-simple-schema/functions/schema-creation/createSurveySchemaFromXLSForm\";\nimport { XLSForm } from \"./xlsform-simple-schema/index\";\n\nFocusStyleManager.onlyShowFocusOnTabs();\n\nconst StyledXLSFormSurvey = styled(XLSFormSurvey)`\n  max-width: 800px;\n  margin: auto;\n\n  font-size: 20px;\n  .bp3-small {\n    font-size: 16px;\n  }\n\n  .bp3-large {\n    font-size: 20px;\n  }\n\n  .bp3-form-helper-text {\n    font-size: 16px;\n  }\n\n  .bp3-form-group {\n    margin: 0 0 40px;\n  }\n\n  .bp3-control {\n    margin-bottom: 10px;\n  }\n`;\n\nconst AppBody = styled.div`\n  flex: 1;\n  overflow: hidden;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\n\nfunction App() {\n  const [language, setLanguage] = React.useState<string>(\"English (en)\");\n  const undoContext = useUndoHistory<XLSForm>();\n  const xlsForm = undoContext.document;\n\n  const resultCodeElement = xlsForm && (\n    <OverflowScrollContainer\n      className={\"bp3-code-block\"}\n      style={{ padding: \"1rem\", margin: \"0\", whiteSpace: \"pre\" }}\n    >\n      <ResultCodeTree {...{ xlsForm }} />\n    </OverflowScrollContainer>\n  );\n\n  const { viewMenuButton, viewOptions } = useViewOptionsButton();\n  const isDarkMode = useDarkMode();\n\n  const setXLSFormWithPatches = undoContext.setDocumentWithPatches;\n\n  const changeHooks = useChangeHooks({\n    language,\n    xlsForm,\n    setXLSFormWithPatches,\n    debug: viewOptions.debug,\n  });\n\n  const { evaluationContext: context } = changeHooks;\n  const [, languageName, languageCode] =\n    language?.match(/^(.*) \\((\\w+)\\)$/) || [];\n\n  const schema = React.useMemo(() => {\n    if (xlsForm && language && context) {\n      return createSurveySchemaFromXLSForm(xlsForm, context, language);\n    }\n    return undefined;\n  }, [xlsForm, language, context]);\n\n  const hotkeys = useGlobalHotkeys(undoContext);\n\n  return (\n    <HotkeysProvider>\n      <HotkeysTarget2 hotkeys={hotkeys}>\n        {({ handleKeyDown, handleKeyUp }) => (\n          <DarkModeContainer\n            style={{ height: \"100%\", display: \"flex\", flexDirection: \"column\" }}\n            onKeyDown={handleKeyDown}\n            onKeyUp={handleKeyUp}\n          >\n            <UndoContext.Provider value={undoContext}>\n              <ODKNodeDragAndDropContext.Provider\n                value={{ onDropNode: changeHooks.onMoveNode }}\n              >\n                <ODKSurveyContext.Provider\n                  value={{\n                    schema,\n                    language,\n                    languageCode,\n                    languageName,\n                    debug: viewOptions.debug,\n                    xlsForm,\n                    ...changeHooks,\n                  }}\n                >\n                  {xlsForm && (\n                    <Navbar>\n                      <Navbar.Group>\n                        <FileMenuButton\n                          {...{ setXLSFormWithPatches, setLanguage, xlsForm }}\n                        />\n                        <EditMenuButton />\n                      </Navbar.Group>\n                      <Navbar.Group>\n                        <Navbar.Divider />\n                        <EditableSurveyTitle />\n                      </Navbar.Group>\n                      <Navbar.Group align={Alignment.RIGHT}>\n                        {viewMenuButton}\n                        <Navbar.Divider />\n                        {xlsForm && language && (\n                          <LanguageSelector\n                            languages={Array.from(xlsForm.languages.values())}\n                            language={language}\n                            onChange={setLanguage}\n                          />\n                        )}\n                      </Navbar.Group>\n                    </Navbar>\n                  )}\n\n                  <AppBody>\n                    {!xlsForm && (\n                      <OverflowScrollContainer>\n                        <AppEmptyState\n                          {...{ setXLSFormWithPatches, setLanguage }}\n                        />\n                      </OverflowScrollContainer>\n                    )}\n                    {xlsForm && language && viewOptions.table && (\n                      <XLSFormWorkbook\n                        xlsForm={xlsForm}\n                        language={language}\n                        debug={viewOptions.debug}\n                        style={{ flex: 1, display: \"flex\" }}\n                      />\n                    )}\n                    {xlsForm && language && (\n                      <OverflowScrollContainer\n                        style={{\n                          boxShadow: isDarkMode\n                            ? `0 0px 2px ${alpha(\n                                Colors.DARK_GRAY5,\n                                0.8\n                              )}, 0 0px 20px ${alpha(Colors.DARK_GRAY1, 0.3)}`\n                            : `0 0px 10px ${alpha(Colors.DARK_GRAY5, 0.3)}`,\n                          zIndex: 1,\n                        }}\n                      >\n                        <StyledXLSFormSurvey\n                          xlsForm={xlsForm}\n                          language={language}\n                          debug={viewOptions.debug}\n                        />\n                      </OverflowScrollContainer>\n                    )}\n                    {xlsForm &&\n                      language &&\n                      viewOptions.json &&\n                      resultCodeElement}\n                  </AppBody>\n                </ODKSurveyContext.Provider>\n              </ODKNodeDragAndDropContext.Provider>\n            </UndoContext.Provider>\n          </DarkModeContainer>\n        )}\n      </HotkeysTarget2>\n    </HotkeysProvider>\n  );\n}\n\nexport default App;\n","import { Patch } from \"immer/dist/internal\";\nimport * as React from \"react\";\nimport { UndoContextType } from \"./createUndoHistoryContext\";\nimport { UndoHistory, UndoHistoryItem } from \"./types\";\nexport type { Patch } from \"immer/dist/internal\";\n\nexport default function useUndoHistory<T>(): UndoContextType<T> {\n  const [undoHistory, setUndoHistory] = React.useState<UndoHistory<T>>({\n    commands: [],\n    index: -1,\n  });\n\n  const setDocumentWithPatches = React.useCallback(\n    (\n      description: string,\n      nextState: T | undefined,\n      patches: Patch[],\n      inversePatches: Patch[]\n    ) => {\n      const newCommand: UndoHistoryItem<T> = {\n        description,\n        document: nextState,\n        patches,\n        inversePatches,\n      };\n      setUndoHistory((undoHistory) => {\n        const { commands, index } = undoHistory;\n        return {\n          commands: [...commands.slice(0, index + 1), newCommand],\n          index: index + 1,\n        };\n      });\n    },\n    []\n  );\n\n  const undo = React.useCallback(\n    () =>\n      setUndoHistory((undoHistory) => ({\n        ...undoHistory,\n        index: Math.max(undoHistory.index - 1, 0),\n      })),\n    []\n  );\n\n  const redo = React.useCallback(\n    () =>\n      setUndoHistory((undoHistory) => ({\n        ...undoHistory,\n        index: Math.min(undoHistory.index + 1, undoHistory.commands.length - 1),\n      })),\n    []\n  );\n\n  const document = React.useMemo(\n    () => undoHistory.commands[undoHistory.index]?.document,\n    [undoHistory.commands, undoHistory.index]\n  );\n\n  const gotoIndex = React.useCallback(\n    (index: number) =>\n      setUndoHistory((undoHistory) => ({\n        ...undoHistory,\n        index,\n      })),\n    []\n  );\n\n  return {\n    setDocumentWithPatches,\n    undoHistory,\n    undo,\n    redo,\n    gotoIndex,\n    document,\n  };\n}\n","import SimpleSchema from \"simpl-schema\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport createRecursiveNodeSchemaDefinition from \"./createRecursiveNodeSchemaDefinition\";\n\n/**\n * @returns a `SimpleSchema` definition for a whole XLSFormthat you can use to validate\n * survey results at runtime.\n */\nexport function createSurveySchemaFromXLSForm(\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext,\n  language: string\n): SimpleSchema {\n  const schemaDefinition = createRecursiveNodeSchemaDefinition({\n    node: xlsForm.rootSurveyGroup,\n    xlsForm,\n    context,\n    language,\n    key: xlsForm.rootSurveyGroup.row.name,\n  });\n\n  const schema = new SimpleSchema(\n    new SimpleSchema(schemaDefinition).mergedSchema()\n  );\n\n  return schema;\n}\n","import React from \"react\";\nimport { XLSForm } from \"../xlsform-simple-schema/index\";\nimport { UndoContextType } from \"./undo/createUndoHistoryContext\";\n\nexport function useGlobalHotkeys(undoContext: UndoContextType<XLSForm>) {\n  return React.useMemo(\n    () => [\n      {\n        combo: \"mod+z\",\n        global: true,\n        label: \"Undo\",\n        onKeyDown: undoContext.undo,\n        allowInInput: false,\n        preventDefault: true,\n      },\n      {\n        global: true,\n        combo: \"mod+shift+z\",\n        label: \"Redo\",\n        onKeyDown: undoContext.redo,\n        allowInInput: false,\n        preventDefault: true,\n      },\n    ],\n    [undoContext.redo, undoContext.undo]\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { enableAllPlugins, enablePatches } from \"immer\";\n\nenableAllPlugins();\nenablePatches();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}