{"version":3,"sources":["xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext.ts","lib/ODKSurveyContext.ts","lib/colors.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/XPath.ts","xlsform-simple-schema/types/Errors.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/types.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaLexer.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/InfixParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PrefixParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/Parser.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/NameExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/OperatorExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/BinaryOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/CallExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/CallParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/ConditionalExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/ConditionalParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/GroupParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/NameParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/PostfixExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PostfixOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/PrefixExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/PrefixOperatorParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/index.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaPrecedence.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/LiteralExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/LiteralParselet.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/SelectorExpression.ts","xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/parselets/SelectorParselet.ts","xlsform-simple-schema/functions/odk-formulas/odk-formula-parser/ODKFormulaParser.ts","xlsform-simple-schema/types/RowSchemas.ts","xlsform-simple-schema/types/RowTypes.ts","xlsform-simple-schema/functions/nestSurvey.ts","xlsform-simple-schema/types/XLSForm.ts","xlsform-simple-schema/functions/loadSurveyFromXLSX.ts","lib/createLabelInAllLanguages.tsx","xlsform-simple-schema/types/ODKNode.ts","lib/findOrReplaceFieldReferences.ts","lib/getFirstColumnNameWithError.tsx","lib/ODKNodeContext.ts","lib/typesToIcons.tsx","toaster.ts","lib/useNodeDeletionDialog.tsx","survey/DetailsPopover/NodeReferencesMenu.tsx","lib/useRenameNodeDialog.tsx","survey/useNodeDragAndDrop.tsx","components/expression/HighlightedExpression.tsx","components/unindent.ts","components/Markdown.tsx","components/StyledMarkdown.tsx","survey/DetailsPopover/DefaultValueExplanation.tsx","survey/DetailsPopover/FormulaResultMeaning.tsx","survey/DetailsPopover/ExpressionPanel.tsx","survey/DetailsPopover/ChoiceListMenu.tsx","survey/DetailsPopover/FieldTypeMenu.tsx","survey/DetailsPopover/FieldConfigurationButton.tsx","survey/DetailsPopover/NoChoicesState.tsx","survey/DetailsPopover/FieldPathBreadcrumbs.tsx","survey/AddFieldMenuItem.tsx","survey/DetailsPopover/NodeActionMenuItems.tsx","survey/DetailsPopover/DetailsPopover.tsx","code/ResultCodeTree.tsx","components/ExcelFileInput.tsx","components/LanguageSelector.tsx","components/OverflowScrollContainer.tsx","xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaFunctions.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateExpression.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateODKFormula.ts","xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeColumn.ts","xlsform-simple-schema/functions/evaluateNodeAndChildren.ts","lib/createUntitledFieldRow.tsx","lib/createUntitledGroupRows.tsx","lib/getLastRowIndexOfNode.ts","lib/useChangeHooks.tsx","xlsform-simple-schema/functions/patchXLSFormCell.ts","SheetTabs.tsx","components/PaddedContainer.tsx","survey/fields/ObjectArrayField.tsx","survey/fields/ObjectField.tsx","survey/internalFields.ts","survey/fields/BooleanField.tsx","survey/fields/CheckboxGroupField.tsx","survey/fields/DateField.tsx","survey/fields/Label.tsx","survey/fields/NumberField.tsx","survey/fields/RadioGroupField.tsx","survey/fields/TextField.tsx","survey/fields/ValueField.tsx","survey/FieldSetForKey.tsx","table/XLSFormWorksheet.tsx","xlsform-simple-schema/functions/schema-creation/getNodeOptionalFunction.ts","xlsform-simple-schema/functions/schema-creation/getStringInterpolationFunctionOrString.ts","xlsform-simple-schema/functions/schema-creation/Geometry.ts","xlsform-simple-schema/functions/schema-creation/getQuantitativeValueSchema.ts","xlsform-simple-schema/functions/schema-creation/MediaSchemas.ts","xlsform-simple-schema/functions/schema-creation/getAllowedChoiceValues.ts","xlsform-simple-schema/functions/schema-creation/evaluateDynamicChoiceListName.ts","xlsform-simple-schema/functions/schema-creation/evaluateFilteredChoiceNames.ts","xlsform-simple-schema/functions/schema-creation/questionTypesToSchemaGenerators.ts","xlsform-simple-schema/functions/schema-creation/createRecursiveNodeSchemaDefinition.ts","xlsform-simple-schema/functions/schema-creation/createLeafNodeSchemaDefinition.ts","App.tsx","survey/XLSFormSurvey.tsx","xlsform-simple-schema/functions/schema-creation/createSurveySchemaFromXLSForm.ts","reportWebVitals.ts","index.tsx"],"names":["knownLiteralsWithoutDollarSign","yes","no","TRUE","FALSE","true","false","getEmptyContext","survey","type","typeParameters","row","name","label","children","indentationLevel","rowIndex","nodesToAnswers","Map","evaluationResults","stackDepth","ODKSurveyContext","React","schema","SimpleSchema","context","language","languageCode","languageName","debug","xlsForm","undefined","setContext","onChangeAnswer","onChangeCell","onMoveNode","onSpliceRows","onRemoveRowAndChildren","onRenameNode","onNestNode","onUngroupNode","onAddNode","alpha","color","value","alphaColor","rgb","opacity","toString","findNodeByNameInsideScope","scope","length","i","childScope","foundChild","findNodeByNameInCurrentAndAncestorScopes","child","stack","getAncestors","parentScope","findNodeByPathRelativeToScope","pathComponents","result","pathComponent","Error","slice","getReverseNodeAbsolutePath","node","getNodeAbsolutePath","reverse","getNodeAbsolutePathString","delimiter","join","getScopedNodeIndexPath","isEqual","push","childNode","foundStack","pop","getNodeIndexPath","getScopedAncestors","TokenType","ODKFormulaError","token","this","message","EvaluationError","expression","underlyingEvaluationError","nodeStack","ancestors","ParseError","tokens","LexerError","SyntaxError","SemanticError","FunctionNotImplementedError","functionName","LEFT_PAREN","RIGHT_PAREN","COMMA","ASSIGN","PLUS","MINUS","ASTERISK","GREATER_THAN","LESS_THAN","BOOLEAN_AND","BOOLEAN_OR","SLASH","CARET","TILDE","BANG","MODULO","COMPARISON","BACKSLASH","QUESTION","COLON","SINGLE_QUOTE","DOUBLE_QUOTE","NAME","LITERAL","NUMBER_LITERAL","INT_LITERAL","FLOAT_LITERAL","STRING_LITERAL","BOOLEAN_LITERAL","WHITESPACE","UNKNOWN","EOF","INVALID","punctuator","tokenType","Expression","kind","tokenPatterns","SELECTOR","ODKFormulaLexer","text","index","tokenPattern","regex","match","substr","errorToken","INTERNAL_LEXER_ERROR","InfixParselet","PrefixParselet","Parser","options","readTokens","prefixParselets","infixParselets","parselet","set","precedence","consumeAnything","prefix","get","left","parse","getPrecedence","infix","onExpression","expected","lookAhead","shift","distance","nextToken","next","onToken","parser","NameExpression","builder","OperatorExpression","operatorToken","right","print","BinaryOperatorParselet","isRight","parseExpression","CallExpression","fn","leftParenToken","argsAndDelimiters","rightParenToken","args","filter","e","CallParselet","rightParenTokenType","argumentDelimiterTokenType","delimiterToken","arg","consume","ConditionalExpression","condition","questionMarkToken","thenArm","colonToken","elseArm","ConditionalParselet","GroupParselet","NameParselet","getName","t","_parser","PostfixExpression","PostfixOperatorParselet","PrefixExpression","PrefixOperatorParselet","PrattParser","ODKFormulaPrecedence","BOOLEAN_OP","CONDITIONAL","ASSIGNMENT","SUM","PRODUCT","EXPONENT","PREFIX","POSTFIX","CALL","LiteralExpression","String","LiteralParselet","getValue","getType","SelectorExpression","selectorToken","selector","SelectorParselet","getSelector","ODKFormulaParser","expressions","register","startsWith","split","parseFloat","parseInt","Precedence","infixRight","infixLeft","getStringMapSchemaDefinition","schemaDefinition","Object","blackbox","custom","keys","getLocalizedStringSchemaDefinition","optionalLocalizedString","optional","optionalStringMap","formulaValidationFunction","lexer","addValidationErrors","key","questionRowSchema","includes","field","error","ErrorTypes","REQUIRED","operator","isSet","constraint","constraint_message","image","video","hint","guidance_hint","required_message","relevant","choice_filter","calculation","trigger","readonly","required","parameters","repeat_count","appearance","default","instance","bind","body","choiceRowSchema","settingsRowSchema","form_title","form_id","public_key","submission_url","default_language","version","assertValidQuestionRow","validate","assertNoEndMarker","loadChoices","worksheet","map","rows","forEach","listName","list","loadXLSFormFromRows","defaultLanguage","settings","choices","flatNodes","worksheets","rootSurveyGroup","formRootNameFromSettings","titleFromSettings","onRow","root","normalizeType","currentGroup","newGroupNode","newChildNode","nestSurvey","choicesByName","languages","nestDoubleColonFields","namespacePrefixes","defaultSuffix","foundSuffixes","Set","k","add","namespacePrefix","suffix","objectToExtend","replace","autoCleanOptions","getAutoValues","trimStrings","mutate","loadQuestionRow","cleanRow","clean","loadChoicesRow","assertValidChoiceRow","loadSettingsRow","assertValidSettingsRow","localizableColumnNames","loadWorksheet","workbook","sheetName","loadRowFn","excelWorksheet","getWorksheet","firstRow","getRows","values","Array","columnNames","cellValue","columnNamesNormalized","headerRow","columnName","freeze","normalizeColumnNames","columnNamesToTrues","findLanguagesInColumnNames","eachRow","rowRawData","columnIndex","rowDataWithNamespacedFields","JSON","stringify","details","loadExcelRow","loadFormFromExcelWorkbook","a","createLabelInAllLanguages","lang","evaluatableColumnNames","isNodeRelevant","isRelevantEvaluationResult","isGroupNode","findOrReplaceFieldReferences","replaceName","oldName","dependentNodes","variableRegexp","RegExp","n","found","localizableKeys","flatMap","lcn","without","concat","cn","newCellValue","replaceAll","cloneDeep","getFirstColumnNameWithError","nodeEvaluationResults","find","ODKNodeContext","typesToIcons","integer","decimal","range","select_one","select_one_from_file","select_multiple","select_multiple_from_file","rank","note","geopoint","geotrace","geoshape","date","time","datetime","audio","file","barcode","calculate","acknowledge","hidden","start","end","today","deviceid","simserial","subscriberid","phonenumber","username","email","audit","begin_group","begin_repeat","fieldTypeNames","fieldCategoriesToIcons","literal","choice","geo","media","stats","track","special","grouping","fieldCategoryNames","fieldTypesToCategories","AppToaster","Toaster","create","className","position","Position","TOP","useNodeDeletionDialog","useContext","useState","isAlertOpen","setAlertOpen","setNode","isGroup","closeAlert","useCallback","removeNode","show","intent","showRemoveConfirmationDialog","alert","cancelButtonText","confirmButtonText","icon","Intent","DANGER","isOpen","onCancel","onConfirm","canOutsideClickCancel","canEscapeKeyCancel","NodeReferencesMenu","props","references","reference","href","useRenameNodeDialog","isDialogOpen","setDialogOpen","newName","setNewName","setChangedRows","useEffect","changeName","event","currentTarget","closeDialog","renameNode","preventDefault","showRenameDialog","dependenciesInfo","content","lazy","minimal","dialog","title","canOutsideClickClose","canEscapeKeyClose","isCloseButtonShown","onClose","onSubmit","Classes","DIALOG_BODY","labelFor","style","display","id","placeholder","defaultValue","large","onChange","pattern","DIALOG_FOOTER","DIALOG_FOOTER_ACTIONS","onClick","PRIMARY","disabled","ODKNodeDragAndDropContext","onDropNode","assertIsODKNode","every","p","resultIsInvalid","StyledCode","styled","code","Colors","RED2","GREEN3","BLUE3","ORANGE3","ORANGE4","GRAY1","BLUE2","RED5","TokenElement","parentExpression","target","referencedNode","data-referenced-node","DetailsPopover","editable","nameOfOnlyShownTab","InvalidExpression","lastToken","indexAfterLastToken","TEXT_DISABLED","HighlightedExpression","isErroneousExpression","expressionOrToken","unindent","input","firstLineWithContent","line","matchedIndentation","matchedIndentationString","indentationRegExp","MarkdownDiv","omit","dangerouslySetInnerHTML","__html","marked","Markdown","StyledMarkdown","DARK_GRAY1","DefaultValueExplanation","answer","nodeName","TEXT_MUTED","FormulaResultMeaning","results","ExpressionPanel","cellIsEmpty","isLiteral","isName","formulaIsTrivial","StyledPanel","backgroundColor","LIGHT_GRAY5","marginTop","padding","background","borderTop","LIGHT_GRAY3","StyledCodeBlock","fontSize","lineHeight","state","StyledCalloutWithCode","toMarkdown","ChoiceListMenu","choiceListsByName","choiceListNames","checked","choiceListName","newTypeValue","newRow","numberOfRowsToRemove","rowsToAdd","margin","vertical","isSelected","nameElement","choiceNamesToRows","choiceNames","sortedChoiceRows","sortBy","r","toLowerCase","shownChoices","marginInline","restElement","UI_TEXT","marginLeft","paddingRight","aria-label","shownLabel","fill","LIST_UNSTYLED","justifyContent","FieldTypeMenu","dataset","c","category","data-type","FieldConfigurationButton","showType","surveyHasChoiceLists","choiceListMenu","noChoicesAvailable","addExampleChoices","choiceRows","addExampleChoicesButton","action","description","NoChoicesState","typeName","hasItems","alignSelf","observeParents","minVisibleItems","collapseFrom","Boundary","END","items","visibleItemRenderer","overflowRenderer","overflowItems","transition","maxWidth","FieldPathBreadcrumbs","path","width","overflowListProps","AddFieldOrGroupMenuItem","group","omitAction","caption","NodeActionMenuItems","onRemove","onRename","onNestField","onUngroupField","nestField","ungroupField","renameText","Code","div","Callout","DragStripe","RenderTarget","detailsButtonCaption","hasTypeIcon","isRelevant","hasMissingParameters","hasError","isDraggedOver","setIsDraggedOver","dragProps","onDragStart","dataTransfer","setData","sourceNode","sourcePath","onDragOver","getData","onDrop","data","console","log","destinationNode","draggable","onDragLeave","useNodeDragAndDrop","flex","overflow","small","rightIcon","Boolean","firstColumnNameWithError","firstColumnNameWithContent","setWidth","handleResize","entries","setTimeout","newWidth","contentRect","Math","abs","tabId","setTabId","renameDialog","referencesButton","referencesButtonTitle","ReferencesButton","editHeader","marginBottom","borderBottom","gap","FLEX_EXPANDER","detailsContent","onResize","selectedTabId","renderActiveTabPanelOnly","panel","getTab","Provider","interactionKind","popoverClassName","PopoverClasses","POPOVER2_CONTENT_SIZING","placement","rootBoundary","onOpening","modifiers","arrow","enabled","preventOverflow","targetTagName","SecondaryLabel","keysWithErrors","valueString","htmlTitle","getNodeTree","transform","childNodes","nodeData","ResultCodeTree","evaluationContext","isExpanded","hasCaret","secondaryLabel","contents","ExcelFileInput","onFileChange","files","wb","ExcelJS","reader","FileReader","readAsArrayBuffer","onload","buffer","ArrayBuffer","xlsx","load","then","onLoadWorkbook","onInputChange","LanguageSelect","Select","ofType","renderItem","handleClick","shouldDismissPopover","LanguageSelector","onItemSelect","itemRenderer","activeItem","noResults","filterable","OverflowScrollContainer","assertString","argNo","number","ordinalize","assertNumber","assertBoolean","functions","if","elseExpression","not","coalesce","arg2","boolean","_xpath","once","_expression","selected","space_delimited_array","string","_space_delimited_array","_n","_multi_select_question","_choice_name","_select_question","_name","_group","_i","_sub_grp","_sub_i","_sub_sub_grp","_sub_sub_i","count","_nodeset","sum","max","min","contains","substring","endsWith","_string","_target","translate","_fromchars","_tochars","trim","_separator","round","places","int","floor","Number","NaN","digest","_data","_algorithm","_encodingMethod","pow","exponent","log10","sin","cos","tan","asin","acos","atan","atan2","y","x","sqrt","exp","exp10","pi","PI","now","Date","setHours","toISOString","_dateTime","_days","_time","_date","_format","area","_nodesetOrGeoshape","_nodesetOrGeoshapeOrGeotrace","random","randomize","_seed","uuid","_length","checklist","_min","_max","_response","evaluateExpression","deeperContext","evaluateLiteralExpression","evaluateNameExpression","evaluateNodeColumn","evaluateSelectorExpression","leftBeforeCasting","rightBeforeCasting","evaluateOperatorExpression","nameExpressionOrString","stringFromStringOrExpression","evaluatedArgs","apply","s","evaluateCallExpression","str","valueBeforeCasting","allowUndefinedNames","literalBag","nodeOrNodes","evaluationResult","evaluateNonDollarNameFn","assertExpressionAfterEvaluation","evaluateODKFormula","formula","fallback","originalFormula","fallbackValue","evaluateNodeAndChildren","onEval","fallbacks","getEvaluatedXLSFormResult","columnNamesToResults","untitledFieldIndex","untitledGroupIndex","createEmptyGroupRows","beginMarkerRow","endMarkerRow","getLastRowIndexOfNode","findIndex","useChangeHooks","setXLSForm","newContext","fieldProps","clear","schemaKey","worksheetName","indexPath","valuePathInRow","changeIsInSurveyWorksheet","produce","draft","flat","patchXLSFormCell","operations","surveyWorksheet","newRows","splice","newWorksheet","firstIndex","lastIndex","createEmptyFieldRow","rowsToInsert","after","before","inside","numberOfSourceNodeRows","rowsOfSourceNode","destinationIsBeforeSource","insertOperation","removeOperation","SheetTabs","setWorksheetName","Group","align","Alignment","LEFT","active","PaddedContainer","horizontal","ObjectArrayField","ObjectField","subKeys","objectKeys","onChangeSurveyName","onChangeLabel","labelInput","minWidth","multiline","HeadingClass","H1","H2","H3","H4","H5","hintString","alignItems","subkey","FieldSetForKey","internalFields","BooleanField","labelElement","defaultChecked","CheckboxGroupField","valueIsInvalid","element","newChoices","delete","from","choiceList","choiceRow","definedLabel","has","inline","jsDateFormatter","formatDate","toLocaleDateString","parseDate","DateField","selectedDate","isUserChange","Label","isEditable","evaluatedLabel","editedLabel","setEditedLabel","onConfirmLabel","minLines","maxLines","NumberField","valueAsNumber","allowNumericCharactersOnly","onValueChange","RadioGroupField","allowedValues","selectedValue","TextField","AutoField","quickType","ValueField","isBoolean","checkbox","valueAsDate","radio","isInternalField","detailsButton","autoFieldProps","Stripe","CornerButton","TopCornerButton","BottomCornerButton","Hoverable","getQuickTypeForKey","schemaKeyPath","nodeActionMenuItems","nodeActionMenu","renderTarget","ref","targetProps","hoverOpenDelay","hoverCloseDelay","FlexTable","Table","XLSFormWorksheet","numRows","uniq","onConfirmCellEdit","cellRenderer","paddingLeft","enableRowResizing","getNodeOptionalFunction","getStringInterpolationFunctionOrString","inputString","offset","getQuantitativeValueSchema","rootDefinition","Text","oneOf","getMediaObjectSchema","regEx","RegEx","Url","getImageObjectSchema","withThumbnail","getAllowedChoiceValues","choiceListStrings","availableListNames","compact","choiceListString","evaluateDynamicChoiceListName","choiceObjects","o","choiceFilterString","choiceFilterExpression","choiceObject","evalResult","evaluateFilteredChoiceNames","questionTypesToSchemaGenerators","Integer","minCount","maxCount","getPointGeometrySchema","getLineStringGeometrySchema","getPolygonGeometrySchema","getAudioObjectSchema","getVideoObjectSchema","EmailWithTLD","createRecursiveNodeSchemaDefinition","schemaDefinitions","definition","childrenSchemaDefinitions","assign","labelString","defaults","schemaGeneratorFunction","firstField","createLeafNodeSchemaDefinition","FocusStyleManager","onlyShowFocusOnTabs","StyledXLSFormSurvey","fieldSets","AppBody","NavbarSwitch","App","setLanguage","setDebug","showTable","setShowTable","showResult","setShowResult","onDebugChange","onShowTableChange","onShowResultChange","fileInput","reset","resetButton","resultCodeElement","whiteSpace","changeHooks","useMemo","mergedSchema","createSurveySchemaFromXLSForm","RIGHT","Divider","boxShadow","zIndex","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","enableAllPlugins","enablePatches","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d25c9fab.chunk.js","sourcesContent":["import {\n  EvaluatableColumnName,\n  NodesToValues,\n  ODKNode,\n} from \"../../../types/ODKNode\";\nimport { NameExpression } from \"../pratt-parser-base\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\n/**\n * Contains global information that can be used in a single formula evaluation. The evaluation\n * process needs this to find values of other nodes, for example, when a formulas uses a relative\n * XPath selector to refer to a NodeSet.\n */\n\ntype ODKFormulaEvaluationContext = {\n  /** The survey in which the evaluation takes place */\n  survey: ODKNode;\n  nodesToAnswers: NodesToValues;\n  evaluationResults: NodesToValues<\n    Map<EvaluatableColumnName, ODKFormulaEvaluationResult>\n  >;\n  /** The current stack depth. Used to to prevent stack overflows in recursive calculations. */\n  stackDepth: number;\n  knownLiteralsWithoutDollarSign: Record<string, unknown>;\n  evaluateNonDollarNameFn?: (options: {\n    expression: NameExpression;\n    context: ODKFormulaEvaluationContext;\n    scope: ODKNode;\n  }) => unknown;\n};\n\nexport default ODKFormulaEvaluationContext;\n\n/** These are literals that appeared (and apparently were supported) in our Kobo forms, and are documented in XLSForms. */\nexport const knownLiteralsWithoutDollarSign: Record<string, unknown> = {\n  yes: true,\n  no: false,\n  TRUE: true,\n  FALSE: false,\n  true: true,\n  false: false,\n};\n\nexport const getEmptyContext: (\n  survey?: ODKNode\n) => ODKFormulaEvaluationContext = (survey?: ODKNode) => ({\n  survey: survey || {\n    type: \"\",\n    typeParameters: [],\n    row: {\n      type: \"\",\n      name: \"data\",\n      label: { \"English (en)\": \"[empty survey]\" },\n    },\n    children: [],\n    indentationLevel: 0,\n    rowIndex: -1,\n  },\n  nodesToAnswers: new Map(),\n  evaluationResults: new Map(),\n  stackDepth: 0,\n  knownLiteralsWithoutDollarSign,\n});\n","import * as React from \"react\";\nimport SimpleSchema from \"simpl-schema\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport ODKFormulaEvaluationContext, {\n  getEmptyContext,\n} from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport useChangeHooks from \"./useChangeHooks\";\n\nexport interface IODKSurveyContext {\n  schema?: SimpleSchema;\n  context?: ODKFormulaEvaluationContext;\n  language?: string;\n  languageName?: string;\n  languageCode?: string;\n  debug: boolean;\n  xlsForm?: XLSForm;\n}\n\nexport const ODKSurveyContext = React.createContext<\n  IODKSurveyContext & ReturnType<typeof useChangeHooks>\n>({\n  schema: new SimpleSchema({}),\n  context: getEmptyContext(),\n  language: \"English (en)\",\n  languageCode: \"en\",\n  languageName: \"English\",\n  debug: true,\n  xlsForm: undefined,\n  setContext: () => {},\n  onChangeAnswer: () => {},\n  onChangeCell: () => {},\n  onMoveNode: () => {},\n  onSpliceRows: () => {},\n  onRemoveRowAndChildren: () => {},\n  onRenameNode: () => {},\n  onNestNode: () => {},\n  onUngroupNode: () => {},\n  onAddNode: () => {},\n});\n","import { hsl, rgb } from \"d3-color\";\nimport { interpolateHsl, interpolateLab } from \"d3-interpolate\";\n\nexport function coloredWhite(color: string, value: number = 0.5) {\n  const labColor = hsl(color);\n  return interpolateHsl(labColor, \"white\")(value).toString();\n}\n\nexport function brighter(color: string, value: number = 0.3) {\n  return hsl(color).brighter(value).toString();\n}\n\nexport function darker(color: string, value: number = 0.3) {\n  return hsl(color).darker(value).toString();\n}\n\nexport function alpha(color: string, value: number = 0.4) {\n  const alphaColor = rgb(color);\n  alphaColor.opacity *= value;\n  return alphaColor.toString();\n}\n\nexport function mixLab(color1: string, color2: string, ratio: number = 0.5) {\n  return interpolateLab(color1, color2)(ratio).toString();\n}\n","import { isEqual } from \"lodash\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\n\n/**\n * Recursively searches for a node by its name, starting from the given scope. Includes children of\n * the current scope in search.\n *\n * @param name the name of the node to select\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByNameInsideScope(\n  name: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKNode | ODKNode[] | undefined {\n  if (scope.row?.name === name) {\n    return scope;\n  } else if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childScope = scope.children[i];\n      if (childScope.row?.name === name) {\n        return childScope;\n      }\n      const foundChild = findNodeByNameInsideScope(name, context, childScope);\n      if (foundChild) {\n        return foundChild;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Recursively searches for a node by its name, starting from the given scope and moving upwards in\n * the hierarchy. Includes ancestors of the current scope in search, until it reaches the root\n * scope.\n *\n * @param name the name of the node to select\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByNameInCurrentAndAncestorScopes(\n  name: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): ODKNode | ODKNode[] | undefined {\n  if (scope.row?.name === name) {\n    return scope;\n  } else if (scope.children) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const child = scope.children[i];\n      if (child.row?.name === name) {\n        return child;\n      }\n    }\n  }\n  const stack = getAncestors(scope, context);\n  const parentScope = stack?.[stack.length - 1];\n  if (!parentScope) {\n    return undefined;\n  }\n  return (\n    findNodeByNameInCurrentAndAncestorScopes(name, context, parentScope) ||\n    undefined\n  );\n}\n\n/**\n * Returns a node that matches the given absolute path, or its relative path as seen from the given\n * scope. Works a bit like a file structure.\n *\n * @param pathComponents Path of the node to select. Array of strings, e.g. `['..', '..', 'name']`.\n * @param context global survey context to search in\n * @param scope current scope to limit the search. Skip this argument to search in the survey's root\n *   node.\n */\nexport function findNodeByPathRelativeToScope(\n  pathComponents: string[],\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKNode | ODKNode[] | undefined {\n  const pathComponent = pathComponents[0];\n  // console.log('Searching', pathComponent, 'in scope', scope.row?.name, 'stack', scope.stack);\n  let result: ODKNode | undefined;\n\n  if (pathComponent === \".\") {\n    result = scope;\n  } else if (pathComponent === \"/\") {\n    result = context.survey;\n  } else if (pathComponent === \"..\") {\n    if (scope === context.survey) {\n      throw new Error(\n        \"Reached root - Can’t traverse further up the hierarchy.\"\n      );\n    }\n    const stack = getAncestors(scope, context);\n    result = stack?.[stack.length - 1];\n  } else if (pathComponent === scope.row.name) {\n    result = scope;\n  } else if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childScope = scope.children[i];\n      if (childScope.row.name === pathComponent) {\n        result = childScope;\n        break;\n      }\n    }\n  }\n\n  if (pathComponents.length === 1) {\n    return result;\n  }\n\n  return findNodeByPathRelativeToScope(\n    pathComponents.slice(1),\n    context,\n    result\n  );\n}\n\nfunction getReverseNodeAbsolutePath(\n  node: ODKNode | undefined,\n  context: ODKFormulaEvaluationContext\n): string[] {\n  if (!node) {\n    return [\"/\"];\n  }\n\n  if (!node?.row?.name) {\n    throw new Error(\n      `Encountered a row without a name (row #${node.rowIndex}). This should not happen. Please ensure the survey data is valid.`\n    );\n  }\n\n  const stack = getAncestors(node, context);\n  return [\n    node.row?.name,\n    ...getReverseNodeAbsolutePath(stack?.[stack.length - 1], context),\n  ];\n}\n\nexport function getNodeAbsolutePath(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n): string[] {\n  return getReverseNodeAbsolutePath(node, context)?.reverse();\n}\n\nexport function getNodeAbsolutePathString(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  delimiter: string = \".\"\n): string {\n  return getNodeAbsolutePath(node, context).slice(1).join(delimiter);\n}\n\nexport function isXPath(string: string): boolean {\n  return !!string.match(/^\\/(\\/?[\\w*]+(?:\\[[^]+?])?)$/);\n}\n\nexport function getScopedNodeIndexPath(\n  node: ODKNode,\n  scope: ODKNode,\n  stack: number[] = []\n): number[] | undefined {\n  if (isEqual(node, scope)) {\n    return stack;\n  }\n  if (scope.children?.length) {\n    for (let i = 0; i < scope.children.length; i += 1) {\n      stack.push(i);\n      const childNode = scope.children[i];\n      const foundStack = getScopedNodeIndexPath(node, childNode, stack);\n      if (foundStack !== undefined) {\n        return foundStack;\n      }\n      stack.pop();\n    }\n  }\n  return undefined;\n}\n\nexport function getNodeIndexPath(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n): number[] | undefined {\n  return getScopedNodeIndexPath(node, context.survey);\n}\n\nexport function getScopedAncestors(\n  node: ODKNode,\n  scope: ODKNode,\n  stack: ODKNode[] = []\n): ODKNode[] | undefined {\n  if (isEqual(node, scope)) {\n    return stack;\n  }\n  if (scope.children?.length) {\n    stack.push(scope);\n    for (let i = 0; i < scope.children.length; i += 1) {\n      const childNode = scope.children[i];\n      const foundStack = getScopedAncestors(node, childNode, stack);\n      if (foundStack) {\n        return foundStack;\n      }\n    }\n    stack.pop();\n  }\n}\n\nexport function getAncestors(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n) {\n  return getScopedAncestors(node, context.survey);\n}\n","import ODKFormulaEvaluationContext from \"../functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getScopedAncestors } from \"../functions/odk-formulas/evaluation/XPath\";\nimport { Expression, Token } from \"../functions/odk-formulas/pratt-parser-base\";\nimport { ODKNode } from \"./ODKNode\";\n\nexport abstract class ODKFormulaError extends Error {\n  token?: Token;\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\nexport class EvaluationError extends ODKFormulaError {\n  nodeStack: readonly Readonly<ODKNode>[];\n\n  constructor(\n    message: string,\n    readonly type: string,\n    readonly expression: Expression | undefined,\n    readonly context: ODKFormulaEvaluationContext,\n    readonly scope: ODKNode,\n    readonly underlyingEvaluationError: EvaluationError | undefined = undefined\n  ) {\n    super(message);\n\n    const ancestors = getScopedAncestors(scope, context.survey);\n\n    this.nodeStack = [...(ancestors || []), scope];\n  }\n\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\nexport class ParseError extends ODKFormulaError {\n  constructor(\n    readonly type: string,\n    message: string,\n    readonly tokens?: Token[]\n  ) {\n    super(message);\n  }\n\n  toMarkdown(): string {\n    return this.message;\n  }\n}\n\nexport class LexerError extends ODKFormulaError {\n  constructor(readonly token: Token, readonly message: string) {\n    super(message);\n  }\n}\n\nexport class SyntaxError extends ODKFormulaError {}\n\nexport class SemanticError extends ODKFormulaError {}\n\nexport class FunctionNotImplementedError extends ODKFormulaError {\n  constructor(functionName: string) {\n    super(\n      `The \\`${functionName}\\` function is not supported yet. If you need it, please contact the developers.`\n    );\n  }\n}\n\nexport class UnsupportedFeatureError extends ODKFormulaError {\n  constructor(feature: string) {\n    super(`${feature} is not supported.`);\n  }\n}\n","export enum TokenType {\n  LEFT_PAREN,\n  RIGHT_PAREN,\n  COMMA,\n  ASSIGN,\n  PLUS,\n  MINUS,\n  ASTERISK,\n  DOLLAR,\n  LEFT_BRACE,\n  RIGHT_BRACE,\n  GREATER_THAN,\n  LESS_THAN,\n  SLASH,\n  POINT,\n  CARET,\n  TILDE,\n  BANG,\n  BACKSLASH,\n  QUESTION,\n  COLON,\n  SINGLE_QUOTE,\n  DOUBLE_QUOTE,\n  MODULO,\n  BOOLEAN_AND,\n  BOOLEAN_OR,\n  COMPARISON,\n  NAME,\n  LITERAL,\n  NUMBER_LITERAL,\n  FLOAT_LITERAL,\n  INT_LITERAL,\n  STRING_LITERAL,\n  BOOLEAN_LITERAL,\n  SELECTOR,\n  WHITESPACE,\n  UNKNOWN,\n  EOF,\n  INVALID,\n  INTERNAL_LEXER_ERROR,\n}\n\nexport const tokenTypes = [\n  TokenType.LEFT_PAREN,\n  TokenType.RIGHT_PAREN,\n  TokenType.COMMA,\n  TokenType.ASSIGN,\n  TokenType.PLUS,\n  TokenType.MINUS,\n  TokenType.ASTERISK,\n  TokenType.GREATER_THAN,\n  TokenType.LESS_THAN,\n  TokenType.BOOLEAN_AND,\n  TokenType.BOOLEAN_OR,\n  TokenType.SLASH,\n  TokenType.CARET,\n  TokenType.TILDE,\n  TokenType.BANG,\n  TokenType.MODULO,\n  TokenType.COMPARISON,\n  TokenType.BACKSLASH,\n  TokenType.QUESTION,\n  TokenType.COLON,\n  TokenType.SINGLE_QUOTE,\n  TokenType.DOUBLE_QUOTE,\n  TokenType.NAME,\n  TokenType.LITERAL,\n  TokenType.NUMBER_LITERAL,\n  TokenType.INT_LITERAL,\n  TokenType.FLOAT_LITERAL,\n  TokenType.STRING_LITERAL,\n  TokenType.BOOLEAN_LITERAL,\n  TokenType.WHITESPACE,\n  TokenType.UNKNOWN,\n  TokenType.EOF,\n  TokenType.INVALID,\n];\n\n/**\n * If the TokenType represents a punctuator (i.e. a token that can split an\n * identifier like '+', this will get its text.\n */\nexport function punctuator(tokenType: TokenType): string {\n  switch (tokenType) {\n    case TokenType.LEFT_PAREN:\n      return \"(\";\n    case TokenType.RIGHT_PAREN:\n      return \")\";\n    case TokenType.COMMA:\n      return \",\";\n    case TokenType.ASSIGN:\n      return \"=\";\n    case TokenType.PLUS:\n      return \"+\";\n    case TokenType.MINUS:\n      return \"-\";\n    case TokenType.ASTERISK:\n      return \"*\";\n    case TokenType.SLASH:\n      return \"/\";\n    case TokenType.CARET:\n      return \"^\";\n    case TokenType.TILDE:\n      return \"~\";\n    case TokenType.BANG:\n      return \"!\";\n    case TokenType.BACKSLASH:\n      return \"\\\\\";\n    case TokenType.QUESTION:\n      return \"?\";\n    case TokenType.COLON:\n      return \":\";\n    default:\n      return \"[undefined punctuator]\";\n  }\n}\n\n/**\n * A simple token class. These are generated by Lexer and consumed by Parser.\n */\nexport type Token = {\n  type: TokenType;\n  text: string;\n  index: number;\n};\n\n/**\n * Interface for all expression AST node classes.\n */\nexport abstract class Expression {\n  abstract readonly kind: string;\n  abstract tokens: Token[];\n  abstract children: (Token | Expression)[];\n  /**\n   * Pretty-print the expression to a string.\n   */\n  abstract print(builder: StringBuilder): void;\n}\n\nexport type StringBuilder = (result: string) => void;\n","import { LexerError } from \"../../../types/Errors\";\nimport { Token, TokenType } from \"../pratt-parser-base/types\";\n\nexport const xPathPrefixRegExp = /^\\/(\\/?[\\w*]+(?:\\[[^]+?]\\B)?)/;\n\nconst tokenPatterns: [TokenType, RegExp][] = [\n  [TokenType.STRING_LITERAL, /^'(\\\\\\\\|\\\\'|[^'])*'/],\n  [TokenType.STRING_LITERAL, /^\"(\\\\\\\\|\\\\\"|[^\"])*\"/],\n  [TokenType.SLASH, /^div/],\n  [TokenType.MODULO, /^mod/],\n  [TokenType.BOOLEAN_AND, /^and/],\n  [TokenType.BOOLEAN_OR, /^or/],\n  [TokenType.FLOAT_LITERAL, /^-?\\d+\\.\\d+/],\n  [TokenType.INT_LITERAL, /^-?\\d+/],\n  [TokenType.NAME, /^\\$?{[^}]+}/],\n  [TokenType.NAME, /^[a-zA-Z_\\w_][a-zA-Z_\\w_-]*/],\n  [TokenType.SELECTOR, xPathPrefixRegExp], // Match XPaths\n  [TokenType.LEFT_PAREN, /^\\(/],\n  [TokenType.RIGHT_PAREN, /^\\)/],\n  [TokenType.COMMA, /^,/],\n  [TokenType.PLUS, /^\\+/],\n  [TokenType.MINUS, /^-/],\n  [TokenType.ASTERISK, /^\\*/],\n  [TokenType.COMPARISON, /^(>=|>|<=|<|=|!=)/],\n  [TokenType.COMPARISON, /^(>=|>|<=|<|=|!=)/],\n  [TokenType.INVALID, /^(\\w+|[\\s\\S])/],\n];\n\nexport default class ODKFormulaLexer implements Iterator<Token> {\n  index = 0;\n  constructor(readonly text: string) {}\n  next(): { value: Token } {\n    if (this.index >= this.text.length) {\n      // Once we've reached the end of the string, just return EOF tokens. We'll\n      // just keeping returning them as many times as we're asked so that the\n      // parser's lookahead doesn't have to worry about running out of tokens.\n      return { value: { type: TokenType.EOF, text: \"\", index: this.index } };\n    }\n\n    // Consume and ignore whitespace\n    while (this.text[this.index] === \" \") {\n      this.index += 1;\n    }\n\n    for (let i = 0; i < tokenPatterns.length; i += 1) {\n      const tokenPattern = tokenPatterns[i];\n      const [type, regex] = tokenPattern;\n      const result = this.text.slice(this.index).match(regex);\n      if (result === null) {\n        continue;\n      }\n      const text = result[0];\n      const token: Token = {\n        type,\n        text: this.text.substr(this.index, text.length),\n        index: this.index,\n      };\n      this.index += text.length;\n      return { value: token };\n    }\n\n    const errorToken: Token = {\n      type: TokenType.INTERNAL_LEXER_ERROR,\n      text: this.text[this.index],\n      index: this.index,\n    };\n    throw new LexerError(\n      errorToken,\n      \"Lexer should never get here. If we get here, this means there is no invalid token defined at the end of the pattern list. This invalid token should match at least one character that is not recognized by all other patterns.\"\n    );\n  }\n}\n","import Parser from '../Parser';\nimport { Expression, Token } from '../types';\n\n/**\n * One of the two parselet interfaces used by the Pratt parser. An\n * InfixParselet is associated with a token that appears in the middle of the\n * expression it parses. Its parse() method will be called after the left-hand\n * side has been parsed, and it in turn is responsible for parsing everything\n * that comes after the token. This is also used for postfix expressions, in\n * which case it simply doesn't consume any more tokens in its parse() call.\n */\nexport default abstract class InfixParselet {\n  abstract parse(parser: Parser, left: Expression, token: Token): Expression;\n  abstract getPrecedence(): number;\n}\n","import Parser from '../Parser';\nimport { Expression, Token } from '../types';\n\n/**\n * One of the two interfaces used by the Pratt parser. A PrefixParselet is\n * associated with a token that appears at the beginning of an expression. Its\n * parse() method will be called with the consumed leading token, and the\n * parselet is responsible for parsing anything that comes after that token.\n * This interface is also used for single-token expressions like variables, in\n * which case parse() simply doesn't consume any more tokens.\n * @author rnystrom\n *\n */\nexport default abstract class PrefixParselet {\n  abstract parse(parser: Parser, token: Token): Expression;\n}\n","import { ParseError } from \"../../../types/Errors\";\nimport InfixParselet from \"./parselets/InfixParselet\";\nimport PrefixParselet from \"./parselets/PrefixParselet\";\nimport { Expression, Token, TokenType } from \"./types\";\n\nexport type TokenCallback = (expression: Token) => void;\nexport type ExpressionCallback = (expression: Expression) => void;\nexport interface ITokenizer {\n  next: () => { value: Token };\n}\nexport type ParserOptions = {\n  tokens: ITokenizer;\n  onToken?: TokenCallback;\n  onExpression?: ExpressionCallback;\n};\n\nexport default class Parser {\n  private readTokens: Token[] = [];\n  private prefixParselets: Map<TokenType, PrefixParselet> = new Map();\n  private infixParselets: Map<TokenType, InfixParselet> = new Map();\n\n  constructor(readonly options: ParserOptions) {}\n\n  public register(\n    token: TokenType,\n    parselet: PrefixParselet | InfixParselet\n  ): void {\n    if (parselet instanceof PrefixParselet) {\n      this.prefixParselets.set(token, parselet);\n    } else if (parselet instanceof InfixParselet) {\n      this.infixParselets.set(token, parselet);\n    } else {\n      throw new Error(\n        `Found a parselet that was neither an infix nor a prefix parselet: No idea what to do with it…`\n      );\n    }\n  }\n\n  public parseExpression(precedence = 0): Expression {\n    const token = this.consumeAnything();\n    if (!token) {\n      throw new ParseError(\n        \"prematureEOF\",\n        \"Parser encountered end of tokens. This should not happen.\"\n      );\n    }\n    const prefix = this.prefixParselets.get(token.type);\n    if (!prefix)\n      throw new ParseError(\n        \"undefinedPrefix\",\n        `Expected start of a new expression, but \\`${token.text}\\` is not an allowed prefix.`,\n        [token]\n      );\n\n    let left: Expression = prefix.parse(this, token);\n\n    while (precedence < this.getPrecedence()) {\n      const token = this.consumeAnything();\n      if (!token) {\n        throw new ParseError(\n          \"prematureEndOfTokens\",\n          \"Parser encountered end of tokens. This should not happen.\"\n        );\n      }\n      const infix = this.infixParselets.get(token.type);\n      if (!infix)\n        throw new ParseError(\n          \"undefinedInfix\",\n          `\\`${token.text}\\` is not an allowed infix.`,\n          [token]\n        );\n      left = infix.parse(this, left, token);\n    }\n\n    this.options.onExpression?.(left);\n    return left;\n  }\n\n  public match(expected: TokenType): Token | undefined {\n    const token = this.lookAhead(0);\n    if (token.type !== expected) {\n      return undefined;\n    }\n\n    return this.consumeAnything();\n  }\n\n  public consume(expected: TokenType): Token {\n    const token = this.lookAhead(0);\n    if (token.type !== expected) {\n      throw new Error(\n        \"Expected token \" + expected + \" and found \" + token.type\n      );\n    }\n\n    const consumedToken = this.consumeAnything();\n    if (!consumedToken) {\n      throw new Error(\"Could not consume token \" + expected);\n    }\n    return token;\n  }\n\n  public consumeAnything(): Token | undefined {\n    // Make sure we've read the token.\n    this.lookAhead(0);\n\n    return this.readTokens.shift();\n  }\n\n  private lookAhead(distance: number): Token {\n    // Read in as many as needed.\n    while (distance >= this.readTokens.length) {\n      const nextToken = this.options.tokens.next();\n      if (nextToken.value) this.options.onToken?.(nextToken.value);\n      this.readTokens.push(nextToken.value);\n    }\n\n    // Get the queued token.\n    return this.readTokens[distance];\n  }\n\n  private getPrecedence(): number {\n    const parser = this.infixParselets.get(this.lookAhead(0).type);\n    if (parser) return parser.getPrecedence();\n    return 0;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A simple variable name expression like \"abc\".\n */\nexport default class NameExpression extends Expression {\n  kind = \"name\";\n  children = this.tokens;\n\n  constructor(\n    readonly tokens: Token[],\n    readonly name: string,\n    readonly text: string\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(this.name);\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A binary arithmetic expression like \"a + b\" or \"c ^ d\".\n */\nexport default class OperatorExpression extends Expression {\n  kind = \"operator\";\n  children = [this.left, this.operatorToken, this.right];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly left: Expression,\n    readonly operatorToken: Token,\n    readonly right: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.left.print(builder);\n    builder(\" \");\n    builder(this.operatorToken.text);\n    builder(\" \");\n    this.right.print(builder);\n    builder(\")\");\n  }\n}\n","import OperatorExpression from \"../expressions/OperatorExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Generic infix parselet for a binary arithmetic operator. The only\n * difference when parsing, \"+\", \"-\", \"*\", \"/\", and \"^\" is precedence and\n * associativity, so we can use a single parselet class for all of those.\n */\nexport default class BinaryOperatorParselet extends InfixParselet {\n  constructor(readonly precedence: number, readonly isRight: boolean) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    operatorToken: Token\n  ): Expression {\n    // To handle right-associative operators like \"^\", we allow a slightly\n    // lower precedence when parsing the right-hand side. This will let a\n    // parselet with the same precedence appear on the right, which will then\n    // take *this* parselet's result as its left-hand argument.\n    const right = parser.parseExpression(\n      this.precedence - (this.isRight ? 1 : 0)\n    );\n\n    return new OperatorExpression(\n      [...left.tokens, operatorToken, ...right.tokens],\n      left,\n      operatorToken,\n      right\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A function call like \"a(b, c, d)\".\n */\nexport default class CallExpression extends Expression {\n  kind = \"call\";\n  readonly args: Expression[];\n  children = [\n    this.fn,\n    this.leftParenToken,\n    ...this.argsAndDelimiters,\n    this.rightParenToken,\n  ];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly fn: Expression,\n    readonly leftParenToken: Token,\n    readonly argsAndDelimiters: (Expression | Token)[],\n    readonly rightParenToken: Token\n  ) {\n    super();\n    this.args = argsAndDelimiters.filter(\n      (e) => e instanceof Expression\n    ) as Expression[];\n  }\n\n  public print(builder: StringBuilder): void {\n    this.fn.print(builder);\n    builder(\"(\");\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i].print(builder);\n      if (i < this.args.length - 1) builder(\", \");\n    }\n    builder(\")\");\n  }\n}\n","import CallExpression from \"../expressions/CallExpression\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\nimport Parser from \"../Parser\";\n\n/**\n * Parselet to parse a function call like \"a(b, c, d)\".\n */\nexport default class CallParselet extends InfixParselet {\n  constructor(\n    readonly rightParenTokenType: TokenType,\n    readonly argumentDelimiterTokenType: TokenType,\n    readonly precedence: number\n  ) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    leftParenToken: Token\n  ): Expression {\n    // Parse the token-separated arguments until we hit the token that marks the argument list end.\n    const args: Expression[] = [];\n    let rightParenToken: Token | undefined = parser.match(\n      this.rightParenTokenType\n    );\n    const tokens: Token[] = [...left.tokens, leftParenToken];\n    const argsAndDelimiters: (Expression | Token)[] = [];\n    if (rightParenToken) {\n      // There may be no arguments at all.\n      tokens.push(rightParenToken);\n    } else {\n      let delimiterToken;\n      do {\n        const arg = parser.parseExpression();\n        args.push(arg);\n        tokens.push(...arg.tokens);\n        argsAndDelimiters.push(arg);\n        delimiterToken = parser.match(this.argumentDelimiterTokenType);\n        if (delimiterToken) {\n          tokens.push(delimiterToken);\n          argsAndDelimiters.push(delimiterToken);\n        }\n      } while (delimiterToken);\n      rightParenToken = parser.consume(this.rightParenTokenType);\n      if (rightParenToken) {\n        tokens.push(rightParenToken);\n      }\n    }\n\n    return new CallExpression(\n      tokens,\n      left,\n      leftParenToken,\n      argsAndDelimiters,\n      rightParenToken\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A ternary conditional expression like \"a ? b : c\".\n */\nexport default class ConditionalExpression extends Expression {\n  kind = \"conditional\";\n  children = [\n    this.condition,\n    this.questionMarkToken,\n    this.thenArm,\n    this.colonToken,\n    this.elseArm,\n  ];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly condition: Expression,\n    readonly questionMarkToken: Token,\n    readonly thenArm: Expression,\n    readonly colonToken: Token,\n    readonly elseArm: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.condition.print(builder);\n    builder(\" ? \");\n    this.thenArm.print(builder);\n    builder(\" : \");\n    this.elseArm.print(builder);\n    builder(\")\");\n  }\n}\n","import ConditionalExpression from \"../expressions/ConditionalExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Parselet for the condition or \"ternary\" operator, like \"a ? b : c\".\n */\nexport default class ConditionalParselet extends InfixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(\n    parser: Parser,\n    left: Expression,\n    questionMarkToken: Token\n  ): Expression {\n    const thenArm = parser.parseExpression();\n    const colonToken = parser.consume(TokenType.COLON);\n    const elseArm = parser.parseExpression(this.precedence - 1);\n    return new ConditionalExpression(\n      [\n        ...left.tokens,\n        questionMarkToken,\n        ...thenArm.tokens,\n        colonToken,\n        ...elseArm.tokens,\n      ],\n      left,\n      questionMarkToken,\n      thenArm,\n      colonToken,\n      elseArm\n    );\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import Parser from \"../Parser\";\nimport { Expression, Token, TokenType } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Parses parentheses used to group an expression, like \"a * (b + c)\".\n */\nexport default class GroupParselet extends PrefixParselet {\n  constructor(readonly rightParenTokenType: TokenType) {\n    super();\n  }\n\n  public parse(parser: Parser, leftParenToken: Token): Expression {\n    const expression = parser.parseExpression();\n    const rightParenToken = parser.consume(this.rightParenTokenType);\n    expression.tokens = [leftParenToken, ...expression.tokens, rightParenToken];\n    expression.children = [leftParenToken, expression, rightParenToken];\n    return expression;\n  }\n}\n","import NameExpression from \"../expressions/NameExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a named variable like \"abc\".\n */\nexport default class NameParselet extends PrefixParselet {\n  constructor(readonly getName: (text: string) => string = (t) => t) {\n    super();\n  }\n  public parse(_parser: Parser, token: Token): Expression {\n    const name = this.getName(token.text);\n    return new NameExpression([token], name, token.text);\n  }\n}\n","import { Expression, punctuator, StringBuilder, Token } from \"../types\";\n\n/**\n * A postfix unary arithmetic expression like \"a!\".\n */\nexport default class PostfixExpression extends Expression {\n  kind = \"postfix\";\n  children = [this.left, this.operatorToken];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly left: Expression,\n    readonly operatorToken: Token\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    this.left.print(builder);\n    builder(punctuator(this.operatorToken.type));\n    builder(\")\");\n  }\n}\n","import PostfixExpression from \"../expressions/PostfixExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport InfixParselet from \"./InfixParselet\";\n\n/**\n * Generic infix parselet for an unary arithmetic operator. Parses postfix\n * unary \"?\" expressions.\n */\nexport default class PostfixOperatorParselet extends InfixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(_parser: Parser, left: Expression, token: Token): Expression {\n    return new PostfixExpression([...left.tokens, token], left, token);\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import { Expression, punctuator, StringBuilder, Token } from \"../types\";\n\n/**\n * A prefix unary arithmetic expression like \"!a\" or \"-b\".\n */\nexport default class PrefixExpression extends Expression {\n  kind = \"prefix\";\n  children = [this.right];\n\n  constructor(\n    readonly tokens: Token[],\n    readonly operatorToken: Token,\n    readonly right: Expression\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(\"(\");\n    builder(punctuator(this.operatorToken.type));\n    this.right.print(builder);\n    builder(\")\");\n  }\n}\n","import PrefixExpression from \"../expressions/PrefixExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Generic prefix parselet for an unary arithmetic operator. Parses prefixes, for example\n * unary \"-\", \"+\", \"~\", and \"!\" expressions.\n */\nexport default class PrefixOperatorParselet extends PrefixParselet {\n  constructor(readonly precedence: number) {\n    super();\n  }\n\n  public parse(parser: Parser, token: Token): Expression {\n    // To handle right-associative operators like \"^\", we allow a slightly\n    // lower precedence when parsing the right-hand side. This will let a\n    // parselet with the same precedence appear on the right, which will then\n    // take *this* parselet's result as its left-hand argument.\n    const right = parser.parseExpression(this.precedence);\n\n    return new PrefixExpression([token, ...right.tokens], token, right);\n  }\n\n  public getPrecedence(): number {\n    return this.precedence;\n  }\n}\n","import Parser from './Parser';\n\nexport const PrattParser = Parser;\n\nexport * from './parselets/index';\nexport * from './expressions/index';\nexport * from './types';\n\nexport default PrattParser;\n","/**\n * Defines the different precedence levels used by the infix parsers. These\n * determine how a series of infix expressions will be grouped. For example,\n * \"a + b * c - d\" will be parsed as \"(a + (b * c)) - d\" because \"*\" has higher\n * precedence than \"+\" and \"-\". Here, bigger numbers mean higher precedence.\n */\nexport default class ODKFormulaPrecedence {\n  // Ordered in increasing precedence.\n  public static BOOLEAN_OP = 1;\n  public static CONDITIONAL = 2;\n  public static ASSIGNMENT = 3;\n  public static SUM = 4;\n  public static PRODUCT = 5;\n  public static EXPONENT = 6;\n  public static PREFIX = 7;\n  public static POSTFIX = 8;\n  public static CALL = 9;\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A literal expression like `true`, `\"some string\"`, `1.2345`.\n */\nexport default class LiteralExpression<T> extends Expression {\n  kind = \"literal\";\n  children = this.tokens;\n\n  constructor(\n    readonly tokens: Token[],\n    readonly type: string,\n    readonly value: T\n  ) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    if (this.type === \"string\") {\n      builder(`'${this.value}'`);\n      return;\n    }\n    builder(\"[\");\n    builder(this.type);\n    builder(\" \");\n    builder(String(this.value));\n    builder(\"]\");\n  }\n}\n","import LiteralExpression from \"../expressions/LiteralExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a literal value, like `-4` or `true`.\n */\nexport default class LiteralParselet<T> extends PrefixParselet {\n  constructor(\n    readonly getValue: (token: Token) => T,\n    readonly getType: (token: Token) => string\n  ) {\n    super();\n  }\n\n  public parse(_parser: Parser, token: Token): Expression {\n    const value = this.getValue(token);\n    const type = this.getType(token);\n    return new LiteralExpression<T>([token], type, value);\n  }\n}\n","import { Expression, StringBuilder, Token } from \"../types\";\n\n/**\n * A simple variable name expression like \"a > b > c\" or \"[foo=~bar]\".\n */\nexport default class SelectorExpression<T> extends Expression {\n  kind = \"selector\";\n  children = [this.selectorToken];\n  tokens = [this.selectorToken];\n\n  constructor(readonly selectorToken: Token, readonly selector: T) {\n    super();\n  }\n\n  public print(builder: StringBuilder): void {\n    builder(this.selectorToken.text);\n  }\n}\n","import SelectorExpression from \"../expressions/SelectorExpression\";\nimport Parser from \"../Parser\";\nimport { Expression, Token } from \"../types\";\nimport PrefixParselet from \"./PrefixParselet\";\n\n/**\n * Simple parselet for a selector variable like \"x > y > z\" or \"a/b/c[d='123']\".\n *\n * Expects that the lexer recognizes the whole selector already completely as one token.\n */\nexport default class SelectorParselet<T> extends PrefixParselet {\n  constructor(readonly getSelector: (text: string) => T) {\n    super();\n  }\n  public parse(_parser: Parser, token: Token): Expression {\n    const selector = this.getSelector(token.text);\n    return new SelectorExpression(token, selector);\n  }\n}\n","import {\n  default as PrattParser,\n  TokenType,\n  // AssignParselet,\n  BinaryOperatorParselet,\n  CallParselet,\n  ConditionalParselet,\n  GroupParselet,\n  NameParselet,\n  PostfixOperatorParselet,\n  PrefixOperatorParselet,\n  Token,\n  Expression,\n} from \"../pratt-parser-base/index\";\nimport Precedence from \"./ODKFormulaPrecedence\";\nimport LiteralParselet from \"../pratt-parser-base/parselets/LiteralParselet\";\nimport SelectorParselet from \"../pratt-parser-base/parselets/SelectorParselet\";\nimport { ParserOptions } from \"../pratt-parser-base/Parser\";\n\n/**\n * Extends the generic Parser class with support for parsing the actual ODK formula grammar.\n * grammar.\n *\n * Example based on a blog post by Bob Nystrom:\n *\n * http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n */\nexport default class ODKFormulaParser extends PrattParser {\n  expressions: Expression[] = [];\n  tokens: Token[] = [];\n\n  constructor(options: ParserOptions) {\n    super({\n      onExpression: (e) => this.expressions.push(e),\n      onToken: (t) => this.tokens.push(t),\n      ...options,\n    });\n\n    // Register all of the parselets for the grammar.\n\n    // Register the ones that need special parselets.\n    this.register(\n      TokenType.NAME,\n      new NameParselet((name) =>\n        name.startsWith(\"$\") ? name.slice(2, name.length - 1) : name\n      )\n    );\n    this.register(\n      TokenType.SELECTOR,\n      new SelectorParselet((text) => text.split(\"/\"))\n    );\n    this.register(\n      TokenType.FLOAT_LITERAL,\n      new LiteralParselet(\n        (t) => parseFloat(t.text),\n        () => \"float\"\n      )\n    );\n    this.register(\n      TokenType.INT_LITERAL,\n      new LiteralParselet(\n        (t) => parseInt(t.text, 10),\n        () => \"int\"\n      )\n    );\n    this.register(\n      TokenType.STRING_LITERAL,\n      new LiteralParselet(\n        (t) => t.text.slice(1, t.text.length - 1),\n        () => \"string\"\n      )\n    );\n    this.register(\n      TokenType.QUESTION,\n      new ConditionalParselet(Precedence.CONDITIONAL)\n    );\n    this.register(\n      TokenType.LEFT_PAREN,\n      new GroupParselet(TokenType.RIGHT_PAREN)\n    );\n    this.register(\n      TokenType.LEFT_PAREN,\n      new CallParselet(TokenType.RIGHT_PAREN, TokenType.COMMA, Precedence.CALL)\n    );\n\n    this.infixRight(TokenType.COMPARISON, Precedence.CONDITIONAL);\n\n    this.infixLeft(TokenType.BOOLEAN_AND, Precedence.BOOLEAN_OP);\n    this.infixLeft(TokenType.BOOLEAN_OR, Precedence.BOOLEAN_OP);\n    this.infixLeft(TokenType.PLUS, Precedence.SUM);\n    this.infixLeft(TokenType.MINUS, Precedence.SUM);\n    this.infixLeft(TokenType.ASTERISK, Precedence.PRODUCT);\n    this.infixLeft(TokenType.SLASH, Precedence.PRODUCT);\n    this.infixLeft(TokenType.MODULO, Precedence.EXPONENT);\n  }\n\n  /**\n   * Registers a postfix unary operator parselet for the given token and\n   * precedence.\n   */\n  public postfix(token: TokenType, precedence: number): void {\n    this.register(token, new PostfixOperatorParselet(precedence));\n  }\n\n  /**\n   * Registers a prefix unary operator parselet for the given token and\n   * precedence.\n   */\n  public prefix(token: TokenType, precedence: number): void {\n    this.register(token, new PrefixOperatorParselet(precedence));\n  }\n\n  /**\n   * Registers a left-associative binary operator parselet for the given token\n   * and precedence.\n   */\n  public infixLeft(token: TokenType, precedence: number): void {\n    this.register(token, new BinaryOperatorParselet(precedence, false));\n  }\n\n  /**\n   * Registers a right-associative binary operator parselet for the given token\n   * and precedence.\n   */\n  public infixRight(token: TokenType, precedence: number): void {\n    this.register(token, new BinaryOperatorParselet(precedence, true));\n  }\n}\n","// tslint:disable-next-line: import-name\nimport SimpleSchema, {\n  SchemaDefinition,\n  ValidationFunction,\n} from \"simpl-schema\";\nimport ODKFormulaLexer from \"../functions/odk-formulas/odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../functions/odk-formulas/odk-formula-parser/ODKFormulaParser\";\n\nexport const getStringMapSchemaDefinition = <T>(\n  schemaDefinition: Partial<SchemaDefinition<T>> = {}\n): SchemaDefinition<T> => {\n  return {\n    type: Object,\n    blackbox: true,\n    custom() {\n      const { value } = this;\n      if (value === undefined) {\n        return;\n      }\n      if (typeof value === \"string\") {\n        return \"notAllowed\";\n      }\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (typeof value[key] !== \"string\") {\n          return \"notAllowed\";\n        }\n      }\n      return undefined;\n    },\n    ...schemaDefinition,\n  };\n};\n\nexport const getLocalizedStringSchemaDefinition = getStringMapSchemaDefinition;\n\nconst optionalLocalizedString = getLocalizedStringSchemaDefinition({\n  optional: true,\n});\nconst optionalStringMap = getStringMapSchemaDefinition({ optional: true });\n\nconst formulaValidationFunction: ValidationFunction<unknown> = function () {\n  try {\n    const lexer = new ODKFormulaLexer(this.value);\n    const parser = new ODKFormulaParser({ tokens: lexer });\n    parser.parseExpression();\n  } catch (e) {\n    this.addValidationErrors([\n      {\n        name: this.key,\n        type: `Invalid formula: ${e.message}`,\n        value: this.value,\n      },\n    ]);\n  }\n};\n\nexport const questionRowSchema = new SimpleSchema({\n  type: {\n    type: String,\n  },\n  name: {\n    type: String,\n    optional: true,\n    custom() {\n      const shouldBeRequired = ![\"end_group\", \"end_repeat\"].includes(\n        this.field(\"type\").value\n      );\n      if (shouldBeRequired) {\n        const error = SimpleSchema.ErrorTypes.REQUIRED;\n\n        // inserts\n        if (!this.operator) {\n          if (!this.isSet || this.value === null || this.value === \"\")\n            return error;\n        }\n\n        // updates\n        else if (this.isSet) {\n          if (\n            (this.operator === \"$set\" && this.value === null) ||\n            this.value === \"\"\n          )\n            return error;\n          if (this.operator === \"$unset\") return error;\n          if (this.operator === \"$rename\") return error;\n        }\n      }\n      return undefined;\n    },\n  },\n  constraint: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  constraint_message: optionalLocalizedString,\n  label: optionalLocalizedString,\n  image: optionalLocalizedString,\n  video: optionalLocalizedString,\n  hint: optionalLocalizedString,\n  guidance_hint: optionalLocalizedString,\n  required_message: optionalLocalizedString,\n  relevant: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  choice_filter: {\n    // Only on 'select*' types\n    type: String,\n    optional: true,\n  },\n  calculation: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  trigger: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  readonly: {\n    type: String,\n    optional: true,\n  },\n  required: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  parameters: {\n    type: String,\n    optional: true,\n  },\n  repeat_count: {\n    type: String,\n    optional: true,\n    custom: formulaValidationFunction,\n  },\n  appearance: {\n    type: String,\n    optional: true,\n  },\n  default: {\n    type: String,\n    optional: true,\n  },\n  instance: optionalStringMap,\n  bind: optionalStringMap,\n  body: optionalStringMap,\n});\n\nexport const choiceRowSchema = new SimpleSchema({\n  \"list name\": {\n    type: String,\n  },\n  name: {\n    type: String,\n  },\n  label: getLocalizedStringSchemaDefinition(),\n});\n\nexport const settingsRowSchema = new SimpleSchema({\n  form_title: {\n    type: String,\n    optional: true,\n  },\n  form_id: {\n    type: String,\n    optional: true,\n  },\n  public_key: {\n    type: String,\n    optional: true,\n  },\n  submission_url: {\n    type: String,\n    optional: true,\n  },\n  default_language: {\n    type: String,\n    optional: true,\n  },\n  version: {\n    type: String,\n    optional: true,\n  },\n});\n","import {\n  choiceRowSchema,\n  questionRowSchema,\n  settingsRowSchema,\n} from \"./RowSchemas\";\n\n/** Represents a row in the 'survey' worksheet */\n\nexport type StringMap = Record<string, string>;\nexport type LocalizedString = StringMap;\n\nexport type QuestionRow = Record<\n  string,\n  string | LocalizedString | undefined\n> & {\n  /** specifies the type of entry you are adding. */\n  type: string;\n  /** specifies the unique variable name for that entry. No two entries can have the same name. Names have to start with a letter or an underscore. Names can only contain letters, digits, hyphens, underscores, and periods. Names are case-sensitive. */\n  name: string;\n  /** contains the actual text you see in the form. Alternatively, label translation columns can be used. */\n  label: LocalizedString;\n  constraint?: string;\n  constraint_message?: LocalizedString;\n  image?: LocalizedString;\n  audio?: LocalizedString;\n  video?: LocalizedString;\n  hint?: LocalizedString;\n  guidance_hint?: string;\n  relevant?: string;\n  choice_filter?: string;\n  calculation?: string;\n  trigger?: string;\n  readonly?: string;\n  required?: string;\n  required_message?: LocalizedString;\n  parameters?: string;\n  repeat_count?: string;\n  appearance?: string;\n  default?: string;\n  instance?: StringMap;\n  bind?: StringMap;\n  body?: StringMap;\n};\n\n/** Represents a row in the 'choices' worksheet */\n\nexport type ChoiceRow = Record<string, string | LocalizedString> & {\n  /** lets you group together a set of related answer choices, i.e., answer choices that should appear together under a question. */\n  \"list name\": string;\n  /** specifies the unique variable name for that answer choice. */\n  name: string;\n  /** shows the answer choice exactly as you want it to appear on the form. Alternatively, label translation columns can be used. */\n  label: LocalizedString;\n};\n\n/** Represents a row in the 'settings' worksheet */\n\nexport type SettingsRow = Record<string, string> & {\n  /** The title of the form that is shown to users. The form title is pulled from form_id if form_title is blank or missing. */\n  form_title: string;\n  /** The name used to uniquely identify the form on the server. The form id is pulled from the XLS file name if form_id is blank or missing. */\n  form_id: string;\n  /** For encryption-enabled forms, this is where the public key is copied and pasted. */\n  public_key: string;\n  /** This url can be used to override the default server where finalized records are submitted to. */\n  submission_url: string;\n  /** In localized forms, this sets which language should be used as the default. The same format as described for adding translations should be used, including the language code. */\n  default_language: string;\n  /** String of up to 10 numbers that describes this revision. Revised form definitions must have numerically greater versions than previous ones. A common convention is to use strings of the form 'yyyymmddrr'. For example, 2017021501 is the 1st revision from Feb 15th, 2017. */\n  version: string;\n};\n\nexport function assertValidQuestionRow(\n  row: Record<string, unknown>\n): asserts row is QuestionRow {\n  return questionRowSchema.validate(row);\n}\nexport function assertValidChoiceRow(\n  row: Record<string, unknown>\n): asserts row is ChoiceRow {\n  return choiceRowSchema.validate(row, { keys: [\"list name\", \"name\"] });\n}\nexport function assertValidSettingsRow(\n  row: Record<string, unknown>\n): asserts row is SettingsRow {\n  return settingsRowSchema.validate(row);\n}\n","import {\n  BeginMarkerRow,\n  BeginOrEndMarkerRow,\n} from \"../types/BeginOrEndMarkerRow\";\nimport { SemanticError } from \"../types/Errors\";\nimport { ODKNode } from \"../types/ODKNode\";\nimport { QuestionRow } from \"../types/RowTypes\";\nimport { normalizeType } from \"./loadSurveyFromXLSX\";\n\nfunction assertNoEndMarker(\n  row: QuestionRow | BeginOrEndMarkerRow,\n  i: number\n): asserts row is QuestionRow | BeginMarkerRow {\n  if (row.type.match(/^end[ _](?:group|repeat)$/)) {\n    throw new SemanticError(\n      `Found '${row.type}' without a matching start marker in row ${\n        i + 2\n      }. Please check that the group/repeat nesting is correct. The row: ${row}`\n    );\n  }\n}\n\n/**\n * Calculates a nested `Node` survey model for an array of non-nested survey worksheet rows.\n */\nexport default function nestSurvey({\n  rows,\n  defaultLanguage,\n  formRootNameFromSettings = \"data\",\n  titleFromSettings = \"\",\n  onRow,\n}: {\n  rows: readonly (QuestionRow | BeginOrEndMarkerRow)[];\n  defaultLanguage: string;\n  formRootNameFromSettings?: string;\n  titleFromSettings?: string;\n  onRow?: (row: QuestionRow | BeginOrEndMarkerRow, node: ODKNode) => void;\n}): {\n  node: Readonly<ODKNode>;\n} {\n  const root: ODKNode = {\n    children: [] as ODKNode[],\n    type: \"\",\n    typeParameters: [],\n    rowIndex: -1,\n    indentationLevel: 0,\n    row: {\n      name: formRootNameFromSettings,\n      type: \"\",\n      label: { [defaultLanguage]: titleFromSettings },\n    } as QuestionRow,\n  };\n  const stack: ODKNode[] = [root];\n  let i = 0;\n\n  while (i < rows.length) {\n    const row = rows[i];\n    const [type, ...typeParameters] = normalizeType(row.type).split(\" \");\n    const currentGroup = stack[stack.length - 1];\n\n    if (currentGroup.type === \"begin_group\" && type === \"end_group\") {\n      stack.pop();\n      onRow?.(row, currentGroup);\n    } else if (\n      currentGroup.type === \"begin_repeat\" &&\n      row.type === \"end_repeat\"\n    ) {\n      stack.pop();\n      onRow?.(row, currentGroup);\n    } else if (type.match(/^begin_(?:repeat|group)$/)) {\n      // Found the beginning of a nested group or repeat\n      const newGroupNode: ODKNode = {\n        row: row as BeginMarkerRow,\n        type,\n        typeParameters,\n        children: [],\n        indentationLevel: stack.length - 1,\n        rowIndex: i,\n      };\n      currentGroup.children.push(newGroupNode);\n      stack.push(newGroupNode);\n      onRow?.(row, newGroupNode);\n    } else {\n      // Found a 'normal' survey question\n      assertNoEndMarker(row, i);\n      const newChildNode: ODKNode = {\n        row,\n        type,\n        typeParameters,\n        indentationLevel: stack.length - 1,\n        rowIndex: i,\n        children: [],\n      };\n      currentGroup.children.push(newChildNode);\n      onRow?.(row, newChildNode);\n    }\n\n    i += 1;\n  }\n\n  return { node: root };\n}\n","import nestSurvey from \"../functions/nestSurvey\";\nimport { ODKNode } from \"./ODKNode\";\nimport { ChoiceRow, QuestionRow, SettingsRow } from \"./RowTypes\";\n\nexport type XLSFormWorksheet<RowT> = Readonly<{\n  rows: readonly RowT[];\n  languages: Readonly<Set<string>>;\n  columnNames: readonly string[];\n  columnNamesNormalized: readonly string[];\n}>;\n\nexport type SurveyWorksheet = XLSFormWorksheet<QuestionRow>;\nexport type ChoicesWorksheet = XLSFormWorksheet<ChoiceRow>;\nexport type SettingsWorksheet = XLSFormWorksheet<SettingsRow>;\n\nexport type ChoiceRowByName = Record<string, ChoiceRow>;\nexport type ChoiceRowsByListNameAndName = Record<string, ChoiceRowByName>;\n\nexport type FlatNode = {\n  row: Readonly<QuestionRow>;\n  node: Readonly<ODKNode>;\n};\n\nexport type XLSForm = {\n  worksheets: {\n    survey: SurveyWorksheet;\n    choices?: ChoicesWorksheet;\n    settings?: SettingsWorksheet;\n  };\n  choicesByName: Readonly<ChoiceRowsByListNameAndName>;\n  rootSurveyGroup: Readonly<ODKNode>;\n  languages: Readonly<Set<string>>;\n  flatNodes: readonly ODKNode[];\n};\n\nexport type WorksheetName = keyof XLSForm[\"worksheets\"];\n\nexport type WorksheetRowsWithMetadata<RowT> = {\n  rows: readonly RowT[];\n  languages: Readonly<Set<string>>;\n  columnNames: readonly string[];\n  columnNamesNormalized: readonly string[];\n};\n\nexport function loadChoices(\n  worksheet: ChoicesWorksheet\n): ChoiceRowsByListNameAndName {\n  const map: ChoiceRowsByListNameAndName = {};\n\n  worksheet.rows.forEach((row) => {\n    const listName = row[\"list name\"];\n    const { name } = row;\n    const list = map[listName] || {};\n    list[name] = row;\n    map[listName] = list;\n  });\n\n  return map;\n}\n\nexport function loadXLSFormFromRows(\n  survey: Readonly<WorksheetRowsWithMetadata<QuestionRow>>,\n  defaultLanguage: string,\n  settings?: WorksheetRowsWithMetadata<SettingsRow>,\n  choices?: WorksheetRowsWithMetadata<ChoiceRow>\n) {\n  const flatNodes: ODKNode[] = [];\n  const { node: rootSurveyGroup } = nestSurvey({\n    rows: survey.rows,\n    defaultLanguage,\n    onRow: (row, node) => flatNodes.push(node),\n  });\n\n  const xlsForm: XLSForm = {\n    worksheets: {\n      settings,\n      choices,\n      survey,\n    },\n    rootSurveyGroup,\n    choicesByName: choices ? loadChoices(choices) : {},\n    languages: survey.languages,\n    flatNodes,\n  };\n  return xlsForm;\n}\n","import Excel from \"exceljs\";\nimport { SyntaxError } from \"../types/Errors\";\nimport {\n  choiceRowSchema,\n  questionRowSchema,\n  settingsRowSchema,\n} from \"../types/RowSchemas\";\nimport {\n  assertValidChoiceRow,\n  assertValidQuestionRow,\n  assertValidSettingsRow,\n  ChoiceRow,\n  QuestionRow,\n  SettingsRow,\n} from \"../types/RowTypes\";\nimport {\n  loadXLSFormFromRows,\n  WorksheetName,\n  WorksheetRowsWithMetadata,\n  XLSForm,\n} from \"../types/XLSForm\";\n\nexport function nestDoubleColonFields(\n  row: Record<string, unknown>,\n  namespacePrefixes: string[],\n  defaultSuffix?: string\n): {\n  result: Readonly<Record<string, unknown>>;\n  foundSuffixes: Readonly<Set<string>>;\n} {\n  const result: Record<string, unknown> = {\n    ...row,\n  };\n\n  const foundSuffixes = new Set<string>();\n\n  if (defaultSuffix) {\n    namespacePrefixes.forEach((k) => {\n      if (result[k]) {\n        result[`${k}::${defaultSuffix}`] = result[k];\n      }\n      foundSuffixes.add(defaultSuffix);\n      delete result[k];\n    });\n  }\n\n  namespacePrefixes.forEach((namespacePrefix) => {\n    Object.keys(result)\n      .filter((k) => k.startsWith(namespacePrefix))\n      .forEach((k) => {\n        const [prefix, suffix] = k.split(/::/);\n        /* Example { 'label::English (en)': 'A label!' } */\n        const objectToExtend = result[prefix] as\n          | Record<string, string>\n          | string;\n        const value = String(result[k]);\n        if (objectToExtend === undefined) {\n          result[prefix] = { [suffix]: value };\n          foundSuffixes.add(suffix);\n        } else if (typeof objectToExtend === \"object\") {\n          objectToExtend[suffix] = value;\n          foundSuffixes.add(suffix);\n        } else {\n          throw new SyntaxError(\n            `Can't handle \\`${prefix}\\` column. Columns with prefix \\`${prefix}\\` must be namespaced with \\`::\\`. See chapter [‘Advanced use and extensibility’](https://xlsform.org/en/#advanced-use-and-extensibility) in the documentation.`\n          );\n        }\n        delete result[k];\n      });\n  });\n\n  return { result, foundSuffixes };\n}\n\n// See reference table: https://xlsform.org/en/ref-table/\n\nexport function normalizeColumnNames(\n  headerRow: Excel.CellValue[]\n): readonly string[] {\n  const result: string[] = [];\n  for (let i = 0; i < headerRow.length; i += 1) {\n    const columnName = headerRow[i]?.toString() || \"\";\n    result.push(\n      columnName\n        .replace(/^constraint-msg\\B/, \"constraint_message\")\n        .replace(/^requiredMsg\\B/, \"required_message\")\n        .replace(/^bind::required$/, \"required\")\n        .replace(/^repeat-count$/, \"repeat_count\")\n        .replace(/^media::(image|audio|video)\\B/, \"$1\")\n        .replace(/^photo\\B/, \"image\")\n        .replace(/^list_name$/, \"list name\")\n    );\n  }\n  return Object.freeze(result);\n}\n\n// See reference table: https://xlsform.org/en/ref-table/\n\nexport function normalizeType(type: string): string {\n  return type\n    .replace(/^media::(image|audio|video)\\B/, \"$1\")\n    .replace(/^imei$/, \"deviceid\")\n    .replace(/^phone_number$/, \"phonenumber\")\n    .replace(/^select one\\B/, \"select_one\")\n    .replace(/^select multiple\\B/, \"select_multiple\")\n    .replace(/^location$/, \"geopoint\")\n    .replace(/^photo\\B/, \"image\")\n    .replace(/^trigger$/, \"acknowledge\")\n    .replace(/^begin group$/, \"begin_group\")\n    .replace(/^end group$/, \"end_group\")\n    .replace(/^begin repeat$/, \"begin_repeat\")\n    .replace(/^end repeat$/, \"end_repeat\");\n}\n\nconst autoCleanOptions = {\n  getAutoValues: true,\n  trimStrings: true,\n  mutate: false,\n};\n\nexport function loadQuestionRow(row: Record<string, unknown>): QuestionRow {\n  const cleanRow = questionRowSchema.clean(\n    { ...row, type: normalizeType(String(row.type)) },\n    autoCleanOptions\n  );\n  assertValidQuestionRow(cleanRow);\n  return cleanRow;\n}\n\nexport function loadChoicesRow(row: Record<string, unknown>): ChoiceRow {\n  const cleanRow = choiceRowSchema.clean(row, {\n    ...autoCleanOptions,\n    filter: false,\n  });\n  assertValidChoiceRow(cleanRow);\n  return cleanRow;\n}\n\nexport function loadSettingsRow(row: Record<string, unknown>): SettingsRow {\n  const cleanRow = settingsRowSchema.clean(row, autoCleanOptions);\n  assertValidSettingsRow(cleanRow);\n  return cleanRow;\n}\n\ntype LoadRowFunction<T> = (row: Record<string, unknown>) => T;\n\nexport const localizableColumnNames = [\n  \"label\",\n  \"hint\",\n  \"constraint_message\",\n  \"required_message\",\n  \"image\",\n  \"audio\",\n  \"video\",\n];\n\nexport function loadExcelRow<RowT>({\n  row,\n  columnNames,\n  defaultLanguage,\n  loadRowFn,\n}: {\n  readonly row: Excel.Row;\n  readonly columnNames: readonly string[];\n  readonly defaultLanguage: string | undefined;\n  readonly loadRowFn: LoadRowFunction<RowT>;\n}) {\n  const rowRawData: Record<string, unknown> = {};\n  (row.values as Excel.CellValue[]).slice(1).forEach((value, columnIndex) => {\n    const columnName = columnNames[columnIndex];\n    rowRawData[columnName] = `${value}`;\n  });\n  const { result: rowDataWithLocalizedStrings } = nestDoubleColonFields(\n    rowRawData,\n    localizableColumnNames,\n    defaultLanguage\n  );\n  const {\n    result: rowDataWithNamespacedFields,\n  } = nestDoubleColonFields(rowDataWithLocalizedStrings, [\n    \"instance\",\n    \"bind\",\n    \"body\",\n  ]);\n  try {\n    return loadRowFn(rowDataWithNamespacedFields);\n  } catch (error) {\n    throw new SyntaxError(\n      `Could not load row ${JSON.stringify(\n        rowDataWithNamespacedFields,\n        null,\n        2\n      )}: ${error} / ${JSON.stringify(error.details)}`\n    );\n  }\n}\n\nfunction findLanguagesInColumnNames(\n  columnNames: readonly string[],\n  defaultLanguage?: string\n): Readonly<Set<string>> {\n  const columnNamesToTrues: Record<string, unknown> = {};\n  columnNames.forEach((name) => {\n    columnNamesToTrues[name] = true;\n  });\n  const { foundSuffixes } = nestDoubleColonFields(\n    columnNamesToTrues,\n    localizableColumnNames,\n    defaultLanguage\n  );\n  return foundSuffixes;\n}\n\nfunction loadWorksheet<RowT>(\n  workbook: Excel.Workbook,\n  sheetName: WorksheetName,\n  loadRowFn: LoadRowFunction<RowT>,\n  defaultLanguage?: string\n): WorksheetRowsWithMetadata<RowT> | undefined {\n  const excelWorksheet = workbook.getWorksheet(sheetName);\n  const rows: RowT[] = [];\n\n  if (!excelWorksheet) {\n    return undefined;\n  }\n\n  const firstRow = excelWorksheet.getRows(1, 1)[0];\n  if (!(firstRow.values instanceof Array)) {\n    throw new SyntaxError(\n      `First row of the ‘${sheetName}’ worksheet must be an array structure, but is a ${typeof firstRow.values} instead. Please fix this.`\n    );\n  }\n\n  // console.log('Column names before normalization:', firstRow.values.slice(1));\n  const columnNames = firstRow.values\n    .slice(1)\n    .map((cellValue) => cellValue?.toString() || \"\");\n  const columnNamesNormalized = normalizeColumnNames(columnNames);\n  const languages = findLanguagesInColumnNames(\n    columnNamesNormalized,\n    defaultLanguage\n  );\n  excelWorksheet.eachRow((row, rowIndex) => {\n    if (rowIndex === 1) {\n      return;\n    }\n    rows.push(\n      loadExcelRow<RowT>({\n        row,\n        columnNames: columnNamesNormalized,\n        defaultLanguage,\n        loadRowFn,\n      })\n    );\n  });\n\n  return { rows, languages, columnNames, columnNamesNormalized };\n}\n\nexport async function loadFormFromExcelWorkbook(\n  workbook: Excel.Workbook\n): Promise<XLSForm> {\n  const settings = loadWorksheet(workbook, \"settings\", loadSettingsRow);\n  const defaultLanguage = settings?.rows[0].default_language || \"English (en)\";\n  const choices = loadWorksheet(\n    workbook,\n    \"choices\",\n    loadChoicesRow,\n    defaultLanguage\n  );\n  const survey = loadWorksheet(\n    workbook,\n    \"survey\",\n    loadQuestionRow,\n    defaultLanguage\n  );\n\n  if (!survey) {\n    throw new Error(\n      \"No `survey` sheet found in workbook. Please define a sheet named `survey` and try again.\"\n    );\n  }\n\n  const xlsForm: XLSForm = loadXLSFormFromRows(\n    survey,\n    defaultLanguage,\n    settings,\n    choices\n  );\n\n  // console.log(xlsForm);\n  // console.log(xlsForm.rootSurveyGroup);\n\n  return xlsForm;\n}\n\nexport default async function loadFormFromXLSXFile(\n  filename: string\n): Promise<XLSForm> {\n  const workbook = new Excel.Workbook();\n  await workbook.xlsx.readFile(filename);\n  return loadFormFromExcelWorkbook(workbook);\n}\n","import { LocalizedString } from \"../xlsform-simple-schema/types/RowTypes\";\n\nexport function createLabelInAllLanguages(\n  label: string,\n  languages: Readonly<Set<string>>\n): LocalizedString {\n  const result: LocalizedString = {};\n  languages.forEach((lang) => {\n    result[lang] = label;\n  });\n  return result;\n}\n","import { createLabelInAllLanguages } from \"../../lib/createLabelInAllLanguages\";\nimport ODKFormulaEvaluationContext from \"../functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport {\n  IBeginGroupMarkerRow,\n  IBeginRepeatMarkerRow,\n} from \"./BeginOrEndMarkerRow\";\nimport { QuestionRow } from \"./RowTypes\";\n\nexport type ODKNodeAnswer = {};\n\nexport type ODKNodeWithoutRuntimeInfo =\n  | {\n      row?: QuestionRow & (IBeginRepeatMarkerRow | IBeginGroupMarkerRow);\n      children: ODKNodeWithoutRuntimeInfo[];\n      indentationLevel: number;\n      rowIndex: number;\n    }\n  | {\n      row: QuestionRow;\n      children: ODKNodeWithoutRuntimeInfo[];\n      indentationLevel: number;\n      rowIndex: number;\n    };\n\nexport type ODKNode =\n  | {\n      row: QuestionRow & (IBeginRepeatMarkerRow | IBeginGroupMarkerRow);\n      type: string;\n      typeParameters: string[];\n      children: ODKNode[];\n      indentationLevel: number;\n      rowIndex: number;\n    }\n  | {\n      row: QuestionRow;\n      type: string;\n      typeParameters: string[];\n      children: ODKNode[];\n      indentationLevel: number;\n      rowIndex: number;\n    };\n\nlet i = 0;\nexport function getEmptyNode(\n  languages: Readonly<Set<string>>\n): Readonly<ODKNode> {\n  i += 1;\n  return Object.freeze({\n    row: {\n      type: \"text\",\n      name: `empty_node_${i}`,\n      label: createLabelInAllLanguages(`Empty node ${i}`, languages),\n    },\n    type: \"text\",\n    typeParameters: [],\n    children: [],\n    indentationLevel: 0,\n    rowIndex: -2,\n  });\n}\n\nexport type NodesToValues<T = unknown> = Readonly<Map<Readonly<ODKNode>, T>>;\n\nexport type EvaluatableColumnName =\n  | \"relevant\"\n  | \"calculation\"\n  | \"required\"\n  | \"readonly\"\n  | \"constraint\";\nexport const evaluatableColumnNames: EvaluatableColumnName[] = [\n  \"calculation\",\n  \"required\",\n  \"relevant\",\n  \"readonly\",\n  \"constraint\",\n];\n\nexport function isNodeRelevant(\n  node: ODKNode,\n  context?: ODKFormulaEvaluationContext\n) {\n  if (!context) {\n    return false;\n  }\n  const isRelevantEvaluationResult = context.evaluationResults\n    .get(node)\n    ?.get(\"relevant\")?.result;\n  return isRelevantEvaluationResult === undefined || isRelevantEvaluationResult;\n}\n\nexport function isNodeReadonly(\n  node: ODKNode,\n  context?: ODKFormulaEvaluationContext\n) {\n  if (!context) {\n    return false;\n  }\n  const isReadonlyEvaluationResult = context.evaluationResults\n    .get(node)\n    ?.get(\"readonly\")?.result;\n  return isReadonlyEvaluationResult === undefined || isReadonlyEvaluationResult;\n}\n\nexport function isGroupNode(node: ODKNode) {\n  return node.type === \"begin_group\" || node.type === \"begin_repeat\";\n}\n\nexport function isGroupRow(row: QuestionRow) {\n  return (\n    row.type === \"begin_group\" ||\n    row.type === \"begin_repeat\" ||\n    row.type === \"end_group\" ||\n    row.type === \"end_repeat\"\n  );\n}\n","import { cloneDeep, get, set, without } from \"lodash\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport { localizableColumnNames } from \"../xlsform-simple-schema/functions/loadSurveyFromXLSX\";\nimport {\n  evaluatableColumnNames,\n  ODKNode,\n} from \"../xlsform-simple-schema/types/ODKNode\";\nimport { QuestionRow } from \"../xlsform-simple-schema/types/RowTypes\";\n\nexport type DependentNodeWithReplacedRow = {\n  node: ODKNode;\n  index: number;\n  row: QuestionRow;\n};\n\nexport default function findOrReplaceFieldReferences(\n  xlsForm: XLSForm,\n  node: ODKNode,\n  replaceName?: string\n) {\n  const oldName = node.row.name;\n  const dependentNodes: DependentNodeWithReplacedRow[] = [];\n  const variableRegexp = new RegExp(`\\\\\\${${oldName}}`);\n  xlsForm.flatNodes.forEach((n) => {\n    let found = false;\n    let row: QuestionRow | undefined;\n    const localizableKeys = localizableColumnNames.flatMap((lcn) =>\n      [...xlsForm.languages.values()].map((lang) => `${lcn}.${lang}`)\n    );\n    without(evaluatableColumnNames as string[], \"choice_filter\")\n      .concat(...localizableKeys)\n      .forEach((cn) => {\n        const value = get(n.row, cn);\n        if (typeof value !== \"string\" && value !== undefined) {\n          throw new Error(\n            `Replacing variable names works only with string cells. Please ensure the ${cn} cell of the ${node.row.name} row has a string value.`\n          );\n        }\n        if (value?.match(variableRegexp)) {\n          if (replaceName) {\n            const newCellValue = value?.replaceAll(\n              `\\${${oldName}}`,\n              `\\${${replaceName}}`\n            );\n            row = row || cloneDeep(n.row);\n            set(row, cn, newCellValue);\n          }\n          found = true;\n        }\n      });\n    if (found) {\n      dependentNodes.push({ node: n, index: n.rowIndex, row: row || n.row });\n    }\n  });\n  return dependentNodes;\n}\n","import ODKFormulaEvaluationResult from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\n\nexport function getFirstColumnNameWithError(\n  nodeEvaluationResults: Map<string, ODKFormulaEvaluationResult> | undefined\n) {\n  return (\n    nodeEvaluationResults &&\n    [...nodeEvaluationResults.keys()].find(\n      (k) => nodeEvaluationResults?.get(k)?.error\n    )\n  );\n}\n","import * as React from \"react\";\nimport ODKFormulaEvaluationResult from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport {\n  EvaluatableColumnName,\n  getEmptyNode,\n  ODKNode,\n} from \"../xlsform-simple-schema/types/ODKNode\";\n\nexport interface IODKNodeContext {\n  node: ODKNode;\n  nodeEvaluationResults?: Map<\n    EvaluatableColumnName,\n    ODKFormulaEvaluationResult\n  >;\n}\n\nexport const ODKNodeContext = React.createContext<IODKNodeContext>({\n  node: getEmptyNode(new Set([\"English (en)\"])),\n});\n","import { IconName } from \"@blueprintjs/core\";\n\nexport const typesToIcons: Record<string, IconName> = {\n  integer: \"numerical\",\n  decimal: \"numerical\",\n  range: \"horizontal-distribution\",\n  text: \"edit\",\n  select_one: \"selection\",\n  select_one_from_file: \"selection\",\n  select_multiple: \"multi-select\",\n  select_multiple_from_file: \"multi-select\",\n  rank: \"sort-numerical\",\n  note: \"lightbulb\",\n  geopoint: \"map-marker\",\n  geotrace: \"geofence\",\n  geoshape: \"geofence\",\n  date: \"calendar\",\n  time: \"time\",\n  datetime: \"time\",\n  image: \"media\",\n  audio: \"headset\",\n  video: \"video\",\n  file: \"upload\",\n  barcode: \"barcode\",\n  calculate: \"function\",\n  acknowledge: \"switch\",\n  hidden: \"eye-off\",\n  \"xml-external\": \"layout-hierarchy\",\n  start: \"time\",\n  end: \"time\",\n  today: \"calendar\",\n  deviceid: \"desktop\",\n  simserial: \"sim-card\",\n  subscriberid: \"id-number\",\n  phonenumber: \"phone\",\n  username: \"person\",\n  email: \"envelope\",\n  audit: \"shield\",\n  begin_group: \"group-objects\",\n  begin_repeat: \"repeat\",\n};\n\nexport const fieldTypeNames: Record<string, string> = {\n  integer: \"Integer number\",\n  decimal: \"Decimal number\",\n  range: \"Slider\",\n  text: \"Text field\",\n  select_one: \"Single choice\",\n  select_one_from_file: \"Single choice from file\",\n  select_multiple: \"Multiple choice\",\n  select_multiple_from_file: \"Multiple choice from file\",\n  rank: \"Rank items\",\n  note: \"Note / Hint\",\n  geopoint: \"Locate a point\",\n  geotrace: \"Trace a line\",\n  geoshape: \"Draw a shape\",\n  date: \"Date\",\n  time: \"Time\",\n  datetime: \"Date and time\",\n  image: \"Image\",\n  audio: \"Audio\",\n  video: \"Video\",\n  file: \"File\",\n  barcode: \"Scan a code\",\n  acknowledge: \"Checkbox\",\n  calculate: \"Calculate formula\",\n  hidden: \"Hidden field\",\n  \"xml-external\": \"External XML reference\",\n  start: \"Survey start date and time\",\n  end: \"Survey submission date and time\",\n  today: \"Survey start day\",\n  deviceid: \"Device ID\",\n  simserial: \"SIM serial number\",\n  subscriberid: \"Subscriber ID\",\n  phonenumber: \"Phone number\",\n  username: \"Username\",\n  email: \"Email address\",\n  audit: \"Audit trail\",\n  begin_group: \"Field group\",\n  begin_repeat: \"Repeat group\",\n};\n\nexport const fieldCategoriesToIcons: Record<string, IconName> = {\n  literal: \"edit\",\n  choice: \"selection\",\n  geo: \"globe\",\n  time: \"time\",\n  media: \"upload\",\n  stats: \"scatter-plot\",\n  track: \"person\",\n  special: \"small-minus\",\n  grouping: \"layout-hierarchy\",\n};\n\nexport const fieldCategoryNames: Record<string, string> = {\n  literal: \"Enter value\",\n  choice: \"Choice\",\n  geo: \"Maps\",\n  time: \"Date and time\",\n  media: \"Upload\",\n  special: \"Other\",\n  stats: \"Statistics\",\n  track: \"Personal data\",\n  grouping: \"Grouping\",\n};\n\nexport const fieldTypesToCategories: Record<string, string> = {\n  text: \"literal\",\n  acknowledge: \"literal\",\n  integer: \"literal\",\n  decimal: \"literal\",\n  range: \"literal\",\n  barcode: \"literal\",\n  select_one: \"choice\",\n  select_one_from_file: \"choice\",\n  select_multiple: \"choice\",\n  select_multiple_from_file: \"choice\",\n  rank: \"choice\",\n  geopoint: \"geo\",\n  geotrace: \"geo\",\n  geoshape: \"geo\",\n  date: \"time\",\n  time: \"time\",\n  datetime: \"time\",\n  image: \"media\",\n  audio: \"media\",\n  video: \"media\",\n  file: \"media\",\n  note: \"special\",\n  calculate: \"special\",\n  hidden: \"special\",\n  \"xml-external\": \"special\",\n  start: \"stats\",\n  end: \"stats\",\n  today: \"stats\",\n  deviceid: \"track\",\n  simserial: \"track\",\n  subscriberid: \"track\",\n  phonenumber: \"track\",\n  username: \"track\",\n  email: \"track\",\n  audit: \"track\",\n  begin_group: \"grouping\",\n  begin_repeat: \"grouping\",\n};\n","import { Position, Toaster } from \"@blueprintjs/core\";\n\n/** Singleton toaster instance. Create separate instances for different options. */\nexport const AppToaster = Toaster.create({\n  className: \"recipe-toaster\",\n  position: Position.TOP,\n});\n","import { Alert, Intent } from \"@blueprintjs/core\";\nimport { useCallback, useContext, useState } from \"react\";\nimport { AppToaster } from \"../toaster\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { ODKSurveyContext } from \"./ODKSurveyContext\";\n\nexport default function useNodeDeletionDialog() {\n  const context = useContext(ODKSurveyContext);\n  const [isAlertOpen, setAlertOpen] = useState(false);\n  const [node, setNode] = useState<ODKNode>();\n  const isGroup = node && isGroupNode(node);\n\n  const closeAlert = useCallback(() => {\n    setAlertOpen(false);\n  }, []);\n\n  const removeNode = useCallback(() => {\n    if (!node) {\n      return;\n    }\n    AppToaster.show({\n      intent: \"none\",\n      message: (\n        <>\n          <code>{node.row.name}</code> field removed.\n        </>\n      ),\n    });\n    context.onRemoveRowAndChildren(node);\n    setAlertOpen(false);\n  }, [context, node]);\n\n  const showRemoveConfirmationDialog = useCallback((node: ODKNode) => {\n    setNode(node);\n    setAlertOpen(true);\n  }, []);\n\n  const alert = (\n    <Alert\n      cancelButtonText=\"Cancel\"\n      confirmButtonText=\"Delete\"\n      icon=\"trash\"\n      intent={Intent.DANGER}\n      isOpen={isAlertOpen}\n      onCancel={closeAlert}\n      onConfirm={removeNode}\n      canOutsideClickCancel={true}\n      canEscapeKeyCancel={true}\n    >\n      <p>\n        Are you sure you want to remove the <code>{node?.row.name}</code>{\" \"}\n        {isGroup ? \"group\" : \"field\"}?\n      </p>\n      {isGroup && node?.children.length && (\n        <p>This will also remove the group’s nested fields.</p>\n      )}\n    </Alert>\n  );\n\n  return {\n    showRemoveConfirmationDialog,\n    alert,\n  };\n}\n","import { Menu, MenuItem } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { DependentNodeWithReplacedRow } from \"../../lib/findOrReplaceFieldReferences\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { typesToIcons } from \"../../lib/typesToIcons\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\n\nexport function NodeReferencesMenu(props: {\n  references: DependentNodeWithReplacedRow[];\n}) {\n  const context = React.useContext(ODKSurveyContext);\n\n  return (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">\n          {props.references.length === 1\n            ? \"There is one link\"\n            : `There are ${props.references?.length} links`}{\" \"}\n          to this field.\n        </h6>\n      </li>\n\n      {props.references?.map((reference) => {\n        if (!context.context) {\n          return;\n        }\n        const href = `#//${getNodeAbsolutePathString(\n          reference.node,\n          context.context,\n          \"/\"\n        )}`;\n\n        return (\n          <MenuItem\n            text={<code>{reference.node?.row.name}</code>}\n            icon={typesToIcons[reference.node.type]}\n            href={href}\n          />\n        );\n      })}\n    </Menu>\n  );\n}\n","import {\n  Button,\n  Classes,\n  Dialog,\n  FormGroup,\n  InputGroup,\n  Intent,\n} from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport { NodeReferencesMenu } from \"../survey/DetailsPopover/NodeReferencesMenu\";\nimport { AppToaster } from \"../toaster\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport findOrReplaceFieldReferences, {\n  DependentNodeWithReplacedRow,\n} from \"./findOrReplaceFieldReferences\";\nimport { ODKSurveyContext } from \"./ODKSurveyContext\";\n\nexport default function useRenameNodeDialog() {\n  const context = useContext(ODKSurveyContext);\n  const [isDialogOpen, setDialogOpen] = useState(false);\n  const [node, setNode] = useState<ODKNode>();\n  const [newName, setNewName] = useState<string>(\"\");\n  const [references, setChangedRows] = useState<DependentNodeWithReplacedRow[]>(\n    []\n  );\n\n  useEffect(() => {\n    setNewName(\"\");\n  }, [node?.row.name, node]);\n\n  useEffect(() => {\n    if (context.xlsForm && node) {\n      setChangedRows(\n        findOrReplaceFieldReferences(context.xlsForm, node, newName)\n      );\n    }\n  }, [node?.row.name, node, context.xlsForm, newName]);\n\n  const changeName = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      setNewName(event.currentTarget.value);\n    },\n    []\n  );\n\n  const closeDialog = useCallback(() => {\n    setDialogOpen(false);\n  }, []);\n\n  const renameNode = useCallback(\n    (event: React.FormEvent<HTMLFormElement>) => {\n      event.preventDefault();\n      if (!node) {\n        return;\n      }\n      context.onRenameNode(node, newName);\n      AppToaster.show({\n        intent: \"none\",\n        message: (\n          <>\n            The field has been renamed to ‘<code>{newName}</code>’.\n          </>\n        ),\n      });\n      setDialogOpen(false);\n    },\n    [context, newName, node]\n  );\n\n  const showRenameDialog = useCallback((node: ODKNode) => {\n    setNode(node);\n    setDialogOpen(true);\n  }, []);\n\n  const dependenciesInfo =\n    references.length > 0 ? (\n      <Popover2\n        content={<NodeReferencesMenu references={references} />}\n        lazy={true}\n      >\n        <Button minimal={true} intent=\"primary\">\n          See {references.length} updates…\n        </Button>\n      </Popover2>\n    ) : undefined;\n\n  const isGroup = node && isGroupNode(node);\n\n  const dialog = (\n    <Dialog\n      title={\n        <>\n          Rename ‘<code>{node?.row.name}</code>’ {isGroup ? \"group\" : \"field\"}…\n        </>\n      }\n      icon=\"edit\"\n      isOpen={isDialogOpen}\n      canOutsideClickClose={true}\n      canEscapeKeyClose={true}\n      isCloseButtonShown={true}\n      onClose={closeDialog}\n      lazy={true}\n    >\n      <form onSubmit={renameNode}>\n        <div className={Classes.DIALOG_BODY}>\n          <FormGroup\n            label={`Please enter a new name for this ${\n              isGroup ? \"group\" : \"field\"\n            }:`}\n            labelFor={\"newName\"}\n            style={{ display: \"flex\" }}\n          >\n            <InputGroup\n              id={\"newName\"}\n              placeholder=\"Enter a field name…\"\n              defaultValue={node?.row.name}\n              large={true}\n              onChange={changeName}\n              pattern=\"[\\w\\d_-]+\"\n            />\n          </FormGroup>\n        </div>\n        <div className={Classes.DIALOG_FOOTER}>\n          <div className={Classes.DIALOG_FOOTER_ACTIONS}>\n            <div>{dependenciesInfo}</div>\n            <Button onClick={closeDialog} type=\"button\">\n              Close\n            </Button>\n            <Button\n              intent={Intent.PRIMARY}\n              type=\"submit\"\n              disabled={newName === \"\"}\n            >\n              Rename\n            </Button>\n          </div>\n        </div>\n      </form>\n    </Dialog>\n  );\n\n  return {\n    showRenameDialog,\n    dialog,\n  };\n}\n","import * as React from \"react\";\nimport ODKFormulaEvaluationContext from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeAbsolutePathString } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { assertValidQuestionRow } from \"../xlsform-simple-schema/types/RowTypes\";\n\nexport type DropNodeHandler = (options: {\n  sourceNode: ODKNode;\n  destinationNode: ODKNode;\n  sourcePath: string;\n  position: \"before\" | \"after\" | \"inside\";\n}) => void;\n\nexport const ODKNodeDragAndDropContext = React.createContext<{\n  onDropNode: DropNodeHandler;\n}>({ onDropNode: () => {} });\n\nfunction assertIsODKNode(node: any): asserts node is ODKNode {\n  const error = () => {\n    throw new Error(\"Given data is not a valid ODK node.\");\n  };\n  if (typeof node !== \"object\") {\n    error();\n  }\n\n  assertValidQuestionRow(node.row);\n  if (\n    typeof node.type !== \"string\" ||\n    !(node.typeParameters instanceof Array) ||\n    !node.typeParameters.every((p: unknown) => typeof p === \"string\") ||\n    typeof node.indentationLevel !== \"number\" ||\n    typeof node.rowIndex !== \"number\" ||\n    (node.resultIsInvalid !== undefined &&\n      typeof node.resultIsInvalid !== \"boolean\")\n  ) {\n    error();\n  }\n  node.children.forEach(assertIsODKNode);\n}\n\nexport function useNodeDragAndDrop({\n  context,\n  node,\n  setIsDraggedOver,\n}: {\n  context?: ODKFormulaEvaluationContext;\n  node: ODKNode;\n  setIsDraggedOver: React.Dispatch<React.SetStateAction<boolean>>;\n}) {\n  const { onDropNode } = React.useContext(ODKNodeDragAndDropContext);\n  const onDragStart = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      if (!context) {\n        return;\n      }\n      event.dataTransfer.setData(\n        \"application/json\",\n        JSON.stringify({\n          sourceNode: node,\n          sourcePath: getNodeAbsolutePathString(node, context),\n        })\n      );\n    },\n    [context, node]\n  );\n\n  const onDragOver = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      event.preventDefault();\n      if (!context) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const data = event.dataTransfer.getData(\"application/json\");\n      setIsDraggedOver(true);\n    },\n    [context, setIsDraggedOver]\n  );\n\n  const onDrop = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      if (!context) {\n        return;\n      }\n      const path = getNodeAbsolutePathString(node, context);\n      const data = JSON.parse(event.dataTransfer.getData(\"application/json\"));\n      const { sourcePath, sourceNode } = data;\n      assertIsODKNode(sourceNode);\n      console.log(\"Dropped on path\", path);\n      setIsDraggedOver(false);\n      onDropNode({\n        sourceNode,\n        sourcePath,\n        destinationNode: node,\n        position: \"before\",\n      });\n    },\n    [context, node, onDropNode, setIsDraggedOver]\n  );\n\n  const onDragLeave = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      if (!context) {\n        return;\n      }\n      const path = getNodeAbsolutePathString(node, context);\n      console.log(\"Left dragging at path\", path);\n      setIsDraggedOver(false);\n    },\n    [context, node, setIsDraggedOver]\n  );\n\n  const dragProps = {\n    draggable: true,\n    onDragStart,\n    onDragOver,\n    onDragLeave,\n    onDrop,\n  };\n\n  return dragProps;\n}\n","import { Classes, Colors } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport styled, { CSSProperties } from \"styled-components\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport DetailsPopover from \"../../survey/DetailsPopover/DetailsPopover\";\nimport {\n  findNodeByNameInCurrentAndAncestorScopes,\n  findNodeByNameInsideScope,\n} from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  Expression,\n  NameExpression,\n  Token,\n  TokenType,\n} from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport { EvaluationError } from \"../../xlsform-simple-schema/types/Errors\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\n\nconst StyledCode = styled.code`\n  font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n    \"Courier New\", monospace;\n\n  .expression.has-error {\n    text-decoration: underline wavy ${Colors.RED2};\n    text-decoration-skip: none;\n    text-decoration-skip-ink: none;\n    text-decoration-color: ${Colors.RED2} !important;\n\n    a {\n      text-decoration: underline wavy ${Colors.RED2};\n      text-decoration-skip: none;\n      text-decoration-skip-ink: none;\n      text-decoration-color: ${Colors.RED2} !important;\n    }\n  }\n\n  .expression-name {\n    color: ${Colors.GREEN3};\n  }\n\n  &.expression-call > .expression-name:first-child,\n  .expression-call > .expression-name:first-child {\n    color: ${Colors.BLUE3};\n  }\n\n  .expression-name {\n    word-break: break-word;\n  }\n\n  .token-STRING_LITERAL {\n    color: ${Colors.ORANGE3};\n  }\n\n  .token-NUMBER_LITERAL {\n    color: ${Colors.ORANGE4};\n  }\n\n  .token-COMMA {\n    color: ${Colors.GRAY1};\n  }\n\n  .token-LEFT_PAREN,\n  .token-RIGHT_PAREN {\n    color: ${Colors.BLUE2};\n    font-weight: bold;\n  }\n\n  .token-INVALID {\n    border: 2px ${Colors.RED5} solid;\n    padding: 2px;\n    margin: -2px;\n    color: ${Colors.RED5};\n  }\n\n  .token-COMMA::after {\n    content: \" \";\n  }\n\n  .expression-operator {\n    clear: left;\n  }\n\n  .token-COMPARISON {\n    &::after,\n    &::before {\n      content: \" \";\n    }\n    font-weight: bold;\n    color: ${Colors.RED2};\n  }\n\n  .token-COLON,\n  .token-BOOLEAN_AND,\n  .token-BOOLEAN_OR,\n  .token-PLUS,\n  .token-GREATER_THAN,\n  .token-LESS_THAN,\n  .token-MODULO,\n  .token-QUESTION {\n    word-break: break-word;\n    display: block;\n    font-weight: bold;\n    color: ${Colors.RED2};\n  }\n`;\n\nfunction TokenElement({\n  token,\n  expression,\n  parentExpression,\n  node,\n}: {\n  token: Token;\n  expression?: Expression;\n  parentExpression?: Expression;\n  node: ODKNode;\n}) {\n  const className = `token token-${TokenType[token.type]}`;\n  const context = React.useContext(ODKSurveyContext);\n  if (\n    token.type === TokenType.NAME &&\n    parentExpression?.kind === \"call\" &&\n    expression instanceof NameExpression &&\n    token === parentExpression.tokens[0]\n  ) {\n    return (\n      <a\n        href={`https://getodk.github.io/xforms-spec/#fn:${token.text}`}\n        className={className}\n        target=\"docs\"\n      >\n        {token.text}\n      </a>\n    );\n  } else if (\n    token.type === TokenType.NAME &&\n    expression instanceof NameExpression &&\n    token.text.startsWith(\"$\") &&\n    context.context\n  ) {\n    const referencedNode =\n      findNodeByNameInCurrentAndAncestorScopes(\n        expression.name,\n        context.context,\n        node\n      ) ||\n      findNodeByNameInsideScope(\n        expression.name,\n        context.context,\n        context.context.survey\n      );\n    if (!referencedNode || referencedNode instanceof Array) {\n      debugger;\n      return (\n        <var className={className} data-referenced-node={referencedNode}>\n          {token.text}\n        </var>\n      );\n    }\n    return (\n      <var>\n        {\"${\"}\n        <DetailsPopover\n          node={referencedNode}\n          editable={false}\n          nameOfOnlyShownTab={\"calculation\"}\n        />\n        {\"}\"}\n      </var>\n    );\n  }\n  return <span className={className}>{token.text}</span>;\n}\n\nexport function InvalidExpression(props: {\n  code?: string;\n  className?: string;\n  style?: CSSProperties;\n  tokens?: Token[];\n  node: ODKNode;\n}) {\n  if (!props.tokens) {\n    return (\n      <StyledCode\n        style={props.style}\n        className={`${props.className || \"\"} expression expression-invalid`}\n      >\n        {props.code}\n      </StyledCode>\n    );\n  }\n\n  const lastToken = props.tokens[props.tokens.length - 1];\n  const indexAfterLastToken = lastToken.index + lastToken.text.length;\n  return (\n    <StyledCode\n      style={props.style}\n      className={`${props.className || \"\"} expression expression-invalid`}\n    >\n      {props.tokens.map((token) => (\n        <TokenElement token={token} key={token.index} node={props.node} />\n      ))}\n      <span className={Classes.TEXT_DISABLED}>\n        {props.code?.slice(indexAfterLastToken)}\n      </span>\n    </StyledCode>\n  );\n}\n\nexport default function HighlightedExpression(props: {\n  code?: string;\n  state?: \"error\" | \"success\";\n  error?: Error;\n  expression?: Expression;\n  parentExpression?: Expression;\n  className?: string;\n  style?: CSSProperties;\n  tokens?: Token[];\n  node: ODKNode;\n}) {\n  if (!props.expression) {\n    return <InvalidExpression {...props} />;\n  }\n  const isErroneousExpression =\n    props.error instanceof EvaluationError &&\n    props.error.expression === props.expression;\n\n  return (\n    <StyledCode\n      style={props.style}\n      className={`${props.className || \"\"} expression expression-${\n        props.expression.kind\n      } ${isErroneousExpression ? \"has-error\" : \"\"}`}\n    >\n      {props.expression.children.map((expressionOrToken, i) => {\n        if (expressionOrToken instanceof Expression) {\n          return (\n            <HighlightedExpression\n              code={expressionOrToken.tokens.map((t) => t.text).join(\"\")}\n              expression={expressionOrToken}\n              parentExpression={props.expression}\n              tokens={expressionOrToken.tokens}\n              error={props.error}\n              node={props.node}\n            />\n          );\n        } else {\n          return (\n            <TokenElement\n              token={expressionOrToken}\n              key={expressionOrToken.index}\n              expression={props.expression}\n              parentExpression={props.parentExpression}\n              node={props.node}\n            />\n          );\n        }\n      })}\n    </StyledCode>\n  );\n}\n","/**\n * Removes first level of whitespace indentation from a given string by recognizing the indentation\n * level from the first line that has non-whitespace content contains  to remove.\n *\n * This allows to specify hardcoded strings with indentation in code without having to break the\n * code's own indentation:\n *\n * @example\n *   // before:\n *   function getMarkdown() {\n *     return `\n *   # Hello\n *\n *   - this is a markdown list\n *   - with multiple items\n *   `;\n *   }\n *\n *   // with unindent:\n *   function getMarkdown() {\n *     return unindent(`\n *       # Hello\n *\n *       - this is a markdown list\n *       - with multiple items\n *     `);\n *   }\n*/\nexport default function unindent(input: string): string {\n  const firstLineWithContent = input\n    .split(/\\n/)\n    .find(line => line.replace(/\\s/, '').length > 0);\n  if (!firstLineWithContent) {\n    return input;\n  }\n\n  const matchedIndentation = firstLineWithContent.match(/^\\s+/);\n  if (!matchedIndentation) {\n    return input;\n  }\n\n  const matchedIndentationString = matchedIndentation[0];\n  if (!matchedIndentationString) {\n    return input;\n  }\n\n  const indentationRegExp = new RegExp(`^${matchedIndentationString}`);\n  return input\n    .split(/\\n/)\n    .map(line => line.replace(indentationRegExp, ''))\n    .join('\\n');\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport { omit } from \"lodash\";\nimport * as React from \"react\";\nimport unindent from \"./unindent\";\nimport marked from \"marked\";\n\ninterface IProps extends React.HTMLProps<HTMLDivElement> {\n  children: React.ReactNode;\n  marked: (markdown: string) => string;\n}\n\nfunction MarkdownDiv(props: IProps) {\n  if (typeof props.children !== \"string\") {\n    return (\n      <Callout intent=\"danger\">Markdown content must be a string.</Callout>\n    );\n  }\n  return (\n    <div\n      {...omit(props, \"children\", \"marked\")}\n      dangerouslySetInnerHTML={{\n        __html: props.marked?.(unindent(props.children)),\n      }}\n    />\n  );\n}\n\n// const Markdown = LoadableMap({\n//   loader: {\n//     marked: () => import(\"marked\"),\n//   },\n//   render(loaded, props: IProps) {\n//     return <MarkdownDiv {...props} marked={loaded.marked?.default} />;\n//   },\n//   loading: () => null,\n// });\n\nfunction Markdown(props: { children: React.ReactNode }) {\n  return <MarkdownDiv {...props} marked={marked} />;\n}\n\nexport default Markdown;\n","import { Colors } from \"@blueprintjs/core\";\nimport styled from \"styled-components\";\nimport Markdown from \"./Markdown\";\n\nconst StyledMarkdown = styled(Markdown)`\n  h1,\n  h2,\n  h3,\n  h4,\n  h5 {\n    margin: 1em 0;\n  }\n\n  code,\n  pre {\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n    color: ${Colors.DARK_GRAY1};\n    /* border: 1px solid rgba(0, 0, 0, 0.2); */\n    margin: -1px;\n    padding: 2px 3px;\n    background-color: rgba(255, 255, 255, 0.3);\n  }\n\n  pre {\n    padding: 0.5em 0.55em;\n    margin: 0.5em 0;\n    line-height: 1.3em;\n    background: white;\n    white-space: pre-wrap;\n  }\n\n  code {\n    font-weight: 600;\n  }\n\n  p {\n    margin-block-end: 16px;\n  }\n  p:last-child {\n    margin-block-end: 0;\n  }\n\n  ul,\n  ol {\n    margin: 1em 1.25em;\n  }\n`;\n\nexport default StyledMarkdown;\n","import { Classes, Text } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { EvaluatableColumnName } from \"../../xlsform-simple-schema/types/ODKNode\";\n\nexport function DefaultValueExplanation({\n  answer,\n  columnName,\n  nodeName,\n}: {\n  answer: unknown;\n  columnName: EvaluatableColumnName;\n  nodeName: string;\n}) {\n  return (\n    <Text className={Classes.TEXT_MUTED}>\n      {\n        {\n          calculation:\n            answer === undefined || answer === \"\" ? (\n              <>\n                This survey field has no entered answer yet, and the{\" \"}\n                <code>{columnName}</code> cell is empty.\n              </>\n            ) : (\n              <>\n                This is the answer value entered in the <code>{nodeName}</code>{\" \"}\n                field.\n              </>\n            ),\n          required: (\n            <>\n              This means users are not required to enter this field. This is the\n              default when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          relevant: (\n            <>\n              This means the survey field is always shown. This is the default\n              behavior when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          readonly: (\n            <>\n              This means the survey field enables input. This is the default\n              behavior when the <code>{columnName}</code> cell is empty.\n            </>\n          ),\n          constraint: (\n            <>\n              If the cell contains a formula that evaluates to <code>true</code>{\" \"}\n              or if there is no formula in the <code>{columnName}</code> cell,\n              the field accepts any input.\n            </>\n          ),\n        }[columnName]\n      }\n    </Text>\n  );\n}\n","import { Classes, Text } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { EvaluatableColumnName } from \"../../xlsform-simple-schema/types/ODKNode\";\n\nexport function FormulaResultMeaning({\n  results,\n  columnName,\n}: {\n  results: ODKFormulaEvaluationResult;\n  columnName: EvaluatableColumnName;\n}) {\n  return (\n    <Text className={Classes.TEXT_MUTED}>\n      {\n        {\n          calculation: <>This is the result of the formula.</>,\n          required: `This means you ${\n            results?.result ? \"can’t\" : \"can\"\n          } complete the survey without entering data in this field.`,\n          relevant: `This means the survey field is ${\n            results?.result ? \"shown\" : \"hidden\"\n          }.`,\n          readonly: `This means the survey field is ${\n            results?.result ? \"read-only\" : \"editable\"\n          }.`,\n          constraint: `This means the survey field contains an input that is ${\n            results?.result ? \"allowed\" : \"not allowed\"\n          } by the constraint formula..`,\n        }[columnName]\n      }\n    </Text>\n  );\n}\n","import { Callout, Colors, Icon } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport HighlightedExpression from \"../../components/expression/HighlightedExpression\";\nimport StyledMarkdown from \"../../components/StyledMarkdown\";\nimport { alpha } from \"../../lib/colors\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { getNodeAbsolutePathString } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { NameExpression } from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base\";\nimport LiteralExpression from \"../../xlsform-simple-schema/functions/odk-formulas/pratt-parser-base/expressions/LiteralExpression\";\nimport { EvaluationError } from \"../../xlsform-simple-schema/types/Errors\";\nimport {\n  EvaluatableColumnName,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { DefaultValueExplanation } from \"./DefaultValueExplanation\";\nimport {\n  StyledCalloutWithCode,\n  StyledCodeBlock,\n  StyledPanel,\n} from \"./DetailsPopover\";\nimport { FormulaResultMeaning } from \"./FormulaResultMeaning\";\n\nexport function ExpressionPanel({\n  node,\n  columnName,\n  nodeEvaluationResults,\n  style,\n}: {\n  node: ODKNode;\n  columnName: EvaluatableColumnName;\n  nodeEvaluationResults: Map<string, ODKFormulaEvaluationResult> | undefined;\n  style?: React.CSSProperties;\n}) {\n  const context = React.useContext(ODKSurveyContext);\n  const cellValue = node.row[columnName];\n  const results = nodeEvaluationResults?.get(columnName);\n  const cellIsEmpty = cellValue === undefined;\n  const isLiteral = results?.expression?.kind === \"literal\";\n  const isName = results?.expression?.kind === \"name\";\n  const answer = context.context?.nodesToAnswers.get(node);\n  const nodeName = context.context\n    ? getNodeAbsolutePathString(node, context.context)\n    : node.row.name;\n\n  const formulaIsTrivial =\n    results?.expression instanceof LiteralExpression ||\n    (results?.expression instanceof NameExpression &&\n      results?.expression.name === results?.expression.text);\n\n  let title: React.ReactNode = \"Result\";\n  if (cellIsEmpty) {\n    if (columnName === \"calculation\") {\n      if (answer !== undefined) {\n        title = \"Using answer value\";\n      }\n    } else {\n      title = \"Default value\";\n    }\n  } else {\n    title = (\n      <>\n        <Icon icon=\"function\" />{\" \"}\n        {columnName === \"calculation\" ? \"Formula\" : \"Condition\"}\n      </>\n    );\n  }\n  const panel = (\n    <StyledPanel\n      lang=\"en\"\n      style={{\n        backgroundColor: Colors.LIGHT_GRAY5,\n        marginTop: \"0\",\n        padding: \"20px\",\n        background: `linear-gradient(${alpha(Colors.BLUE3, 0.06)}, ${alpha(\n          Colors.BLUE3,\n          0.05\n        )} 5px, ${alpha(Colors.BLUE3, 0.01)} 10px, transparent 30px)`,\n        borderTop: `solid 1px ${Colors.LIGHT_GRAY3}`,\n        ...style,\n      }}\n    >\n      <h4>{title}</h4>\n      {!cellIsEmpty && (\n        <>\n          <StyledCodeBlock\n            style={{\n              fontSize: isLiteral || isName ? \"20px\" : \"16px\",\n              lineHeight: \"28px\",\n            }}\n          >\n            <HighlightedExpression\n              node={node}\n              state={results?.state}\n              error={results?.error}\n              expression={results?.expression}\n              code={String(cellValue)}\n              tokens={results?.parser?.tokens}\n            />\n          </StyledCodeBlock>\n        </>\n      )}\n\n      {(cellIsEmpty || !formulaIsTrivial) && (\n        <>\n          {!cellIsEmpty && !results && (\n            <Callout intent=\"none\">Not calculated yet.</Callout>\n          )}\n          {results?.state !== \"error\" && (\n            <StyledCodeBlock style={{ fontSize: \"20px\", lineHeight: \"28px\" }}>\n              {results?.result === undefined\n                ? \"undefined\"\n                : JSON.stringify(results.result)}\n            </StyledCodeBlock>\n          )}\n        </>\n      )}\n\n      {results?.state === \"error\" && (\n        <StyledCalloutWithCode intent=\"danger\">\n          {results.error instanceof EvaluationError && (\n            <>\n              Error in&nbsp;\n              <code>\n                <HighlightedExpression\n                  node={node}\n                  expression={results.error.expression}\n                />\n              </code>\n              :\n            </>\n          )}\n          <StyledMarkdown>{results.error.toMarkdown()}</StyledMarkdown>\n        </StyledCalloutWithCode>\n      )}\n\n      {!cellIsEmpty && results?.result !== undefined && (\n        <FormulaResultMeaning {...{ results, columnName }} />\n      )}\n\n      {cellIsEmpty && (\n        <DefaultValueExplanation {...{ answer, columnName, nodeName }} />\n      )}\n    </StyledPanel>\n  );\n  return panel;\n}\n","import {\n  Callout,\n  Checkbox,\n  Classes,\n  Code,\n  ControlGroup,\n  Menu,\n  Text,\n} from \"@blueprintjs/core\";\nimport { sortBy, without } from \"lodash\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { XLSForm } from \"../../xlsform-simple-schema\";\nimport { ODKNode } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { QuestionRow } from \"../../xlsform-simple-schema/types/RowTypes\";\n\nexport function ChoiceListMenu({\n  xlsForm,\n  node,\n}: {\n  xlsForm: XLSForm;\n  node: ODKNode;\n}) {\n  const choiceListsByName = xlsForm?.choicesByName;\n  const choiceListNames = choiceListsByName\n    ? Object.keys(choiceListsByName)\n    : [];\n  const context = React.useContext(ODKSurveyContext);\n\n  const onChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const checked = event.currentTarget.checked;\n      const choiceListName = event.currentTarget.value;\n      let typeParameters = [...node.typeParameters];\n      if (checked) {\n        typeParameters.push(choiceListName);\n      } else {\n        typeParameters = without(typeParameters, choiceListName);\n      }\n      const newTypeValue = [node.type, ...typeParameters].join(\" \");\n      const newRow: QuestionRow = {\n        ...node.row,\n        type: newTypeValue,\n      };\n      context.onSpliceRows(\"survey\", [\n        {\n          rowIndex: node.rowIndex,\n          numberOfRowsToRemove: 1,\n          rowsToAdd: [newRow],\n        },\n      ]);\n    },\n    [context, node]\n  );\n\n  const choiceListMenu = (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">\n          Set which choice lists should be visible.\n        </h6>\n      </li>\n      <ControlGroup style={{ margin: \"16px 8px 4px\" }} vertical={true}>\n        {choiceListNames.map((listName) => {\n          const isSelected = node.typeParameters.includes(listName);\n          const nameElement = listName;\n          const choiceNamesToRows = choiceListsByName[listName];\n          const choiceNames = Object.keys(choiceNamesToRows);\n\n          const sortedChoiceRows = sortBy(\n            choiceNames.map((n) => choiceNamesToRows[n]),\n            (r) => r.name.toLowerCase()\n          );\n\n          const maxChoicesCount = 4;\n          const shownChoices = sortedChoiceRows\n            .slice(0, maxChoicesCount)\n            .map((row) => (\n              <li>\n                <Code\n                  key={row.name}\n                  style={{\n                    marginInline: \"1px\",\n                  }}\n                >\n                  {row.name}\n                </Code>\n              </li>\n            ));\n          const restElement = sortedChoiceRows.length > maxChoicesCount && (\n            <span\n              className={Classes.UI_TEXT}\n              style={{\n                lineHeight: \"24px\",\n                marginLeft: \"4px\",\n                paddingRight: \"2px\",\n              }}\n              aria-label={`and ${\n                sortedChoiceRows.length - maxChoicesCount\n              } more`}\n            >\n              + {sortedChoiceRows.length - maxChoicesCount}\n            </span>\n          );\n          const shownLabel = (\n            <ControlGroup fill={true} style={{ display: \"inline-flex\" }}>\n              <header aria-label={`Choice list ${listName}, allowed values:`}>\n                <Text>{nameElement}</Text>\n              </header>\n              <ul className={Classes.LIST_UNSTYLED}>\n                <ControlGroup\n                  style={{\n                    justifyContent: \"flex-end\",\n                    marginLeft: \"16px\",\n                  }}\n                >\n                  {shownChoices}\n                  {restElement}\n                </ControlGroup>\n              </ul>\n            </ControlGroup>\n          );\n\n          return (\n            <Checkbox\n              value={listName}\n              onChange={onChange}\n              large={true}\n              checked={isSelected}\n              disabled={\n                node.typeParameters.length === 1 &&\n                listName === node.typeParameters[0]\n              }\n            >\n              {shownLabel}\n            </Checkbox>\n          );\n        })}\n      </ControlGroup>\n\n      <Callout intent=\"primary\">\n        The content of these lists is defined in the <code>choices</code> Excel\n        sheet.\n      </Callout>\n    </Menu>\n  );\n  return choiceListMenu;\n}\n","import { Menu, MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport {\n  fieldCategoriesToIcons,\n  fieldCategoryNames,\n  fieldTypeNames,\n  fieldTypesToCategories,\n  typesToIcons,\n} from \"../../lib/typesToIcons\";\nimport { QuestionRow } from \"../../xlsform-simple-schema/types/RowTypes\";\n\nexport function FieldTypeMenu() {\n  const context = React.useContext(ODKSurveyContext);\n  const { node } = React.useContext(ODKNodeContext);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLElement>) => {\n      const type = event.currentTarget.dataset.type;\n      const typeParameters = type?.match(/^select/) ? node.typeParameters : [];\n      const newTypeValue = [type, ...typeParameters].join(\" \");\n      const newRow: QuestionRow = {\n        ...node.row,\n        type: newTypeValue,\n      };\n      context.onSpliceRows(\"survey\", [\n        {\n          rowIndex: node.rowIndex,\n          numberOfRowsToRemove: 1,\n          rowsToAdd: [newRow],\n        },\n      ]);\n    },\n    [context, node]\n  );\n\n  return (\n    <Menu>\n      <li className=\"bp3-menu-header\">\n        <h6 className=\"bp3-heading\">Set a field type.</h6>\n      </li>\n\n      {Object.keys(fieldCategoriesToIcons)\n        .filter((c) => c !== \"special\" && c !== \"grouping\")\n        .map((category) => (\n          <MenuItem\n            text={fieldCategoryNames[category]}\n            icon={fieldCategoriesToIcons[category]}\n          >\n            {Object.keys(fieldTypesToCategories)\n              .filter((t) => fieldTypesToCategories[t] === category)\n              .map((type) => (\n                <MenuItem\n                  text={fieldTypeNames[type]}\n                  icon={typesToIcons[type]}\n                  onClick={onClick}\n                  data-type={type}\n                />\n              ))}\n          </MenuItem>\n        ))}\n\n      <MenuDivider />\n\n      {Object.keys(fieldTypesToCategories)\n        .filter((t) => fieldTypesToCategories[t] === \"special\")\n        .map((type) => (\n          <MenuItem\n            text={fieldTypeNames[type]}\n            icon={typesToIcons[type]}\n            onClick={onClick}\n            data-type={type}\n          />\n        ))}\n    </Menu>\n  );\n}\n","import {\n  Boundary,\n  Button,\n  ButtonGroup,\n  Classes,\n  Code,\n  Icon,\n  OverflowList,\n} from \"@blueprintjs/core\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { fieldTypeNames, typesToIcons } from \"../../lib/typesToIcons\";\nimport {\n  isGroupNode,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { ChoiceListMenu } from \"./ChoiceListMenu\";\nimport { FieldTypeMenu } from \"./FieldTypeMenu\";\nimport { NoChoicesState } from \"./NoChoicesState\";\n\nexport function FieldConfigurationButton({\n  node,\n  showType,\n}: {\n  node: ODKNode;\n  showType: boolean;\n}) {\n  const isGroup = isGroupNode(node);\n  const context = React.useContext(ODKSurveyContext);\n  const { xlsForm } = context;\n  const surveyHasChoiceLists =\n    !!xlsForm && Object.keys(xlsForm?.choicesByName).length > 0;\n  const choiceListMenu = xlsForm && (\n    <ChoiceListMenu xlsForm={xlsForm} node={node} />\n  );\n  const noChoicesAvailable = NoChoicesState();\n  const typeName = fieldTypeNames[node.type];\n  const icon = typesToIcons[node.type];\n  const hasItems = node.typeParameters.length > 0;\n\n  if (isGroup)\n    return (\n      <span\n        className={[Classes.TEXT_MUTED].join(\" \")}\n        style={{ alignSelf: \"center\", marginLeft: \"8px\" }}\n      >\n        <Icon icon={icon} />\n        &nbsp;{typeName}\n      </span>\n    );\n\n  return (\n    <ButtonGroup>\n      {showType && (\n        <Popover2 content={<FieldTypeMenu />} lazy={true}>\n          <Button\n            icon={icon || \"blank\"}\n            fill={false}\n            minimal={true}\n            // rightIcon={\"caret-down\"}\n          >\n            {typeName}\n          </Button>\n        </Popover2>\n      )}\n\n      {node.type.match(/^select/) && (\n        <Popover2\n          lazy={true}\n          content={surveyHasChoiceLists ? choiceListMenu : noChoicesAvailable}\n        >\n          <Button\n            fill={true}\n            minimal={true}\n            // rightIcon={\"caret-down\"}\n            intent={hasItems ? \"none\" : \"warning\"}\n          >\n            {!hasItems && \"Set visible choices\"}\n            {hasItems && (\n              <OverflowList\n                observeParents={true}\n                minVisibleItems={2}\n                collapseFrom={Boundary.END}\n                items={node.typeParameters}\n                visibleItemRenderer={(p) => <Code>{p}</Code>}\n                overflowRenderer={(overflowItems) => (\n                  <span>{`+ ${overflowItems.length}`}</span>\n                )}\n                style={{\n                  transition: \"width 0.1s ease-out\",\n                  maxWidth: `200px`,\n                }}\n              />\n            )}\n          </Button>\n        </Popover2>\n      )}\n    </ButtonGroup>\n  );\n}\n","import { Button, ControlGroup, NonIdealState } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { createLabelInAllLanguages } from \"../../lib/createLabelInAllLanguages\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { ChoiceRow } from \"../../xlsform-simple-schema/types/RowTypes\";\n\nexport function NoChoicesState() {\n  const context = React.useContext(ODKSurveyContext);\n\n  const addExampleChoices = React.useCallback(() => {\n    const languages = context.xlsForm?.languages || new Set([\"English (en)\"]);\n    const choiceRows: ChoiceRow[] = [\n      {\n        \"list name\": \"yes_no_maybe\",\n        name: \"yes\",\n        label: createLabelInAllLanguages(\"yes\", languages),\n      },\n      {\n        \"list name\": \"yes_no_maybe\",\n        name: \"no\",\n        label: createLabelInAllLanguages(\"no\", languages),\n      },\n      {\n        \"list name\": \"yes_no_maybe\",\n        name: \"maybe\",\n        label: createLabelInAllLanguages(\"maybe\", languages),\n      },\n    ];\n    context.onSpliceRows(\"choices\", [\n      {\n        rowIndex: 0,\n        numberOfRowsToRemove: 0,\n        rowsToAdd: choiceRows,\n      },\n    ]);\n  }, [context]);\n\n  const addExampleChoicesButton = (\n    <Button large={true} intent=\"primary\" onClick={addExampleChoices}>\n      Create example choice list\n    </Button>\n  );\n\n  return (\n    <ControlGroup style={{ padding: \"16px\" }}>\n      <NonIdealState\n        icon=\"selection\"\n        action={addExampleChoicesButton}\n        title=\"Sometimes, we have no choice.\"\n        description={\n          <>\n            This survey has no choice lists yet. Please add one first to make it\n            available for this survey question.\n          </>\n        }\n      />\n    </ControlGroup>\n  );\n}\n","import { Breadcrumbs } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\nexport function FieldPathBreadcrumbs({\n  path,\n  width,\n}: {\n  path: string[];\n  width: number;\n}) {\n  return (\n    <Breadcrumbs\n      items={path.map((k, i) => ({\n        href: `#//${path.slice(0, i + 1).join(\"/\")}`,\n        text: k,\n      }))}\n      collapseFrom=\"start\"\n      overflowListProps={{\n        minVisibleItems: 1,\n        style: {\n          transition: \"width 0.1s ease-out\",\n          width: `${width}px`,\n        },\n      }}\n    />\n  );\n}\n","import { Code, IconName, MenuItem } from \"@blueprintjs/core\";\nimport { useCallback, useContext } from \"react\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\n\nexport default function AddFieldOrGroupMenuItem({\n  node,\n  position,\n  icon,\n  group,\n  omitAction,\n}: {\n  node: ODKNode;\n  position: \"before\" | \"after\" | \"inside\";\n  icon?: IconName;\n  group: boolean;\n  omitAction?: boolean;\n}) {\n  const context = useContext(ODKSurveyContext);\n\n  const caption = (\n    <>\n      {omitAction ? null : `Add ${group ? \"group\" : \"field\"}`} {position}{\" \"}\n      <Code>{node.row.name}</Code>\n    </>\n  );\n\n  const onClick = useCallback(() => {\n    context.onAddNode({ position, node, group });\n  }, [context, group, node, position]);\n\n  return (\n    <MenuItem\n      icon={icon}\n      // intent=\"primary\"\n      onClick={onClick}\n      text={caption}\n    />\n  );\n}\n","import { MenuDivider, MenuItem } from \"@blueprintjs/core\";\nimport { useCallback } from \"react\";\nimport {\n  isGroupNode,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport AddFieldOrGroupMenuItem from \"../AddFieldMenuItem\";\n\nexport default function NodeActionMenuItems({\n  node,\n  onRemove,\n  onRename,\n  onNestField,\n  onUngroupField,\n}: {\n  node: ODKNode;\n  onRemove: (node: ODKNode) => void;\n  onRename: (node: ODKNode) => void;\n  onNestField: (node: ODKNode) => void;\n  onUngroupField: (node: ODKNode) => void;\n}) {\n  const removeNode = useCallback(() => {\n    onRemove(node);\n  }, [node, onRemove]);\n\n  const renameNode = useCallback(() => {\n    onRename(node);\n  }, [node, onRename]);\n\n  const nestField = useCallback(() => {\n    onNestField(node);\n  }, [node, onNestField]);\n\n  const ungroupField = useCallback(() => {\n    onUngroupField(node);\n  }, [node, onUngroupField]);\n\n  const isGroup = isGroupNode(node);\n  const renameText = isGroup ? \"Rename group…\" : \"Rename field…\";\n  const items = (\n    <>\n      <MenuItem icon=\"edit\" text={renameText} onClick={renameNode} />\n\n      <MenuDivider />\n\n      <MenuItem icon=\"group-objects\" text=\"Add group\">\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"before\"\n          icon=\"arrow-up\"\n          group={true}\n          omitAction={true}\n        />\n        {isGroup && (\n          <AddFieldOrGroupMenuItem\n            node={node}\n            position=\"inside\"\n            icon=\"key-enter\"\n            group={true}\n            omitAction={true}\n          />\n        )}\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"after\"\n          icon=\"arrow-down\"\n          group={true}\n          omitAction={true}\n        />\n      </MenuItem>\n\n      <MenuItem icon=\"manually-entered-data\" text=\"Add field\">\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"before\"\n          icon=\"arrow-up\"\n          group={false}\n          omitAction={true}\n        />\n        {isGroup && (\n          <AddFieldOrGroupMenuItem\n            node={node}\n            position=\"inside\"\n            icon=\"key-enter\"\n            group={false}\n            omitAction={true}\n          />\n        )}\n        <AddFieldOrGroupMenuItem\n          node={node}\n          position=\"after\"\n          icon=\"arrow-down\"\n          group={false}\n          omitAction={true}\n        />\n      </MenuItem>\n\n      <MenuDivider />\n\n      <MenuItem\n        icon=\"group-objects\"\n        text=\"Nest in new group\"\n        onClick={nestField}\n      />\n      {isGroup && (\n        <MenuItem\n          icon=\"ungroup-objects\"\n          text=\"Ungroup\"\n          onClick={ungroupField}\n        />\n      )}\n\n      <MenuDivider />\n\n      <MenuItem\n        intent=\"danger\"\n        icon=\"trash\"\n        text={`Remove ${isGroup ? \"group\" : \"field\"}…`}\n        onClick={removeNode}\n      />\n    </>\n  );\n\n  return items;\n}\n","import {\n  Button,\n  ButtonGroup,\n  Callout,\n  Classes,\n  Code,\n  Colors,\n  ControlGroup,\n  HTMLDivProps,\n  Icon,\n  IResizeEntry,\n  Menu,\n  ResizeSensor,\n  Tab,\n  Tabs,\n} from \"@blueprintjs/core\";\nimport { Classes as PopoverClasses, Popover2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport { alpha } from \"../../lib/colors\";\nimport findOrReplaceFieldReferences, {\n  DependentNodeWithReplacedRow,\n} from \"../../lib/findOrReplaceFieldReferences\";\nimport { getFirstColumnNameWithError } from \"../../lib/getFirstColumnNameWithError\";\nimport { ODKNodeContext } from \"../../lib/ODKNodeContext\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { typesToIcons } from \"../../lib/typesToIcons\";\nimport useNodeDeletionDialog from \"../../lib/useNodeDeletionDialog\";\nimport useRenameNodeDialog from \"../../lib/useRenameNodeDialog\";\nimport ODKFormulaEvaluationResult from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationResult\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  EvaluatableColumnName,\n  evaluatableColumnNames,\n  isNodeRelevant,\n  ODKNode,\n} from \"../../xlsform-simple-schema/types/ODKNode\";\nimport { useNodeDragAndDrop } from \"../useNodeDragAndDrop\";\nimport { ExpressionPanel } from \"./ExpressionPanel\";\nimport { FieldConfigurationButton } from \"./FieldConfigurationButton\";\nimport { FieldPathBreadcrumbs } from \"./FieldPathBreadcrumbs\";\nimport NodeActionMenuItems from \"./NodeActionMenuItems\";\nimport { NodeReferencesMenu } from \"./NodeReferencesMenu\";\n\nexport const StyledCodeBlock = styled(Code)`\n  overflow: auto;\n  word-break: break-all;\n  font-size: 16px;\n  line-height: 20px;\n  display: block;\n  border: none;\n  box-shadow: none;\n  background: transparent;\n  padding: 0;\n`;\n\nexport const StyledPanel = styled.div`\n  display: grid;\n  gap: 8px;\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5 {\n    margin: 0;\n    &:not(:first-child) {\n      margin-top: 8px;\n    }\n  }\n`;\n\nexport const StyledCalloutWithCode = styled(Callout)`\n  > code,\n  pre {\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n    color: ${Colors.DARK_GRAY1};\n    /* border: 1px solid rgba(0, 0, 0, 0.2); */\n    margin: -1px;\n    padding: 2px 4px;\n    background-color: rgba(255, 255, 255, 0.3);\n  }\n\n  pre {\n    padding: 0.5em 0.55em;\n    margin: 0.5em 0;\n    line-height: 1.3em;\n    background: white;\n    white-space: pre-wrap;\n  }\n\n  code {\n    font-weight: 600;\n    font-family: SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n  }\n`;\n\nconst DragStripe = styled.div`\n  position: absolute;\n  top: 0px;\n  left: -20px;\n  width: calc(100% + 40px);\n  height: 5px;\n  background-color: ${Colors.BLUE3};\n  z-index: 10000000;\n`;\n\nfunction RenderTarget({\n  detailsButtonCaption,\n  hasTypeIcon,\n}: {\n  detailsButtonCaption?: React.ReactNode;\n  hasTypeIcon?: boolean;\n}) {\n  const context = React.useContext(ODKSurveyContext);\n  const { node, nodeEvaluationResults } = React.useContext(ODKNodeContext);\n  const isRelevant = isNodeRelevant(node, context.context);\n  const hasMissingParameters =\n    node.type.match(/^select/) && node.typeParameters.length === 0;\n  const firstColumnNameWithError = getFirstColumnNameWithError(\n    nodeEvaluationResults\n  );\n  const hasError = !!firstColumnNameWithError;\n  const [isDraggedOver, setIsDraggedOver] = React.useState(false);\n  const dragProps = useNodeDragAndDrop({\n    context: context.context,\n    node,\n    setIsDraggedOver,\n  });\n\n  return (\n    <ControlGroup\n      style={{\n        display: \"inline-flex\",\n        flex: \"none\",\n        position: \"relative\",\n        overflow: \"visible\",\n      }}\n      {...dragProps}\n    >\n      {isDraggedOver && <DragStripe />}\n      <Button\n        // elementRef={ref}\n        minimal={true}\n        // outlined={true}\n        small={true}\n        lang=\"en\"\n        intent={hasError ? \"danger\" : hasMissingParameters ? \"warning\" : \"none\"}\n        rightIcon={hasError ? \"error\" : undefined}\n        icon={hasTypeIcon ? typesToIcons[node.type] : undefined}\n        style={{\n          color: hasError || hasMissingParameters ? undefined : \"inherit\",\n          fontSize: \"inherit\",\n          padding: 0,\n        }}\n        className={[!hasError && !isRelevant && Classes.TEXT_MUTED]\n          .filter(Boolean)\n          .join(\" \")}\n      >\n        <ControlGroup>\n          {detailsButtonCaption || (\n            <code style={{ color: \"inherit\" }}>{node.row.name}</code>\n          )}\n          {!isRelevant && (\n            <>\n              &nbsp;\n              <Icon icon=\"eye-off\" style={{ opacity: 0.5, color: \"inherit\" }} />\n            </>\n          )}\n        </ControlGroup>\n      </Button>\n    </ControlGroup>\n  );\n}\n\nexport default function DetailsPopover(props: {\n  detailsButtonCaption?: React.ReactNode;\n  detailsContent?: string | JSX.Element | undefined;\n  node: ODKNode;\n  controlGroupProps?: HTMLDivProps;\n  showJumpButton?: boolean;\n  editable: boolean;\n  nameOfOnlyShownTab?: EvaluatableColumnName;\n  hasTypeIcon?: boolean;\n}) {\n  const {\n    node,\n    editable,\n    nameOfOnlyShownTab,\n    detailsButtonCaption,\n    hasTypeIcon,\n  } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const nodeEvaluationResults = context.context?.evaluationResults.get(node);\n  const firstColumnNameWithError = getFirstColumnNameWithError(\n    nodeEvaluationResults\n  );\n  const { row } = node;\n  const firstColumnNameWithContent = evaluatableColumnNames.find((n) => {\n    const value = row[n];\n    return typeof value === \"string\" && value.length > 0;\n  });\n\n  const [width, setWidth] = React.useState(100);\n  const handleResize = React.useCallback(\n    (entries: IResizeEntry[]) => {\n      // console.log(entries.map(e => `${e.contentRect.width} x ${e.contentRect.height}`));\n      setTimeout(() => {\n        const newWidth = entries[0]?.contentRect.width;\n        if (Math.abs(newWidth - width) > 10) {\n          setWidth(newWidth);\n        }\n      }, 50);\n    },\n    [width]\n  );\n\n  const [tabId, setTabId] = React.useState<string | number>(\n    firstColumnNameWithError || firstColumnNameWithContent || \"calculation\"\n  );\n\n  const references = React.useMemo(\n    () =>\n      context?.xlsForm && findOrReplaceFieldReferences(context.xlsForm, node),\n    [context, node]\n  );\n\n  const { alert, showRemoveConfirmationDialog } = useNodeDeletionDialog();\n  const { dialog: renameDialog, showRenameDialog } = useRenameNodeDialog();\n  if (!context.context) {\n    return null;\n  }\n\n  const path = getNodeAbsolutePath(node, context.context).slice(1);\n\n  const referencesButton = ReferencesButton({ references, editable });\n\n  const editHeader = (\n    <ControlGroup\n      style={{\n        margin: \"-20px\",\n        marginBottom: \"12px\",\n        backgroundColor: Colors.LIGHT_GRAY5,\n        // padding: \"20px\",\n        background: `linear-gradient(\n          ${alpha(Colors.BLUE3, 0.0)} 0px,\n          ${alpha(Colors.BLUE3, 0.05)} 22px,\n          ${alpha(Colors.BLUE3, 0.06)} 32px)`,\n        borderBottom: `solid 1px ${Colors.LIGHT_GRAY3}`,\n        gap: \"8px\",\n      }}\n    >\n      <FieldConfigurationButton node={node} showType={true} />\n\n      <div className={Classes.FLEX_EXPANDER} />\n\n      {referencesButton}\n\n      <ButtonGroup fill={false}>\n        <Popover2\n          content={\n            <Menu>\n              <NodeActionMenuItems\n                node={node}\n                onRemove={showRemoveConfirmationDialog}\n                onRename={showRenameDialog}\n                onNestField={context.onNestNode}\n                onUngroupField={context.onUngroupNode}\n              />\n            </Menu>\n          }\n          lazy={true}\n        >\n          <Button icon={\"more\"} minimal={true} title=\"Actions\" />\n        </Popover2>\n      </ButtonGroup>\n    </ControlGroup>\n  );\n\n  const detailsContent = (\n    <ControlGroup vertical={true}>\n      {editable && editHeader}\n\n      <ResizeSensor onResize={handleResize} observeParents={true}>\n        <ControlGroup style={{ width: \"100%\", marginBottom: \"8px\" }}>\n          <FieldPathBreadcrumbs {...{ path, width }} />\n        </ControlGroup>\n      </ResizeSensor>\n\n      {nameOfOnlyShownTab ? (\n        <ExpressionPanel\n          {...{ node, columnName: nameOfOnlyShownTab, nodeEvaluationResults }}\n          style={{ margin: \"0 -20px 0 -20px\" }}\n        />\n      ) : (\n        <Tabs\n          onChange={setTabId}\n          selectedTabId={tabId}\n          renderActiveTabPanelOnly={false}\n        >\n          {evaluatableColumnNames.map((columnName) =>\n            getTab({\n              node,\n              nodeEvaluationResults,\n              columnName: columnName,\n            })\n          )}\n        </Tabs>\n      )}\n    </ControlGroup>\n  );\n\n  return (\n    <ODKNodeContext.Provider value={{ node, nodeEvaluationResults }}>\n      {alert}\n      {renameDialog}\n      <Popover2\n        lazy={true}\n        interactionKind=\"click\"\n        popoverClassName={PopoverClasses.POPOVER2_CONTENT_SIZING}\n        minimal={false}\n        placement=\"bottom\"\n        rootBoundary=\"viewport\"\n        onOpening={() => setWidth(0)}\n        modifiers={{\n          arrow: { enabled: true },\n          preventOverflow: { enabled: true },\n        }}\n        content={detailsContent}\n        fill={false}\n        targetTagName=\"span\"\n      >\n        <RenderTarget {...{ detailsButtonCaption, hasTypeIcon }} />\n      </Popover2>\n    </ODKNodeContext.Provider>\n  );\n}\n\nfunction ReferencesButton({\n  references,\n  editable,\n}: {\n  references: DependentNodeWithReplacedRow[] | undefined;\n  editable: boolean;\n}) {\n  const referencesButtonTitle =\n    references &&\n    (references.length === 1\n      ? \"One dependency\"\n      : `${references.length} dependencies`);\n  const referencesButton = editable && references && references.length > 0 && (\n    <Popover2\n      content={<NodeReferencesMenu references={references} />}\n      lazy={true}\n    >\n      <Button\n        icon=\"link\"\n        // rightIcon={\"caret-down\"}\n        fill={false}\n        minimal={true}\n        title={referencesButtonTitle}\n        aria-label={referencesButtonTitle}\n      >\n        {references.length}\n      </Button>\n    </Popover2>\n  );\n  return referencesButton;\n}\n\nfunction getTab({\n  nodeEvaluationResults,\n  node,\n  columnName,\n}: {\n  nodeEvaluationResults: Map<string, ODKFormulaEvaluationResult> | undefined;\n  node: ODKNode;\n  columnName: EvaluatableColumnName;\n}) {\n  const results = nodeEvaluationResults?.get(columnName);\n  const panel = (\n    <ExpressionPanel\n      {...{ node, columnName, nodeEvaluationResults }}\n      style={{ margin: \"-20px\" }}\n    />\n  );\n\n  return (\n    <Tab\n      id={columnName}\n      panel={panel}\n      title={\n        <>\n          {columnName}\n          {results?.state === \"error\" && (\n            <>\n              &nbsp;\n              <Icon icon=\"warning-sign\" intent=\"warning\" />\n            </>\n          )}\n        </>\n      }\n    />\n  );\n}\n","import { Icon, ITreeNode, Tree } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport DetailsPopover from \"../survey/DetailsPopover/DetailsPopover\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport ODKFormulaEvaluationContext from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport {\n  getNodeAbsolutePath,\n  getNodeAbsolutePathString,\n} from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport {\n  evaluatableColumnNames,\n  ODKNode,\n} from \"../xlsform-simple-schema/types/ODKNode\";\n\nfunction SecondaryLabel(props: { node: ODKNode }) {\n  const { node } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const results = context.context?.evaluationResults.get(node);\n  if (!results) {\n    return <Icon icon=\"calculator\" intent=\"none\" />;\n  }\n  const keysWithErrors = evaluatableColumnNames.filter(\n    (k) => results.get(k)?.error\n  );\n  const answer = context.context?.nodesToAnswers.get(node);\n  const valueString = answer === undefined ? null : JSON.stringify(answer);\n  const caption = <span>{valueString}</span>;\n  const error = `Node has errors in the following columns: ${keysWithErrors\n    .map((k) => `‘${k}’`)\n    .join(\", \")}`;\n  const icon = keysWithErrors.length ? (\n    <Icon icon=\"error\" intent=\"danger\" title={error} htmlTitle={error} />\n  ) : null;\n  return (\n    <>\n      {caption}\n      {icon}\n    </>\n  );\n}\n\nexport function getNodeTree(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  transform: (result: ITreeNode<ODKNode>) => ITreeNode<ODKNode>\n): ITreeNode<ODKNode> {\n  if (node.children.length === 0) {\n    return transform({\n      id: getNodeAbsolutePath(node, context).join(\".\"),\n      label: node.row.name,\n      childNodes: [],\n      nodeData: node,\n    });\n  }\n\n  return transform({\n    id: getNodeAbsolutePath(node, context).join(\".\"),\n    label: node.row.name,\n    childNodes: node.children.map((childNode) =>\n      getNodeTree(childNode, context, transform)\n    ),\n    nodeData: node,\n  });\n}\n\n// const DragSourcePlaceholder = styled.div`\n//   height: 20px;\n//   background-color: red;\n// `;\n\n// const DragTargetPlaceholder = styled.div`\n//   height: 20px;\n//   background-color: blue;\n// `;\n\nexport default function ResultCodeTree(props: { xlsForm: XLSForm }) {\n  const { xlsForm } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const evaluationContext = context.context;\n\n  const result = React.useMemo(() => {\n    return xlsForm && evaluationContext\n      ? getNodeTree(xlsForm.rootSurveyGroup, evaluationContext, (result) => {\n          const node = result.nodeData;\n          if (!node) {\n            debugger;\n            throw new Error(\n              \"Encountered a tree node that is not associated with a node. Please fix this.\"\n            );\n          }\n\n          if (!context.context) {\n            throw new Error(\n              \"No context defined. Please define a context before using this component.\"\n            );\n          }\n\n          const path = getNodeAbsolutePathString(node, context.context);\n\n          const label = (\n            <DetailsPopover node={node} editable={true} hasTypeIcon={true} />\n          );\n\n          return {\n            ...result,\n            label,\n            key: node.row.name,\n            isExpanded: true,\n            hasCaret: !(result.childNodes?.length === 0),\n            secondaryLabel: node && <SecondaryLabel node={node} />,\n          } as ITreeNode<ODKNode>;\n        })\n      : null;\n  }, [context.context, evaluationContext, xlsForm]);\n\n  return result ? <Tree contents={[result]} /> : <div></div>;\n}\n","import * as React from \"react\";\nimport { FileInput } from \"@blueprintjs/core\";\nimport * as ExcelJS from \"exceljs\";\n\nexport default function ExcelFileInput(props: {\n  onLoadWorkbook: (workbook: ExcelJS.Workbook) => void;\n}) {\n  const onFileChange = React.useCallback(\n    (e) => {\n      const file = e.target.files[0];\n      const wb = new ExcelJS.Workbook();\n      const reader = new FileReader();\n\n      reader.readAsArrayBuffer(file);\n      reader.onload = () => {\n        const buffer = reader.result;\n        if (!(buffer instanceof ArrayBuffer)) {\n          throw new Error(\n            \"Buffer was not defined as Buffer object after reading.\"\n          );\n        }\n        wb.xlsx.load(buffer).then((workbook) => {\n          console.log(workbook, \"workbook instance\");\n          props.onLoadWorkbook(wb);\n        });\n      };\n    },\n    [props]\n  );\n\n  return <FileInput onInputChange={onFileChange} />;\n}\n","import { Button, MenuItem } from \"@blueprintjs/core\";\nimport { ItemRenderer, Select } from \"@blueprintjs/select\";\nimport * as React from \"react\";\n\nconst LanguageSelect = Select.ofType<string>();\n\ntype Props = {\n  language: string;\n  languages: string[];\n  onChange: (language: string) => void;\n};\n\nconst renderItem: ItemRenderer<string> = (language: string, options) => {\n  return (\n    <MenuItem\n      text={language}\n      // active={true}\n      onClick={options.handleClick}\n      shouldDismissPopover={false}\n    />\n  );\n};\n\nexport default function LanguageSelector(props: Props) {\n  const onItemSelect = React.useCallback(\n    (language: string) => {\n      props.onChange(language);\n    },\n    [props]\n  );\n\n  return (\n    <LanguageSelect\n      items={props.languages}\n      itemRenderer={renderItem}\n      activeItem={props.language}\n      noResults={<MenuItem disabled={true} text=\"No languages loaded yet.\" />}\n      onItemSelect={onItemSelect}\n      filterable={false}\n    >\n      {/* children become the popover target; render value here */}\n      <Button text={props.language} rightIcon=\"double-caret-vertical\" />\n    </LanguageSelect>\n  );\n}\n","import { HTMLDivProps } from '@blueprintjs/core';\nimport * as React from 'react';\n\nexport default function OverflowScrollContainer(props: HTMLDivProps) {\n    return <div {...props} style={{ overflow: 'auto', flex: 1, ...props.style }}>\n        {props.children}\n    </div>;\n}","import {\n  SemanticError,\n  FunctionNotImplementedError,\n} from \"../../../types/Errors\";\nimport ODKNodeValue from \"../../../types/ODKNodeValue\";\nimport { ODKNodeWithoutRuntimeInfo } from \"../../../types/ODKNode\";\nimport ODKFormulaExecutionContext from \"./ODKFormulaEvaluationContext\";\nimport { ordinalize } from \"inflection\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\ntype Value = ODKNodeValue;\n\nexport type FormulaFunction = (\n  this: {\n    context: ODKFormulaExecutionContext;\n    scope: ODKNodeWithoutRuntimeInfo;\n  },\n  ...args: Value[]\n) => Value;\n\nfunction assertString(value: unknown, argNo: number): asserts value is string {\n  if (typeof value !== \"string\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a string value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\nfunction assertNumber(value: unknown, argNo: number): asserts value is number {\n  if (typeof value !== \"number\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a number value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\nfunction assertBoolean(\n  value: unknown,\n  argNo: number\n): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    const number = ordinalize(String(argNo + 1));\n    throw new SemanticError(\n      `Expected a boolean value as ${number} parameter, but got \\`${value}\\`.`\n    );\n  }\n}\n\n// Documentation: https://docs.getodk.org/form-operators-functions/\nexport const functions: Record<string, FormulaFunction> = {\n  if<T, U>(expression: unknown, then: T, elseExpression: U): T | U {\n    assertBoolean(expression, 0);\n    return expression ? then : elseExpression;\n  },\n\n  true(): boolean {\n    return true;\n  },\n\n  false(): boolean {\n    return false;\n  },\n\n  not(arg: unknown): boolean {\n    assertBoolean(arg, 0);\n    return !arg;\n  },\n\n  coalesce<T extends Value, U extends Value>(arg: T, arg2: U): T | U | string {\n    if (typeof arg !== \"undefined\" && arg !== \"\") {\n      return arg;\n    }\n    if (typeof arg2 !== \"undefined\" && arg2 !== \"\") {\n      return arg2;\n    }\n    return \"\";\n  },\n\n  boolean(arg: Value): boolean {\n    if (typeof arg === \"number\") {\n      return arg !== 0;\n    }\n    if (typeof arg === \"string\") {\n      return arg !== \"\";\n    }\n    if (arg instanceof Array) {\n      return arg.length > 0;\n    }\n    if (typeof arg === \"boolean\") {\n      return arg;\n    }\n    return false;\n  },\n\n  /**\n    Returns an integer equal to the 1-indexed position of the current node within the node defined by xpath.\n    Most often this is used in the form position(..) to identify the current iteration index within a repeat group.\n  */\n  position(_xpath: Value): number {\n    throw new FunctionNotImplementedError(\"position\");\n  },\n  /**\n   * Returns the value expression if the question's value is empty. Otherwise, returns the current value of the question.\n   * This can be used to ensure that a random number is only generated once, or to store the first value entered for a question in a way that is retrievable even if the response is changed later.\n   *   Warning This function is often misunderstood. Read when expressions are evaluated to learn more.\n   */\n  once(_expression: Value): Value {\n    throw new FunctionNotImplementedError(\"once\");\n  },\n\n  /**\n   * Returns True if string is a member of space_delimited_array, otherwise returns False. Commonly used to determined if a specific choice was selected in a select question. (This is possible because a reference to a select question returns a space-delimited array of choice names.)\n   */\n  selected(space_delimited_array: Value, string: Value): boolean {\n    if (space_delimited_array === undefined) {\n      return false;\n    }\n    assertString(space_delimited_array, 0);\n    assertString(string, 1);\n    if (space_delimited_array.length === 0 || string.length === 0) {\n      return false;\n    }\n    return space_delimited_array.split(\" \").includes(string);\n  },\n\n  // Returns the string at the n th position of the space_delimited_array. (The array is zero-indexed.) Returns an empty string if the index does not exist.\n  // This can be used to get the name of a selected choice from a multi-select question. (This is possible because a reference to a select question returns a space-delimited array of choice names.)\n  // Note\n  // If used to get a choice name from a select question, this function returns the name, not the label, of the selected choice. To get the label in the current language, use jr:choice-name().\n  \"selected-at\"(_space_delimited_array: Value, _n): string {\n    throw new FunctionNotImplementedError(\"selected-at\");\n  },\n\n  // Returns the number of choices selected in multi_select_question.\n  \"count-selected\"(_multi_select_question: Value): number {\n    throw new FunctionNotImplementedError(\"count-selected\");\n  },\n\n  // Returns the label value, in the active language, associated with the choice_name in the list of choices for the select_question.\n  // Note\n  // You have to wrap the select_question reference in quotes.\n  // '${question_name}'\n  \"jr:choice-name\"(_choice_name: Value, _select_question: Value): string {\n    throw new FunctionNotImplementedError(\"jr:choice-name\");\n  },\n\n  // Repeat groups\n  // Helpful terms\n  // nodeset\n  // A collection of XML nodes. In XLSForms, this is typically a collection of response values.\n  // Outside a repeat group, referring to a question by name will return a nodeset containing all the responses to that question.\n  // Nodesets can also be created by joining two or more nodes with pipes: /data/age | /data/name.\n\n  // Returns the response value of question name from the repeat-group group, in iteration i.\n  // Nested repeat groups can be accessed using the sub and sub_sub parameters.\n  // See also\n  // Referencing repeated questions from inside the repeat\n  \"indexed-repeat\"(\n    _name: Value,\n    _group: Value,\n    _i: Value,\n    _sub_grp: Value,\n    _sub_i: Value,\n    _sub_sub_grp: Value,\n    _sub_sub_i: Value\n  ): string {\n    throw new FunctionNotImplementedError(\"):\");\n  },\n\n  // Returns the number of items in nodeset. This can be used to count the number of repetitions in a repeat group.\n  count(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"count\");\n  },\n\n  // Returns the number of non-empty members of nodeset.\n  \"count-non-empty\"(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"count-non-empty\");\n  },\n\n  // Returns the sum of the members of nodeset.\n  // Can be used to tally responses to a repeated select question.\n  sum(_nodeset: Value): number {\n    throw new FunctionNotImplementedError(\"sum\");\n  },\n\n  // Returns the largest member of nodeset.\n  // Warning\n  // The min() and max() functions only work sets of numbers. Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n  // Strings\n  max(_nodeset: Value): Value {\n    throw new FunctionNotImplementedError(\"max\");\n  },\n\n  // Returns the smallest member of nodeset.\n  // Warning\n  // The min() and max() functions only work sets of numbers. Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n  // Strings\n  min(_nodeset: Value): Value {\n    throw new FunctionNotImplementedError(\"min\");\n  },\n\n  // Searching and matching strings\n\n  // Returns True if string is an exact and complete match for expression.\n  // See also\n  // Using regular expressions\n  regex(string: Value, expression: Value): boolean {\n    assertString(string, 0);\n    assertString(expression, 0);\n    return !!string.match(new RegExp(expression));\n  },\n\n  // Returns True if the string contains the substring.\n  contains(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return !!string.match(substring);\n  },\n\n  // Returns True if string begins with substring.\n  \"starts-with\"(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return string.startsWith(substring);\n  },\n\n  // Returns True if the string ends with substring.\n  \"ends-with\"(string: Value, substring: Value): boolean {\n    assertString(string, 0);\n    assertString(substring, 1);\n    return string.endsWith(substring);\n  },\n\n  // Returns the substring of string beginning at the index start and extending to (but not including) index end (or to the termination of string, if end is not provided). Members of string are zero-indexed.\n  substr(string: Value, start: Value, end: Value): string {\n    assertString(string, 0);\n    assertNumber(start, 1);\n    assertNumber(end, 2);\n    return string.substring(start, end);\n  },\n\n  // Returns the substring of string before the first occurrence of the target substring. If the target is not found, or string begins with the target substring, then this will return an empty string.\n  \"substring-before\"(_string: Value, _target): string {\n    throw new FunctionNotImplementedError(\"substring-before\");\n  },\n\n  // Returns the substring of string after the first occurrence of the target substring. If the target is not found this will return an empty string.\n  \"substring-after\"(_string: Value, _target): string {\n    throw new FunctionNotImplementedError(\"substring-after\");\n  },\n\n  // Returns a copy of string, where every occurrence of a character in fromchars is replaced by the corresponding character in tochars. If fromchars is longer than tochars then every occurrence of a character in fromchars that does not have a corresponding character in tochars will be removed.\n  translate(_string: Value, _fromchars: Value, _tochars: Value): string {\n    throw new FunctionNotImplementedError(\"translate\");\n  },\n\n  // Returns the number of characters in string. If no value is passed in, returns the number of characters in the value of the question that this function call is tied to which can be useful in a constraint expression.\n  \"string-length\"(string: Value): number {\n    assertString(string, 0);\n    return string.length;\n  },\n\n  // Returns a string with normalized whitespace by stripping leading and trailing whitespace of string and replacing sequences of whitespace characters with a single space. If no value is passed in, normalizes whitespace of the value of the question that this function call is tied to.\n  \"normalize-space\"(string?: Value): string {\n    assertString(string, 0);\n    return string.trim();\n  },\n\n  // Combining strings\n\n  // Concatenates one or more arguments into a single string. If any arg is a nodeset, the values within the set are concatenated into a string.\n  concat(...args: Value[]): string {\n    return args.join(\"\");\n  },\n\n  // Joins the members of nodeset, using the string separator.\n  join(_separator: Value, _nodeset: ODKNodeValue): string {\n    throw new FunctionNotImplementedError(\"join\");\n  },\n\n  // Converting to and from strings\n\n  // Returns True if string is \"true\" or \"1\". Otherwise, False.\n  \"boolean-from-string\"(string: Value): boolean {\n    return string === \"true\" || string === \"1\";\n  },\n\n  // Converts arg to a string.\n  string(arg: Value): string {\n    return String(arg);\n  },\n\n  // Math\n  // Warning\n  // Math functions (except number()) only work with number values.\n  // You can use number() to convert a string of digits to a number, but it is usually better to get a number value directly.\n  // Empty values (that is, variables referencing unanswered questions) are actually empty strings, and will not be automatically converted to zero (0).\n\n  // Number handling\n\n  // Rounds a decimal number to some number of decimal places.\n  round(number: Value, places: Value): number {\n    assertNumber(number, 0);\n    assertNumber(places, 1);\n    return Math.round(number * 10 ** places) / 10 ** places;\n  },\n\n  // Truncates the fractional portion of a decimal number to return an integer.\n  int(number: Value) {\n    assertNumber(number, 0);\n    return Math.floor(number);\n  },\n\n  // Converts arg to number value.\n  // If arg is a string of digits, returns the number value.\n  // If arg is True, returns 1. If arg is False, returns 0.\n  // If arg cannot be converted, returns NaN (not a number).\n  number(arg: Value): number {\n    if (typeof arg === \"boolean\") {\n      return arg ? 1 : 0;\n    }\n    if (typeof arg === \"string\") {\n      if (arg.trim().match(/-?\\d+(\\.\\d+)?/)) {\n        return Number(arg);\n      }\n    }\n    if (typeof arg === \"number\") {\n      return arg;\n    }\n    return NaN;\n  },\n\n  // Computes and returns the hash value of the data string using the indicated hash algorithm string, and encoding this hash value using the optional encoding string.\n  // Options for the algorithm are MD5, SHA-1, SHA-256, SHA-384, SHA-512.\n  // If the third parameter is not specified, the encoding is base64. Valid options for the encoding are base64 and hex.\n  // This function can be useful if, for example, someone wants to build a unique identifier from sensitive data like a national ID number without compromising that data.\n  // See also\n  // count(), max(), min(), number()\n  digest(_data: Value, _algorithm: Value, _encodingMethod: Value): string {\n    throw new FunctionNotImplementedError(\"digest\");\n  },\n\n  // Calculation\n  pow(number: Value, exponent: Value): number {\n    assertNumber(number, 0);\n    assertNumber(exponent, 1);\n    return Math.pow(number, exponent);\n  },\n  log(number: Value): number {\n    assertNumber(number, 0);\n    return Math.log(number);\n  },\n  log10(number: Value): number {\n    assertNumber(number, 0);\n    return Math.log10(number);\n  },\n  abs(number: Value): number {\n    assertNumber(number, 0);\n    return Math.abs(number);\n  },\n  sin(number: Value): number {\n    assertNumber(number, 0);\n    return Math.sin(number);\n  },\n  cos(number: Value): number {\n    assertNumber(number, 0);\n    return Math.cos(number);\n  },\n  tan(number: Value): number {\n    assertNumber(number, 0);\n    return Math.tan(number);\n  },\n  asin(number: Value): number {\n    assertNumber(number, 0);\n    return Math.asin(number);\n  },\n  acos(number: Value): number {\n    assertNumber(number, 0);\n    return Math.acos(number);\n  },\n  atan(number: Value): number {\n    assertNumber(number, 0);\n    return Math.atan(number);\n  },\n  atan2(y: Value, x: Value): number {\n    assertNumber(y, 0);\n    assertNumber(x, 1);\n    return Math.atan2(y, x);\n  },\n  sqrt(number: Value): number {\n    assertNumber(number, 0);\n    return Math.sqrt(number);\n  },\n  exp(number: Value): number {\n    assertNumber(number, 0);\n    return Math.exp(number);\n  },\n  exp10: (number: Value): number => {\n    assertNumber(number, 0);\n    return 10 ** number;\n  },\n  pi: (): number => {\n    return Math.PI;\n  },\n\n  // Date and time\n\n  // Returns the current date without a time component.\n  today(): Date {\n    const now = new Date();\n    now.setHours(0, 0, 0, 0);\n    return now;\n  },\n\n  // Returns the current datetime in ISO 8601 format, including the timezone.\n  // Warning\n  // This function is often misused. Read when expressions are evaluated to learn more.\n  now(): string {\n    return new Date().toISOString();\n  },\n\n  // Converting dates and time\n\n  // Converts dateTime value to the number of days since January 1, 1970 (the Unix Epoch).\n  // This is the inverse of date().\n  \"decimal-date-time\"(_dateTime: Value): number {\n    throw new FunctionNotImplementedError(\"decimal-date-time\");\n  },\n\n  // Converts an integer representing a number of days from January 1, 1970 (the Unix Epoch) to a standard date value.\n\n  // This is the inverse of decimal-date-time().\n  date(_days: Value): Date {\n    throw new FunctionNotImplementedError(\"date\");\n  },\n\n  // Converts time to a number representing a fractional day. For example, noon is 0.5 and 6:00 PM is 0.75.\n  \"decimal-time\"(_time: Value): number {\n    throw new FunctionNotImplementedError(\"decimal-time\");\n  },\n\n  // Formatting dates and times for display\n\n  // Returns date as a string formatted as defined by format.\n  \"format-date\"(_date: Value, _format: Value): string {\n    throw new FunctionNotImplementedError(\"format-date\");\n  },\n\n  // Returns dateTime as a string formatted as defined by format.\n  \"format-date-time\"(_dateTime: Value, _format: Value): string {\n    throw new FunctionNotImplementedError(\"format-date-time\");\n  },\n\n  // Geography\n\n  // Returns the area, in square meters, of either a nodeset of geopoints or a geoshape value.\n  // It takes into account the circumference of the Earth around the Equator but does not take altitude into account.\n  area(_nodesetOrGeoshape: Value | Value): number {\n    throw new FunctionNotImplementedError(\"area\");\n  },\n\n  // Returns the distance, in meters, of either:\n\n  // a nodeset of geopoints\n  // the perimeter of a geoshape\n  // the length of a geotrace value\n  // It takes into account the circumference of the Earth around the Equator and does not take altitude into account.\n  distance(_nodesetOrGeoshapeOrGeotrace: Value): number {\n    throw new FunctionNotImplementedError(\"distance\");\n  },\n\n  // Utility\n\n  // Returns a random number between 0.0 (inclusive) and 1.0 (exclusive).\n  // Warning\n  // This function is often misused. Read when expressions are evaluated to learn more.\n  random: Math.random,\n\n  // Returns a shuffled nodeset.\n  // A shuffle with a numeric seed is deterministic and reproducible.\n  // The primary use for this function is to randomize the order of choices for a select question. The documentation on select widgets describes how this is done in XLSForm.\n  // randomize() can only be used in a context where a nodeset is accepted. Note that questions of type calculate cannot reference a nodeset.\n  randomize(_nodeset: Value, _seed: Value): ODKNodeValue {\n    throw new FunctionNotImplementedError(\"randomize\");\n  },\n\n  // Without argument, returns a random RFC 4122 version 4 compliant UUID.\n  // With an argument it returns a random GUID of specified length.\n  uuid(_length: Value): string {\n    throw new FunctionNotImplementedError(\"uuid\");\n  },\n\n  // Returns True if the number of response s that are exactly the string \"yes\" is between min and max, inclusive.\n  // Set min or max to -1 to make the argument not applicable.\n  checklist(_min: Value, _max: Value, ..._responses: Value[]): boolean {\n    throw new FunctionNotImplementedError(\"checklist\");\n  },\n\n  // Returns True if the sum of the weight s of each response that is exactly the string \"yes\" is between min and max, inclusive.\n  // Set min or max to -1 to make the argument not\n  \"weighted-checklist\"(\n    _min: Value,\n    _max: Value,\n    _response: Value,\n    ..._weightResponsePairs: Value[]\n  ): boolean {\n    throw new FunctionNotImplementedError(\"weighted-checklist\");\n  },\n};\n\nexport default functions;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ordinalize } from \"inflection\";\nimport { EvaluationError } from \"../../../types/Errors\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport ODKNodeValue from \"../../../types/ODKNodeValue\";\nimport {\n  CallExpression,\n  Expression,\n  NameExpression,\n  OperatorExpression,\n} from \"../pratt-parser-base\";\nimport LiteralExpression from \"../pratt-parser-base/expressions/LiteralExpression\";\nimport SelectorExpression from \"../pratt-parser-base/expressions/SelectorExpression\";\nimport evaluateNodeColumn from \"./evaluateNodeColumn\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport functions from \"./ODKFormulaFunctions\";\nimport {\n  findNodeByNameInCurrentAndAncestorScopes,\n  findNodeByNameInsideScope,\n  findNodeByPathRelativeToScope,\n} from \"./XPath\";\n\n/**\n * Evaluates a parsed expression / AST, returning the end result as JavaScript value.\n *\n * @param expression The parsed expression / AST to evaluate.\n * @param context the global context in which the formula should be evaluated. This context contains\n *   information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n * @param scope\n *   For resolving XPaths and relative node references correctly, the evaluation process needs to\n *   know the node in which the evaluation should begin. Use this parameter to supply the node that\n *   contained the formula string.\n */\nexport default function evaluateExpression(\n  expression: Expression,\n  context: ODKFormulaEvaluationContext,\n  scope: Readonly<ODKNode>\n): unknown {\n  let result: unknown;\n\n  if (context.stackDepth > 10000) {\n    throw new EvaluationError(\n      `Stack overflow while evaluating \\`${JSON.stringify(expression)}\\``,\n      \"stackOverflow\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  const deeperContext = {\n    ...context,\n    stackDepth: context.stackDepth + 1,\n  };\n\n  // XXX: This could be caseless, for example by having Expression subclasses that have their own evaluator\n  if (expression instanceof LiteralExpression) {\n    result = evaluateLiteralExpression(expression);\n  } else if (expression instanceof NameExpression) {\n    result = evaluateNameExpression(expression, deeperContext, scope);\n  } else if (expression instanceof SelectorExpression) {\n    result = evaluateSelectorExpression(expression, deeperContext, scope);\n  } else if (expression instanceof OperatorExpression) {\n    result = evaluateOperatorExpression(expression, deeperContext, scope);\n  } else if (expression instanceof CallExpression) {\n    result = evaluateCallExpression(expression, deeperContext, scope);\n  } else {\n    throw new EvaluationError(\n      `Don’t know how to evaluate \\`${expression}\\`.`,\n      \"unsupportedExpressionType\",\n      expression,\n      deeperContext,\n      scope\n    );\n  }\n\n  context.stackDepth -= 1;\n\n  return result;\n}\n\nfunction evaluateLiteralExpression(\n  expression: LiteralExpression<ODKNodeValue>\n): ODKNodeValue {\n  return expression.value;\n}\n\nfunction stringFromStringOrExpression(n: string | Expression) {\n  if (typeof n === \"string\") {\n    return n;\n  }\n  let string = \"\";\n  n.print((str: string) => (string += str));\n  return string;\n}\n\nfunction evaluateCallExpression(\n  expression: CallExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): unknown {\n  const nameExpressionOrString =\n    expression.fn instanceof NameExpression\n      ? expression.fn\n      : evaluateExpression(expression.fn, context, scope);\n  let fn: unknown = undefined;\n  if (nameExpressionOrString instanceof NameExpression) {\n    fn = evaluateNameExpression(\n      nameExpressionOrString,\n      context,\n      scope,\n      true,\n      functions\n    );\n  } else if (typeof nameExpressionOrString === \"string\") {\n    fn = functions[nameExpressionOrString];\n  } else {\n    throw new EvaluationError(\n      `Can’t call a function without knowing its name — the name must be either defined as string, return a name string or a function reference.`,\n      \"functionNotFound\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  if (!fn) {\n    throw new EvaluationError(\n      `Could not find a function named \\`${stringFromStringOrExpression(\n        nameExpressionOrString\n      )}\\`.`,\n      \"functionNotFound\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  const evaluatedArgs = expression.args.map((arg, i) => {\n    try {\n      return evaluateExpression(arg, context, scope);\n    } catch (e) {\n      const number = ordinalize(String(i + 1));\n\n      throw new EvaluationError(\n        `Error in ${number} argument in \\`${stringFromStringOrExpression(\n          nameExpressionOrString\n        )}() function call\\`: ${e.message}`,\n        \"functionEvalError\",\n        expression,\n        context,\n        scope,\n        e\n      );\n    }\n  });\n  if (typeof fn !== \"function\") {\n    throw new EvaluationError(\n      `Found name \\`${fn}\\`, but it is not a function.`,\n      \"functionNotFound\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  try {\n    const result = fn.apply(context, evaluatedArgs);\n    return result;\n  } catch (e) {\n    let string = \"\";\n    expression.print((s) => (string += s));\n    throw new EvaluationError(\n      `Error while calling \\`${string}\\`: ${e.message}`,\n      \"functionEvalError\",\n      expression,\n      context,\n      scope,\n      e\n    );\n  }\n}\n\nfunction assertBoolean(\n  value: unknown,\n  valueBeforeCasting: unknown,\n  expression: Expression | undefined,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    throw new EvaluationError(\n      `Found operand \\`${JSON.stringify(\n        valueBeforeCasting\n      )}\\` that is no boolean value. Boolean operators only work with values that are \\`true\\` or \\`false\\`.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n}\n\nfunction evaluateOperatorExpression(\n  expression: OperatorExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): ODKNodeValue {\n  const leftBeforeCasting = evaluateExpression(expression.left, context, scope);\n  const rightBeforeCasting = evaluateExpression(\n    expression.right,\n    context,\n    scope\n  );\n\n  const operator = expression.operatorToken.text;\n\n  if (operator === \"=\") {\n    // eslint-disable-next-line eqeqeq\n    return leftBeforeCasting == rightBeforeCasting;\n  }\n  if (operator === \"!=\") {\n    // eslint-disable-next-line eqeqeq\n    return leftBeforeCasting != rightBeforeCasting;\n  }\n\n  let left;\n  let right;\n  if (operator === \"and\" || operator === \"or\") {\n    if (typeof leftBeforeCasting === \"boolean\") {\n      left = leftBeforeCasting;\n    }\n    if (typeof leftBeforeCasting === \"number\") {\n      left = Boolean(leftBeforeCasting);\n    }\n\n    if (typeof rightBeforeCasting === \"boolean\") {\n      right = rightBeforeCasting;\n    }\n    if (typeof rightBeforeCasting === \"number\") {\n      right = Boolean(rightBeforeCasting);\n    }\n\n    assertBoolean(left, leftBeforeCasting, expression, context, scope);\n    assertBoolean(right, rightBeforeCasting, expression, context, scope);\n\n    switch (operator) {\n      case \"or\":\n        return left || right;\n      case \"and\":\n        return left && right;\n    }\n  }\n\n  if (typeof leftBeforeCasting === \"number\") {\n    left = leftBeforeCasting;\n  }\n  if (typeof leftBeforeCasting === \"string\") {\n    left = parseFloat(leftBeforeCasting);\n  }\n\n  if (typeof rightBeforeCasting === \"number\") {\n    right = rightBeforeCasting;\n  }\n  if (typeof rightBeforeCasting === \"string\") {\n    right = parseFloat(rightBeforeCasting);\n  }\n\n  if (typeof left !== \"number\") {\n    throw new EvaluationError(\n      `Left operand is \\`${JSON.stringify(\n        leftBeforeCasting\n      )}\\`, which is no number. Arithmetic and relative comparison operators only work with operands that are numeric.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n  if (typeof right !== \"number\") {\n    throw new EvaluationError(\n      `Right operand is \\`${JSON.stringify(\n        rightBeforeCasting\n      )}\\`, which no number. Arithmetic and relative comparison operators only work with operands that are numeric.`,\n      \"invalidOperandType\",\n      expression,\n      context,\n      scope\n    );\n  }\n\n  switch (operator) {\n    case \"+\":\n      return left + right;\n    case \"-\":\n      return left - right;\n    case \"*\":\n      return left * right;\n    case \"div\":\n      return left / right;\n    case \"mod\":\n      return left % right;\n    case \">\":\n      return left > right;\n    case \">=\":\n      return left >= right;\n    case \"<\":\n      return left < right;\n    case \"<=\":\n      return left <= right;\n    default:\n      throw new EvaluationError(\n        `The \\`${operator}\\` operator is not supported`,\n        \"unsupportedOperator\",\n        expression,\n        context,\n        scope\n      );\n  }\n}\n\nfunction evaluateNameExpression(\n  expression: NameExpression,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode,\n  allowUndefinedNames = false,\n  literalBag: Record<string, unknown> = context.knownLiteralsWithoutDollarSign\n): unknown {\n  if (expression.text.startsWith(\"$\")) {\n    const nodeOrNodes =\n      findNodeByNameInCurrentAndAncestorScopes(\n        expression.name,\n        context,\n        scope\n      ) || findNodeByNameInsideScope(expression.name, context);\n    if (!nodeOrNodes) {\n      throw new EvaluationError(\n        `Could not find a node with name \\`${expression.name}\\`.`,\n        \"nodeNotFound\",\n        expression,\n        context,\n        scope\n      );\n    }\n    if (nodeOrNodes instanceof Array) {\n      return nodeOrNodes.map((node) =>\n        evaluateNodeColumn(\n          node,\n          context,\n          \"calculation\",\n          context.nodesToAnswers.get(node)\n        )\n      );\n    }\n    const evaluationResult = evaluateNodeColumn(\n      nodeOrNodes,\n      context,\n      \"calculation\",\n      context.nodesToAnswers.get(nodeOrNodes)\n    );\n    if (evaluationResult.error) {\n      throw new EvaluationError(\n        `Error in expression ${expression.text}.`,\n        \"unsupportedNameExpression\",\n        expression,\n        context,\n        scope,\n        evaluationResult.error instanceof EvaluationError\n          ? evaluationResult.error\n          : undefined\n      );\n    }\n    return evaluationResult.result;\n  } else if (expression.text === expression.name) {\n    const value = context.evaluateNonDollarNameFn\n      ? context.evaluateNonDollarNameFn({ expression, context, scope })\n      : literalBag[expression.name];\n    if (value !== undefined || allowUndefinedNames) {\n      return value;\n    }\n    throw new EvaluationError(\n      `Unknown name \\`${expression.text}\\` — did you mean to use \\`\\${${expression.name}}\\` instead of \\`${expression.name}\\`?`,\n      \"unknownNameWithoutDollarSign\",\n      expression,\n      context,\n      scope\n    );\n  }\n  throw new EvaluationError(\n    `Don’t know how to evaluate ${expression}.`,\n    \"unsupportedNameExpression\",\n    expression,\n    context,\n    scope\n  );\n}\n\nexport function evaluateSelectorExpression(\n  expression: SelectorExpression<string[]>,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode\n): unknown {\n  const selector = expression.selector;\n  const node = findNodeByPathRelativeToScope(selector, context, scope);\n  if (node instanceof Array) {\n    return node.map((childNode) =>\n      evaluateNodeColumn(\n        childNode,\n        context,\n        \"calculation\",\n        context.nodesToAnswers.get(childNode)\n      )\n    );\n  }\n  return (\n    node &&\n    evaluateNodeColumn(\n      node,\n      context,\n      \"calculation\",\n      context.nodesToAnswers.get(node)\n    )\n  );\n}\n","import ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport evaluateExpression from \"./evaluateExpression\";\nimport { ODKNode } from \"../../../types/ODKNode\";\nimport { ODKFormulaError, SemanticError } from \"../../../types/Errors\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\nimport { Expression } from \"../pratt-parser-base\";\nimport ODKFormulaLexer from \"../odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../odk-formula-parser/ODKFormulaParser\";\n\nfunction assertExpressionAfterEvaluation(\n  expression: unknown\n): asserts expression is Expression {\n  if (!expression) {\n    throw new SemanticError(\n      \"Formula was not evaluated to an expression, but no error was encountered. This means an error handler is missing for this case.\"\n    );\n  }\n}\n\n/**\n * Evaluates a formula string.\n *\n * @returns The resulting value, the AST, and detailed error information if the evaluation fails.\n *\n * @param formula the formula string to evaluate, e.g. '1 + 1'\n * @param context the global context in which the formula should be evaluated. This context contains\n *   information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n * @param scope\n *   For resolving XPaths and relative node references correctly, the evaluation process needs to\n *   know the node in which the evaluation should begin. Use this parameter to supply the node that\n *   contained the formula string.\n */\nexport default function evaluateODKFormula(\n  formula: string,\n  context: ODKFormulaEvaluationContext,\n  scope: ODKNode = context.survey\n): ODKFormulaEvaluationResult {\n  let error;\n  let result;\n  let expression;\n  const lexer = new ODKFormulaLexer(formula);\n  const parser = new ODKFormulaParser({ tokens: lexer });\n  try {\n    expression = parser.parseExpression();\n\n    if (!expression) {\n      throw new Error(\n        `Parsing given formula \\`${formula}\\` returned an empty expression. This should not happen, it means the underlying code should have thrown an exception earlier.`\n      );\n    }\n    result = evaluateExpression(expression, context, scope);\n    assertExpressionAfterEvaluation(expression);\n    return {\n      parser,\n      state: \"success\",\n      expression,\n      result,\n      error: undefined,\n    };\n  } catch (e) {\n    if (e instanceof ODKFormulaError) {\n      error = e;\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    parser,\n    state: \"error\",\n    expression,\n    error,\n    result: null,\n  };\n}\n","import { EvaluationError } from \"../../../types/Errors\";\nimport { EvaluatableColumnName, ODKNode } from \"../../../types/ODKNode\";\nimport LiteralExpression from \"../pratt-parser-base/expressions/LiteralExpression\";\nimport evaluateODKFormula from \"./evaluateODKFormula\";\nimport ODKFormulaEvaluationContext from \"./ODKFormulaEvaluationContext\";\nimport ODKFormulaEvaluationResult from \"./ODKFormulaEvaluationResult\";\n\n/**\n * Evaluates the JavaScript value of a survey node, returning either a user answer or a calculated\n * formula result.\n *\n * @param node The node containing the survey answer / calculation to evaluate.\n * @param context the global context in which the node's result should be evaluated. This context\n *   contains information about the whole survey - The evaluation needs this to known the values of\n *   references to other survey nodes (e.g. when you use a variable like `${other-field}` in the\n *   formula)\n */\nexport default function evaluateNodeColumn(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  columnName: EvaluatableColumnName,\n  fallback: unknown\n): ODKFormulaEvaluationResult {\n  const originalFormula = node.row?.[columnName];\n  if (originalFormula !== undefined && typeof originalFormula !== \"string\") {\n    debugger;\n    throw new Error(\"Sorry, multilingual formulas are not supported yet.\");\n  }\n  const formula = originalFormula?.trim();\n  if (formula === \"\" || formula === undefined) {\n    const fallbackValue = fallback;\n    const isMultiSelectResult = node.type === \"select_multiple\";\n    const value =\n      isMultiSelectResult && fallbackValue instanceof Array\n        ? fallbackValue.join(\" \")\n        : fallbackValue;\n    return {\n      state: \"success\",\n      result: value,\n      expression: new LiteralExpression(\n        [],\n        value instanceof Array ? \"array\" : typeof value,\n        value\n      ),\n      error: undefined,\n    };\n  }\n  const row = node.row;\n  let evaluationResult: ODKFormulaEvaluationResult | undefined = undefined;\n  try {\n    evaluationResult = evaluateODKFormula(formula, context, node);\n  } catch (error) {\n    debugger;\n    throw new EvaluationError(\n      `Error in \\`${columnName}\\` column of the ‘${row?.name}’ question (row #${node.rowIndex}). It contains the formula \\`${row?.[columnName]}\\`. Please ensure the formula is valid. The error was: ${error}`,\n      \"calculationError\",\n      evaluationResult?.expression,\n      context,\n      node,\n      error\n    );\n  }\n  return evaluationResult;\n}\n","import {\n  EvaluatableColumnName,\n  evaluatableColumnNames,\n  ODKNode,\n} from \"../types/ODKNode\";\nimport { XLSForm } from \"../types/XLSForm\";\nimport evaluateNodeColumn from \"./odk-formulas/evaluation/evaluateNodeColumn\";\nimport ODKFormulaEvaluationContext from \"./odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport ODKFormulaEvaluationResult from \"./odk-formulas/evaluation/ODKFormulaEvaluationResult\";\n\nexport function evaluateNodeAndChildren(\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext,\n  onEval: (\n    node: ODKNode,\n    columnName: EvaluatableColumnName,\n    result: ODKFormulaEvaluationResult\n  ) => void\n): void {\n  const fallbacks: Record<EvaluatableColumnName, unknown> = {\n    relevant: true,\n    calculation: context.nodesToAnswers.get(node),\n    required: false,\n    readonly: false,\n    constraint: true,\n  };\n\n  evaluatableColumnNames.forEach((columnName) => {\n    onEval(\n      node,\n      columnName,\n      evaluateNodeColumn(node, context, columnName, fallbacks[columnName])\n    );\n  });\n  node.children?.forEach((child) =>\n    evaluateNodeAndChildren(child, context, onEval)\n  );\n}\n\nexport default function getEvaluatedXLSFormResult(\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext\n) {\n  evaluateNodeAndChildren(\n    xlsForm.rootSurveyGroup,\n    context,\n    (node, columnName, result) => {\n      // console.log(\"Eval\", { name: node.row.name, columnName, result });\n      let columnNamesToResults = context.evaluationResults.get(node);\n      if (!columnNamesToResults) {\n        columnNamesToResults = new Map();\n        context.evaluationResults.set(node, columnNamesToResults);\n      }\n      columnNamesToResults?.set(columnName, result);\n    }\n  );\n}\n","import { XLSForm } from \"../xlsform-simple-schema\";\nimport { QuestionRow } from \"../xlsform-simple-schema/types/RowTypes\";\nimport { createLabelInAllLanguages } from \"./createLabelInAllLanguages\";\n\nlet untitledFieldIndex = 0;\n\nexport function createEmptyFieldRow(xlsForm: XLSForm): QuestionRow {\n  return {\n    type: \"text\",\n    name: `untitled_field_${untitledFieldIndex++}`,\n    label: createLabelInAllLanguages(\"\", xlsForm.languages),\n  };\n}\n","import { createLabelInAllLanguages } from \"../lib/createLabelInAllLanguages\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport {\n  BeginMarkerRow,\n  IEndGroupMarkerRow,\n} from \"../xlsform-simple-schema/types/BeginOrEndMarkerRow\";\n\nlet untitledGroupIndex = 0;\n\nexport function createEmptyGroupRows(xlsForm: XLSForm) {\n  untitledGroupIndex += 1;\n  const beginMarkerRow: BeginMarkerRow = {\n    type: \"begin_group\",\n    name: `untitled_group_${untitledGroupIndex}`,\n    label: createLabelInAllLanguages(\"\", xlsForm.languages),\n  };\n  const endMarkerRow: IEndGroupMarkerRow = { type: \"end_group\" };\n  return { beginMarkerRow, endMarkerRow };\n}\n","import { isEqual } from \"lodash\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\n\nexport default function getLastRowIndexOfNode(xlsForm: XLSForm, node: ODKNode) {\n  const isGroup = isGroupNode(node);\n\n  if (!isGroup) {\n    return node.rowIndex;\n  }\n  // The end_group or end_repeat marker is associated to the node, too.\n  const indexOfGroupOrRepeatEnd = xlsForm.flatNodes.findIndex(\n    (n, i) => i > node.rowIndex && isEqual(n, node)\n  );\n  return indexOfGroupOrRepeatEnd;\n}\n","import { Code } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { useEffect, useState } from \"react\";\nimport { FieldProps } from \"../survey/FieldProps\";\nimport { AppToaster } from \"../toaster\";\nimport {\n  ChoicesWorksheet,\n  loadXLSFormFromRows,\n  SettingsWorksheet,\n  SurveyWorksheet,\n  WorksheetName,\n  XLSForm,\n} from \"../xlsform-simple-schema\";\nimport getEvaluatedXLSFormResult from \"../xlsform-simple-schema/functions/evaluateNodeAndChildren\";\nimport ODKFormulaEvaluationContext, {\n  getEmptyContext,\n  knownLiteralsWithoutDollarSign,\n} from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeIndexPath } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport patchXLSFormCell from \"../xlsform-simple-schema/functions/patchXLSFormCell\";\nimport { isGroupNode, ODKNode } from \"../xlsform-simple-schema/types/ODKNode\";\nimport { QuestionRow } from \"../xlsform-simple-schema/types/RowTypes\";\nimport { createEmptyFieldRow } from \"./createUntitledFieldRow\";\nimport { createEmptyGroupRows } from \"./createUntitledGroupRows\";\nimport findOrReplaceFieldReferences from \"./findOrReplaceFieldReferences\";\nimport getLastRowIndexOfNode from \"./getLastRowIndexOfNode\";\n\ntype RowSpliceOperation = {\n  rowIndex: number;\n  numberOfRowsToRemove: number;\n  rowsToAdd: any[];\n};\n\nexport default function useChangeHooks({\n  xlsForm,\n  language,\n  setXLSForm,\n}: {\n  xlsForm?: XLSForm;\n  language?: string;\n  setXLSForm: (value: React.SetStateAction<XLSForm | undefined>) => void;\n}) {\n  const [context, setContext] = useState<ODKFormulaEvaluationContext>();\n\n  useEffect(() => {\n    if (!xlsForm) {\n      setContext(undefined);\n      return;\n    }\n\n    setContext((context) => {\n      if (context && context.survey === xlsForm.rootSurveyGroup) {\n        console.log(\n          \"Context exists already and survey is the same, keeping context.\"\n        );\n        return context;\n      }\n\n      const newContext = getEmptyContext(xlsForm.rootSurveyGroup);\n      newContext.nodesToAnswers = new Map();\n      newContext.survey = xlsForm.rootSurveyGroup;\n      newContext.stackDepth = 0;\n      newContext.knownLiteralsWithoutDollarSign = knownLiteralsWithoutDollarSign;\n      getEvaluatedXLSFormResult(xlsForm, newContext);\n      console.log(\"Setting up new evaluation context\", newContext);\n      return newContext;\n    });\n  }, [xlsForm, xlsForm?.rootSurveyGroup]);\n\n  const onChangeAnswer = React.useCallback(\n    (value: unknown, fieldProps: FieldProps) => {\n      AppToaster.clear();\n      AppToaster.show({\n        message: (\n          <>\n            {fieldProps.schemaKey} → <Code>{JSON.stringify(value)}</Code>\n          </>\n        ),\n      });\n      if (xlsForm && context) {\n        setContext((context) => {\n          if (!context) {\n            return;\n          }\n          const nodesToAnswers = new Map<ODKNode, unknown>(\n            context.nodesToAnswers.entries()\n          );\n          nodesToAnswers.set(fieldProps.node, value);\n          const newContext: ODKFormulaEvaluationContext = {\n            ...context,\n            nodesToAnswers,\n          };\n          getEvaluatedXLSFormResult(xlsForm, newContext);\n          return newContext;\n        });\n      }\n    },\n    [context, xlsForm]\n  );\n\n  const onChangeCell = React.useCallback(\n    (\n      worksheetName: WorksheetName,\n      rowIndex: number,\n      columnName: string,\n      value: unknown,\n      node?: ODKNode\n    ) => {\n      if (!xlsForm || !context || !language) {\n        return;\n      }\n      setXLSForm(\n        patchXLSFormCell({\n          worksheetName,\n          xlsForm,\n          node,\n          rowIndex,\n          columnName,\n          language,\n          value,\n          context,\n        })\n      );\n    },\n    [xlsForm, context, language, setXLSForm]\n  );\n\n  const onSpliceRows = React.useCallback(\n    (worksheetName: WorksheetName, operations: RowSpliceOperation[]) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n\n      setXLSForm((xlsForm: XLSForm | undefined) => {\n        const surveyWorksheet = xlsForm?.worksheets.survey;\n        if (!surveyWorksheet) {\n          throw new Error(\"No survey worksheet defined.\");\n        }\n        const worksheet = xlsForm?.worksheets[worksheetName];\n        if (!worksheet) {\n          return xlsForm;\n        }\n        const newRows = [...worksheet?.rows];\n        operations.forEach(({ rowIndex, numberOfRowsToRemove, rowsToAdd }) =>\n          newRows.splice(rowIndex, numberOfRowsToRemove, ...rowsToAdd)\n        );\n        const newWorksheet = { ...worksheet, rows: newRows };\n        return loadXLSFormFromRows(\n          worksheetName === \"survey\"\n            ? (newWorksheet as SurveyWorksheet)\n            : surveyWorksheet,\n          xlsForm?.worksheets.settings?.rows[0]?.default_language ||\n            \"English (en)\",\n          worksheetName === \"settings\"\n            ? (newWorksheet as SettingsWorksheet)\n            : xlsForm?.worksheets.settings,\n          worksheetName === \"choices\"\n            ? (newWorksheet as ChoicesWorksheet)\n            : xlsForm?.worksheets.choices\n        );\n      });\n    },\n    [context, setXLSForm, xlsForm]\n  );\n\n  const onRemoveRowAndChildren = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const indexPath = getNodeIndexPath(node, context);\n      if (!indexPath) {\n        throw new Error(\n          \"Can’t remove a node that isn’t reachable from survey root. Please ensure the node is actually part of the survey.\"\n        );\n      }\n      const numberOfRowsToRemove =\n        getLastRowIndexOfNode(xlsForm, node) - node.rowIndex + 1;\n      const { rowIndex } = node;\n      onSpliceRows(\"survey\", [\n        {\n          rowIndex,\n          numberOfRowsToRemove,\n          rowsToAdd: [],\n        },\n      ]);\n    },\n    [context, onSpliceRows, xlsForm]\n  );\n\n  const onRenameNode = React.useCallback(\n    (node: ODKNode, newName: string) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      findOrReplaceFieldReferences(xlsForm, node, newName).forEach(\n        ({ index: rowIndex, row }) => {\n          onSpliceRows(\"survey\", [\n            {\n              rowIndex,\n              numberOfRowsToRemove: 1,\n              rowsToAdd: [{ ...row }],\n            },\n          ]);\n        }\n      );\n      onSpliceRows(\"survey\", [\n        {\n          rowIndex: node.rowIndex,\n          numberOfRowsToRemove: 1,\n          rowsToAdd: [{ ...node.row, name: newName }],\n        },\n      ]);\n    },\n    [context, onSpliceRows, xlsForm]\n  );\n\n  const onNestNode = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const { beginMarkerRow, endMarkerRow } = createEmptyGroupRows(xlsForm);\n      const firstIndex = node.rowIndex;\n      const lastIndex = getLastRowIndexOfNode(xlsForm, node);\n\n      onSpliceRows(\"survey\", [\n        // Note that splicing changes indexes, so splicing the last row first is important.\n        {\n          rowIndex: lastIndex + 1,\n          numberOfRowsToRemove: 0,\n          rowsToAdd: [endMarkerRow],\n        },\n        {\n          rowIndex: firstIndex,\n          numberOfRowsToRemove: 0,\n          rowsToAdd: [beginMarkerRow],\n        },\n      ]);\n    },\n    [context, onSpliceRows, xlsForm]\n  );\n\n  const onUngroupNode = React.useCallback(\n    (node: ODKNode) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const firstIndex = node.rowIndex;\n      const lastIndex = getLastRowIndexOfNode(xlsForm, node);\n      onSpliceRows(\"survey\", [\n        // Note that splicing changes indexes, so removing last row first is important.\n        {\n          rowIndex: lastIndex,\n          numberOfRowsToRemove: 1,\n          rowsToAdd: [],\n        },\n        {\n          rowIndex: firstIndex,\n          numberOfRowsToRemove: 1,\n          rowsToAdd: [],\n        },\n      ]);\n    },\n    [context, onSpliceRows, xlsForm]\n  );\n\n  const onAddNode = React.useCallback(\n    ({\n      position,\n      node,\n      group,\n    }: {\n      position: \"before\" | \"after\" | \"inside\";\n      node: ODKNode;\n      group: boolean;\n    }) => {\n      if (!xlsForm || !context) {\n        return;\n      }\n      const row: QuestionRow = createEmptyFieldRow(xlsForm);\n      const { beginMarkerRow, endMarkerRow } = createEmptyGroupRows(xlsForm);\n      const rowsToInsert = group ? [beginMarkerRow, row, endMarkerRow] : [row];\n\n      let rowIndex = 0;\n      const currentNodeIsGroup = isGroupNode(node);\n      if (currentNodeIsGroup) {\n        rowIndex = {\n          after: getLastRowIndexOfNode(xlsForm, node) + 1,\n          before: node.rowIndex,\n          inside: node.rowIndex + 1,\n        }[position];\n      } else {\n        rowIndex = {\n          after: node.rowIndex + 1,\n          before: node.rowIndex,\n          inside: 0,\n        }[position];\n      }\n      onSpliceRows(\"survey\", [\n        {\n          rowIndex,\n          numberOfRowsToRemove: 0,\n          rowsToAdd: rowsToInsert,\n        },\n      ]);\n    },\n    [context, onSpliceRows, xlsForm]\n  );\n\n  const onMoveNode = React.useCallback(\n    ({\n      sourcePath,\n      sourceNode,\n      destinationNode,\n      position,\n    }: {\n      sourcePath: string;\n      sourceNode: ODKNode;\n      destinationNode: ODKNode;\n      position: \"before\" | \"after\" | \"inside\";\n    }) => {\n      if (!xlsForm || !context || !language) {\n        return;\n      }\n      const lastRowIndexOfSourceNode = getLastRowIndexOfNode(\n        xlsForm,\n        sourceNode\n      );\n      const numberOfSourceNodeRows =\n        lastRowIndexOfSourceNode - sourceNode.rowIndex + 1;\n      const rowsOfSourceNode = [...xlsForm.worksheets.survey.rows].slice(\n        sourceNode.rowIndex,\n        sourceNode.rowIndex + numberOfSourceNodeRows\n      );\n      const destinationIsBeforeSource =\n        destinationNode.rowIndex < sourceNode.rowIndex;\n      const insertOperation: RowSpliceOperation = {\n        rowIndex: destinationNode.rowIndex,\n        numberOfRowsToRemove: 0,\n        rowsToAdd: rowsOfSourceNode,\n      };\n      const removeOperation: RowSpliceOperation = {\n        rowIndex:\n          sourceNode.rowIndex +\n          (destinationIsBeforeSource ? numberOfSourceNodeRows : 0),\n        numberOfRowsToRemove: numberOfSourceNodeRows,\n        rowsToAdd: [],\n      };\n\n      onSpliceRows(\"survey\", [insertOperation, removeOperation]);\n    },\n    [context, language, onSpliceRows, xlsForm]\n  );\n\n  return {\n    context,\n    setContext,\n    onChangeAnswer,\n    onChangeCell,\n    onMoveNode,\n    onSpliceRows,\n    onRemoveRowAndChildren,\n    onRenameNode,\n    onNestNode,\n    onUngroupNode,\n    onAddNode,\n  };\n}\n","import produce from \"immer\";\nimport { set } from \"lodash\";\nimport { ODKNode } from \"../types/ODKNode\";\nimport { WorksheetName, XLSForm } from \"../types/XLSForm\";\nimport { localizableColumnNames } from \"./loadSurveyFromXLSX\";\nimport ODKFormulaEvaluationContext from \"./odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeIndexPath } from \"./odk-formulas/evaluation/XPath\";\n\nexport default function patchXLSFormCell({\n  worksheetName,\n  xlsForm,\n  rowIndex,\n  node,\n  context,\n  language,\n  columnName,\n  value,\n}: {\n  worksheetName: WorksheetName;\n  xlsForm: XLSForm;\n  node?: ODKNode;\n  rowIndex: number;\n  context: ODKFormulaEvaluationContext;\n  language: string;\n  columnName: string;\n  value: unknown;\n}) {\n  const indexPath = node && getNodeIndexPath(node, context);\n  const valuePathInRow = localizableColumnNames.includes(columnName)\n    ? [columnName, language]\n    : [columnName];\n\n  const changeIsInSurveyWorksheet = worksheetName === \"survey\";\n\n  return produce(xlsForm, (draft) => {\n    set(\n      draft,\n      [\"worksheets\", worksheetName, \"rows\", rowIndex, ...valuePathInRow],\n      value\n    );\n\n    if (changeIsInSurveyWorksheet) {\n      set(draft, [\"flatNodes\", rowIndex, \"row\", ...valuePathInRow], value);\n      if (indexPath) {\n        set(\n          draft,\n          [\n            \"rootSurveyGroup\",\n            ...indexPath.map((i) => [\"children\", i]).flat(),\n            \"row\",\n            ...valuePathInRow,\n          ],\n          value\n        );\n      }\n    }\n  });\n}\n","import React from \"react\";\nimport { Alignment, Button, ButtonGroup, Navbar } from \"@blueprintjs/core\";\nimport { WorksheetName } from \"./xlsform-simple-schema\";\n\nexport function SheetTabs({\n  setWorksheetName,\n  worksheetName,\n}: {\n  setWorksheetName: React.Dispatch<React.SetStateAction<WorksheetName>>;\n  worksheetName: string;\n}) {\n  return (\n    <Navbar.Group align={Alignment.LEFT}>\n      <ButtonGroup>\n        <Button\n          onClick={() => setWorksheetName(\"survey\")}\n          active={worksheetName === \"survey\"}\n        >\n          Survey\n        </Button>\n        <Button\n          onClick={() => setWorksheetName(\"choices\")}\n          active={worksheetName === \"choices\"}\n        >\n          Choices\n        </Button>\n        <Button\n          onClick={() => setWorksheetName(\"settings\")}\n          active={worksheetName === \"settings\"}\n        >\n          Settings\n        </Button>\n      </ButtonGroup>\n    </Navbar.Group>\n  );\n}\n","import { HTMLDivProps } from '@blueprintjs/core';\nimport * as React from 'react';\n\nexport default function PaddedContainer(props: HTMLDivProps & {\n    horizontal: number,\n    vertical: number,\n}) {\n    return <div {...{props}} style={{ margin: `${props.horizontal}rem ${props.vertical}rem`, ...props.style}}>\n        {props.children}\n    </div>;\n}","import { Callout } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\nexport default function ObjectArrayField(props: FieldProps) {\n  return (\n    <Callout intent={\"warning\"}>\n      <h4>Object arrays are not implemented yet.</h4>\n    </Callout>\n  );\n}\n","import {\n  Callout,\n  ControlGroup,\n  EditableText,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n} from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { isNodeRelevant } from \"../../xlsform-simple-schema/types/ODKNode\";\nimport DetailsPopover from \"../DetailsPopover/DetailsPopover\";\nimport { FieldProps } from \"../FieldProps\";\nimport { FieldSetForKey } from \"../FieldSetForKey\";\n\nexport default function ObjectField(props: FieldProps) {\n  const { onChangeCell } = React.useContext(ODKSurveyContext);\n  const { schema, schemaKey, node } = props;\n  const subKeys = schema.objectKeys(schemaKey);\n  const context = React.useContext(ODKSurveyContext);\n  const { debug } = context;\n\n  const label =\n    node === context.context?.survey\n      ? context.xlsForm?.worksheets.settings?.rows[0].form_title\n      : schema.get(schemaKey, \"label\");\n  const path =\n    context.context && getNodeAbsolutePath(node, context.context).join(\"/\");\n\n  const onChangeSurveyName = React.useCallback(\n    (text: string) => {\n      if (text === label || (label === undefined && text === \"\")) {\n        return;\n      }\n      onChangeCell(\"settings\", 0, \"form_title\", text);\n    },\n    [onChangeCell, label]\n  );\n\n  const onChangeLabel = React.useCallback(\n    (text: string) => {\n      if (text === label || (label === undefined && text === \"\")) {\n        return;\n      }\n      onChangeCell(\"survey\", node.rowIndex, \"label\", text, node);\n    },\n    [node, onChangeCell, label]\n  );\n\n  const labelInput =\n    node === context.context?.survey ? (\n      <EditableText\n        onChange={onChangeSurveyName}\n        onConfirm={onChangeSurveyName}\n        placeholder={`Enter a survey title…`}\n        value={label}\n        minWidth={100}\n      />\n    ) : (\n      <EditableText\n        multiline={true}\n        onChange={onChangeLabel}\n        onConfirm={onChangeLabel}\n        placeholder={`Enter a title for \\`${node.row.name}\\`in ${context.languageName}…`}\n        value={label}\n        minWidth={100}\n      />\n    );\n\n  const HeadingClass = [H1, H2, H3, H4, H5][node.indentationLevel] || H5;\n\n  const hintString =\n    typeof context.language === \"string\" && node.row.hint?.[context.language];\n\n  const isRelevant = isNodeRelevant(node, context.context);\n  if (!isRelevant && !debug) {\n    return null;\n  }\n  return (\n    <ControlGroup\n      vertical={true}\n      style={{ padding: `${6 / (node.indentationLevel + 1)}rem 0` }}\n    >\n      <ControlGroup\n        fill={false}\n        style={{\n          alignItems: \"baseline\",\n        }}\n      >\n        <HeadingClass\n          style={{\n            flex: 1,\n          }}\n          id={path}\n        >\n          {debug ? <>{labelInput}</> : label}\n        </HeadingClass>\n        {debug && node !== context.context?.survey && (\n          <DetailsPopover {...{ ...props }} editable={true} />\n        )}\n      </ControlGroup>\n\n      {subKeys.map((subkey) => (\n        <FieldSetForKey\n          key={subkey}\n          schemaKey={[schemaKey, subkey].join(\".\")}\n          relevant={props.relevant}\n          readonly={props.readonly}\n        />\n      ))}\n\n      {hintString && <Callout intent={\"primary\"}>{hintString}</Callout>}\n    </ControlGroup>\n  );\n}\n","export const internalFields = [\n  undefined,\n  \"\",\n  \"start\",\n  \"end\",\n  \"today\",\n  \"username\",\n  \"simserial\",\n  \"subscriberid\",\n  \"deviceid\",\n  \"phonenumber\",\n  \"calculate\",\n];\n","import { Callout, Checkbox, Code } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function BooleanField(props: Props) {\n  const { value, labelElement, relevant, readonly } = props;\n\n  //   const context = React.useContext(ODKSurveyContext);\n  if (value !== undefined && typeof value !== \"boolean\") {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>boolean</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n  return (\n    <Checkbox\n      large={true}\n      disabled={relevant === false || readonly}\n      labelElement={labelElement}\n      onChange={props.onInputChange}\n      defaultChecked={\n        typeof props.defaultValue === \"boolean\" ? props.defaultValue : undefined\n      }\n    />\n  );\n}\n","import { Callout, Checkbox, Code, ControlGroup } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldConfigurationButton } from \"../DetailsPopover/FieldConfigurationButton\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  value: unknown;\n  allowedValues: string[];\n};\n\nexport default function CheckboxGroupField(props: Props) {\n  const { value, node, relevant, readonly } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { language, onChangeAnswer } = context;\n\n  const valueIsInvalid =\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    (!(value instanceof Array) ||\n      value.find((element) => typeof element !== \"string\"));\n\n  const choices = React.useMemo<Set<string>>(() => {\n    if (typeof value === \"string\") {\n      return new Set<string>(value === \"\" ? [] : value?.split(\" \"));\n    }\n    if (value instanceof Array || value instanceof Set) {\n      return new Set<string>(value);\n    }\n    return new Set<string>();\n  }, [value]);\n\n  const onChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const choice = event.currentTarget.name;\n      const newChoices = new Set(choices);\n      if (event.currentTarget.checked) {\n        newChoices.add(choice);\n      } else {\n        newChoices.delete(choice);\n      }\n      onChangeAnswer(Array.from(newChoices), props);\n    },\n    [props, onChangeAnswer, choices]\n  );\n\n  if (typeof language !== \"string\") {\n    return null;\n  }\n\n  if (valueIsInvalid) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> or Array of <Code>string</Code>s\n          for this field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  if (context.debug && node.typeParameters.length === 0) {\n    return (\n      <Callout intent=\"warning\" title=\"No choice list set.\">\n        <FieldConfigurationButton node={node} showType={false} />\n      </Callout>\n    );\n  }\n\n  return (\n    <ControlGroup vertical={true}>\n      {node.typeParameters.map((choiceListName) => {\n        const choiceList = context.xlsForm?.choicesByName[choiceListName];\n        if (!choiceList) {\n          return null;\n        }\n        return Object.keys(choiceList).map((value) => {\n          const choiceRow = choiceList[value];\n\n          const definedLabel = choiceRow?.label?.[language];\n          const shownLabel =\n            definedLabel === \"undefined\" ? choiceRow?.name : definedLabel;\n          return (\n            <Checkbox\n              disabled={relevant === false || readonly}\n              label={shownLabel}\n              checked={typeof value === \"string\" && choices.has(value)}\n              name={value}\n              inline={true}\n              large={true}\n              onChange={onChange}\n            />\n          );\n        });\n      })}\n    </ControlGroup>\n  );\n}\n","import { Callout, Code } from \"@blueprintjs/core\";\nimport { DateInput, IDateFormatProps } from \"@blueprintjs/datetime\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nconst jsDateFormatter: IDateFormatProps = {\n  // note that the native implementation of Date functions differs between browsers\n  formatDate: (date: Date) => date.toLocaleDateString(),\n  parseDate: (str: string) => (str.length ? new Date(str) : null),\n  placeholder: \"YYYY-MM-DD\",\n};\n\nexport default function DateField(props: Props) {\n  const { value, relevant, readonly } = props;\n  const { onChangeAnswer } = React.useContext(ODKSurveyContext);\n\n  const onChange = React.useCallback(\n    (selectedDate: Date, isUserChange: boolean) => {\n      if (isUserChange) {\n        onChangeAnswer(selectedDate, props);\n      }\n    },\n    [props, onChangeAnswer]\n  );\n\n  if (value !== undefined && !(value instanceof Date)) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>Date</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n\n  let defaultValue = undefined;\n  if (typeof props.defaultValue === \"string\") {\n    defaultValue = jsDateFormatter.parseDate(props.defaultValue);\n  } else if (props.defaultValue instanceof Date) {\n    defaultValue = props.defaultValue;\n  }\n\n  return (\n    <DateInput\n      {...jsDateFormatter}\n      onChange={onChange}\n      defaultValue={defaultValue || undefined}\n      disabled={relevant === false || readonly}\n    />\n  );\n}\n","import { Classes, ControlGroup, EditableText } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport StyledMarkdown from \"../../components/StyledMarkdown\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { getNodeAbsolutePath } from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport { FieldProps } from \"../FieldProps\";\n\nexport function Label(\n  props: FieldProps & {\n    debug: boolean;\n    minimal?: boolean;\n    children: React.ReactNode;\n    isEditable: boolean;\n  }\n) {\n  const {\n    schema,\n    schemaKey,\n    node,\n    debug,\n    relevant,\n    isEditable,\n    children,\n  } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const label = node.row.label?.[context.language || \"English (en)\"];\n  const evaluatedLabel = schema.get(schemaKey, \"label\");\n  const { onChangeCell } = React.useContext(ODKSurveyContext);\n  const path =\n    context.context && getNodeAbsolutePath(node, context.context).join(\"/\");\n  const [editedLabel, setEditedLabel] = React.useState(label);\n\n  const onChangeLabel = React.useCallback((text: string) => {\n    setEditedLabel(text);\n  }, []);\n\n  React.useEffect(() => {\n    setEditedLabel(label);\n  }, [label]);\n\n  const onConfirmLabel = React.useCallback(\n    (text: string) => {\n      if (text === label || (label === undefined && text === \"\")) {\n        return;\n      }\n      onChangeCell(\"survey\", node.rowIndex, \"label\", text, node);\n    },\n    [node, onChangeCell, label]\n  );\n\n  let labelInput =\n    isEditable && debug ? (\n      <EditableText\n        onChange={onChangeLabel}\n        onConfirm={onConfirmLabel}\n        placeholder={`Enter a title for \\`${node.row.name}\\` in ${context.languageName}…`}\n        value={editedLabel}\n        minWidth={100}\n        minLines={1}\n        maxLines={5}\n        multiline={true}\n      />\n    ) : (\n      evaluatedLabel\n    );\n\n  if (children) {\n    return (\n      <ControlGroup\n        style={{ alignItems: \"center\" }}\n        lang={context.languageCode}\n      >\n        {\n          <span\n            id={path}\n            className={relevant ? \"\" : Classes.TEXT_DISABLED}\n            style={{ flex: 1 }}\n          >\n            {debug ? (\n              labelInput\n            ) : (\n              <StyledMarkdown>{evaluatedLabel}</StyledMarkdown>\n            )}\n          </span>\n        }\n        {children}\n      </ControlGroup>\n    );\n  } else {\n    return (\n      <span\n        id={path}\n        className={relevant ? \"\" : Classes.TEXT_DISABLED}\n        style={{ flex: 1 }}\n        lang={context.languageCode}\n      >\n        {debug ? labelInput : <StyledMarkdown>{evaluatedLabel}</StyledMarkdown>}\n      </span>\n    );\n  }\n}\n","import { Callout, Code, NumericInput } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function NumberField(props: Props) {\n  const { value, schemaKey, relevant, readonly } = props;\n  const { onChangeAnswer } = React.useContext(ODKSurveyContext);\n  const onChange = React.useCallback(\n    (valueAsNumber: number) => {\n      onChangeAnswer(valueAsNumber, props);\n    },\n    [props, onChangeAnswer]\n  );\n\n  if (\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    typeof value !== \"number\"\n  ) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>number</Code> for this field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  return (\n    <NumericInput\n      id={schemaKey}\n      disabled={relevant === false || readonly}\n      name={schemaKey}\n      large={true}\n      allowNumericCharactersOnly={false}\n      placeholder=\"Enter a number…\"\n      value={value}\n      onValueChange={onChange}\n      defaultValue={\n        typeof props.defaultValue === \"number\" ||\n        typeof props.defaultValue === \"string\"\n          ? props.defaultValue\n          : undefined\n      }\n    />\n  );\n}\n","import {\n  Callout,\n  Code,\n  ControlGroup,\n  H4,\n  Radio,\n  RadioGroup,\n} from \"@blueprintjs/core\";\nimport { FLEX_EXPANDER } from \"@blueprintjs/core/lib/esm/common/classes\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport { FieldConfigurationButton } from \"../DetailsPopover/FieldConfigurationButton\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  value: unknown;\n  defaultValue: unknown;\n  allowedValues: string[];\n};\n\nexport default function RadioGroupField(props: Props) {\n  const {\n    value,\n    onInputChange,\n    allowedValues,\n    node,\n    relevant,\n    readonly,\n  } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { language } = context;\n\n  if (value !== undefined && typeof value !== \"string\") {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> for this field to work\n        </h4>\n      </Callout>\n    );\n  }\n\n  if (language === undefined) {\n    return null;\n  }\n\n  if (context.debug && node.typeParameters.length === 0) {\n    return (\n      <Callout intent=\"warning\">\n        <ControlGroup fill={true}>\n          <H4>No choice list set.</H4>\n          <div className={FLEX_EXPANDER} />\n          <FieldConfigurationButton node={node} showType={false} />\n        </ControlGroup>\n      </Callout>\n    );\n  }\n\n  return (\n    <RadioGroup\n      // label={labelElement}\n      onChange={onInputChange}\n      selectedValue={value}\n      inline={true}\n      disabled={relevant === false || readonly}\n    >\n      {allowedValues.map((value) => {\n        const choiceListName = node.typeParameters[0];\n        const choiceRow =\n          context.xlsForm?.choicesByName[choiceListName]?.[value];\n        const definedLabel = choiceRow?.label?.[language];\n        const shownLabel =\n          definedLabel === \"undefined\" ? choiceRow?.name : definedLabel;\n        return (\n          <Radio\n            label={shownLabel}\n            value={choiceRow?.name}\n            inline={true}\n            large={true}\n          />\n        );\n      })}\n    </RadioGroup>\n  );\n}\n","import { Callout, Code, InputGroup } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { FieldProps } from \"../FieldProps\";\n\ntype Props = FieldProps & {\n  onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  labelElement: React.ReactNode;\n  value: unknown;\n  defaultValue: unknown;\n};\n\nexport default function TextField(props: Props) {\n  const { value, schemaKey, relevant, readonly } = props;\n\n  if (\n    value !== undefined &&\n    typeof value !== \"string\" &&\n    typeof value !== \"number\"\n  ) {\n    return (\n      <Callout intent=\"warning\">\n        <h4>\n          Value must be a <Code>string</Code> or <Code>number</Code> for this\n          field to work.\n        </h4>\n      </Callout>\n    );\n  }\n\n  return (\n    <InputGroup\n      id={schemaKey}\n      disabled={relevant === false || readonly}\n      name={schemaKey}\n      placeholder=\"\"\n      large={true}\n      onChange={props.onInputChange}\n      defaultValue={\n        typeof props.defaultValue === \"string\" ? props.defaultValue : undefined\n      }\n    />\n  );\n}\n","import { Callout, FormGroup } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { ODKSurveyContext } from \"../../lib/ODKSurveyContext\";\nimport evaluateNodeColumn from \"../../xlsform-simple-schema/functions/odk-formulas/evaluation/evaluateNodeColumn\";\nimport DetailsPopover from \"../DetailsPopover/DetailsPopover\";\nimport { FieldProps } from \"../FieldProps\";\nimport { internalFields } from \"../internalFields\";\nimport BooleanField from \"./BooleanField\";\nimport CheckboxGroupField from \"./CheckboxGroupField\";\nimport DateField from \"./DateField\";\nimport { Label } from \"./Label\";\nimport NumberField from \"./NumberField\";\nimport RadioGroupField from \"./RadioGroupField\";\nimport TextField from \"./TextField\";\n\nexport function AutoField(\n  props: FieldProps & {\n    value: unknown;\n    defaultValue: unknown;\n    onInputChange: (event: React.FormEvent<HTMLInputElement>) => void;\n    labelElement: JSX.Element;\n  }\n) {\n  const { quickType, schema, schemaKey } = props;\n  if (quickType === \"number\") {\n    return <NumberField {...props} />;\n  } else if (quickType === \"date\") {\n    return <DateField {...props} />;\n  } else if (quickType === \"boolean\") {\n    return <BooleanField {...props} />;\n  }\n\n  if (quickType === \"stringArray\") {\n    const allowedValues = schema.get(schemaKey + \".$\", \"allowedValues\");\n    if (allowedValues instanceof Array) {\n      return <CheckboxGroupField {...{ ...props, allowedValues }} />;\n    }\n  }\n  const allowedValues = schema.get(schemaKey, \"allowedValues\");\n  if (allowedValues instanceof Array) {\n    return <RadioGroupField {...{ ...props, allowedValues }} />;\n  }\n\n  return <TextField {...props} />;\n}\n\nexport default function ValueField(props: FieldProps) {\n  const { node } = props;\n  const isBoolean = props.quickType === \"boolean\";\n  const context = React.useContext(ODKSurveyContext);\n  const {\n    language,\n    debug,\n    context: evaluationContext,\n    onChangeAnswer,\n  } = context;\n\n  const onInputChange = React.useCallback(\n    (event: React.FormEvent<HTMLInputElement>) => {\n      const target = event.currentTarget;\n      const values: Record<string, unknown> = {\n        checkbox: target.checked,\n        date: target.valueAsDate,\n        number: target.valueAsNumber,\n        text: target.value,\n        radio: target.value,\n      };\n      const value = values[target.type];\n      onChangeAnswer(value, props);\n    },\n    [onChangeAnswer, props]\n  );\n\n  if (!language || !evaluationContext) {\n    return null;\n  }\n\n  const isInternalField = internalFields.includes(node.type);\n  if (isInternalField && !context.debug) {\n    return null;\n  }\n\n  const detailsButton = <DetailsPopover {...{ ...props }} editable={true} />;\n  const hintString = node.row.hint?.[language] && (\n    <Callout intent=\"primary\">{node.row.hint?.[language]}</Callout>\n  );\n  const labelElement = (\n    <Label {...{ ...props, debug, isEditable: !isBoolean && !isInternalField }}>\n      {props.quickType !== \"boolean\" && debug && detailsButton}\n    </Label>\n  );\n  const evaluationResult = evaluateNodeColumn(\n    node,\n    evaluationContext,\n    \"calculation\",\n    evaluationContext.nodesToAnswers.get(node)\n  );\n  const autoFieldProps = {\n    ...props,\n    labelElement,\n    onInputChange,\n    value: evaluationResult.result,\n    defaultValue: node.row.default,\n  };\n\n  let input = <AutoField {...autoFieldProps} />;\n  if (isBoolean) {\n    return (\n      <FormGroup\n        // helperText={hintString}\n        labelFor={node.row.name}\n        style={{ display: \"flex\" }}\n      >\n        {debug && detailsButton}\n        {input}\n        {hintString}\n      </FormGroup>\n    );\n  }\n\n  if (node.type === \"note\") {\n    return labelElement;\n  }\n  return (\n    <FormGroup\n      // helperText={hintString}\n      label={labelElement}\n      labelFor={node.row.name}\n    >\n      {input}\n      {hintString}\n    </FormGroup>\n  );\n}\n","import {\n  Callout,\n  Classes,\n  Code,\n  Colors,\n  H4,\n  Menu,\n  MenuDivider,\n  MenuItem,\n} from \"@blueprintjs/core\";\nimport { ContextMenu2, Popover2 } from \"@blueprintjs/popover2\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport { alpha } from \"../lib/colors\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport useNodeDeletionDialog from \"../lib/useNodeDeletionDialog\";\nimport useRenameNodeDialog from \"../lib/useRenameNodeDialog\";\nimport { findNodeByPathRelativeToScope } from \"../xlsform-simple-schema/functions/odk-formulas/evaluation/XPath\";\nimport AddFieldOrGroupMenuItem from \"./AddFieldMenuItem\";\nimport NodeActionMenuItems from \"./DetailsPopover/NodeActionMenuItems\";\nimport { FieldProps } from \"./FieldProps\";\nimport ObjectArrayField from \"./fields/ObjectArrayField\";\nimport ObjectField from \"./fields/ObjectField\";\nimport ValueField from \"./fields/ValueField\";\n\nconst Stripe = styled.div`\n  &:after {\n    content: \"\";\n    position: absolute;\n    left: 0px;\n    width: 1px;\n    bottom: 0;\n    top: 0;\n    background-color: transparent;\n  }\n`;\n\nconst CornerButton = styled.div`\n  position: absolute;\n  left: 0px;\n  height: 44px;\n  width: 44px;\n  background-color: transparent;\n  cursor: pointer;\n`;\n\nconst TopCornerButton = styled(CornerButton)`\n  top: 0;\n  &:hover {\n    background: linear-gradient(\n      135deg,\n      ${alpha(Colors.BLUE3, 0.1)},\n      ${alpha(Colors.BLUE3, 0.0)} 50%\n    );\n  }\n`;\n\nconst BottomCornerButton = styled(CornerButton)`\n  bottom: 0;\n  &:hover {\n    background: linear-gradient(\n      45deg,\n      ${alpha(Colors.BLUE3, 0.1)},\n      ${alpha(Colors.BLUE3, 0.0)} 50%\n    );\n  }\n`;\n\nconst Hoverable = styled.div`\n  padding: 16px 16px 8px;\n  margin: 0;\n  position: relative;\n\n  &:not(:hover):not(:focus-within) {\n    ${Stripe} {\n      background: none;\n    }\n  }\n  &:hover,\n  :focus-within {\n    background: ${alpha(Colors.BLUE3, 0.03)};\n\n    ${Stripe} {\n      &:after {\n        background: ${alpha(Colors.BLUE3, 0.1)};\n      }\n    }\n  }\n`;\n\nexport function FieldSetForKey(props: {\n  schemaKey: string;\n  relevant?: boolean;\n  readonly?: boolean;\n}) {\n  const { schemaKey } = props;\n  const {\n    schema,\n    context,\n    debug,\n    onNestNode,\n    onUngroupNode,\n  } = React.useContext(ODKSurveyContext);\n  const { alert, showRemoveConfirmationDialog } = useNodeDeletionDialog();\n  const { dialog: renameDialog, showRenameDialog } = useRenameNodeDialog();\n  if (!context || !schema) {\n    return null;\n  }\n  const quickType = schema.getQuickTypeForKey(schemaKey);\n  const schemaKeyPath = [\".\", ...schemaKey.replace(/\\.\\$/g, \"\").split(\".\")];\n\n  const node = findNodeByPathRelativeToScope(\n    schemaKeyPath,\n    context,\n    context.survey\n  );\n\n  if (node instanceof Array) {\n    if (!debug) {\n      return null;\n    }\n    return (\n      <Callout intent=\"warning\">\n        <H4>\n          Found multiple nodes with path <Code>{schemaKeyPath.join(\"/\")}</Code>.\n          This should not happen.\n        </H4>\n        {/* <p></p> */}\n      </Callout>\n    );\n  }\n  if (!node) {\n    if (!debug) {\n      return null;\n    }\n    return (\n      <Callout intent=\"warning\">\n        <H4>\n          No node found for{\" \"}\n          <Code>{schemaKeyPath[schemaKeyPath.length - 1]}</Code>\n        </H4>\n        {/* <p></p> */}\n      </Callout>\n    );\n  }\n\n  let relevant = props.relevant;\n  if (typeof relevant !== \"boolean\" || relevant === true) {\n    const evaluationResult = context.evaluationResults\n      .get(node)\n      ?.get(\"relevant\");\n\n    if (typeof evaluationResult?.result === \"boolean\") {\n      relevant = evaluationResult.result;\n    } else if (evaluationResult?.result === null) {\n      relevant = false;\n    } else {\n      relevant = true;\n    }\n  }\n\n  let readonly = false;\n  if (typeof props.readonly !== \"undefined\" || props.readonly === true) {\n    const evaluationResult = context.evaluationResults\n      .get(node)\n      ?.get(\"readonly\");\n    readonly =\n      typeof evaluationResult?.result === \"boolean\"\n        ? evaluationResult.result\n        : props.readonly;\n  }\n  // TODO: Add warning for evaluation failure\n\n  const fieldProps: FieldProps = {\n    schema,\n    node,\n    schemaKey,\n    quickType,\n    relevant,\n    readonly,\n  };\n\n  if (!debug && !relevant) {\n    return null;\n  }\n\n  let field;\n  switch (quickType) {\n    case \"object\":\n      field = <ObjectField {...fieldProps} />;\n      break;\n    case \"objectArray\":\n      field = <ObjectArrayField {...fieldProps} />;\n      break;\n    default:\n      field = <ValueField {...fieldProps} />;\n      break;\n  }\n\n  if (debug && node !== context.survey) {\n    const nodeActionMenuItems = (\n      <NodeActionMenuItems\n        node={node}\n        onRemove={showRemoveConfirmationDialog}\n        onRename={showRenameDialog}\n        onNestField={onNestNode}\n        onUngroupField={onUngroupNode}\n      />\n    );\n    const nodeActionMenu = <Menu>{nodeActionMenuItems}</Menu>;\n    return (\n      <>\n        {alert}\n        {renameDialog}\n        <ContextMenu2 content={nodeActionMenu}>\n          <Hoverable>\n            <Stripe />\n\n            <Popover2\n              content={\n                <ul className={Classes.LIST_UNSTYLED}>\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-up\"\n                    node={node}\n                    position=\"before\"\n                    group={false}\n                  />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-up\"\n                    node={node}\n                    position=\"before\"\n                    group={true}\n                  />\n                  <MenuDivider />\n                  <MenuItem text=\"Actions\" icon=\"more\">\n                    {nodeActionMenuItems}\n                  </MenuItem>\n                </ul>\n              }\n              lazy={true}\n              interactionKind=\"click\"\n              placement=\"left\"\n              renderTarget={({ isOpen, ref, ...targetProps }) => (\n                <TopCornerButton {...targetProps} ref={ref} />\n              )}\n              hoverOpenDelay={0}\n              hoverCloseDelay={0}\n            />\n\n            <Popover2\n              content={\n                <ul className={Classes.LIST_UNSTYLED}>\n                  <MenuItem text=\"Actions\" icon=\"more\">\n                    {nodeActionMenuItems}\n                  </MenuItem>\n                  <MenuDivider />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-down\"\n                    node={node}\n                    position=\"after\"\n                    group={false}\n                  />\n                  <AddFieldOrGroupMenuItem\n                    icon=\"arrow-down\"\n                    node={node}\n                    position=\"after\"\n                    group={true}\n                  />\n                </ul>\n              }\n              lazy={true}\n              interactionKind=\"click\"\n              placement=\"left\"\n              renderTarget={({ isOpen, ref, ...targetProps }) => (\n                <BottomCornerButton {...targetProps} ref={ref} />\n              )}\n              hoverOpenDelay={0}\n              hoverCloseDelay={0}\n            />\n\n            {field}\n          </Hoverable>\n        </ContextMenu2>\n      </>\n    );\n  }\n\n  return field;\n}\n","import { Callout } from \"@blueprintjs/core\";\nimport { Column, EditableCell, Table } from \"@blueprintjs/table\";\nimport { uniq } from \"lodash\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport OverflowScrollContainer from \"../components/OverflowScrollContainer\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { WorksheetName, XLSForm } from \"../xlsform-simple-schema\";\nimport { localizableColumnNames } from \"../xlsform-simple-schema/functions/loadSurveyFromXLSX\";\n\ntype Props = {\n  xlsForm: XLSForm;\n  language: string;\n  debug: boolean;\n  worksheetName: WorksheetName;\n  style?: React.CSSProperties;\n};\n\nconst FlexTable = styled(Table)`\n  /* flex: 1; */\n`;\n\nexport default function XLSFormWorksheet(props: Props) {\n  const { language, xlsForm, worksheetName } = props;\n  const context = React.useContext(ODKSurveyContext);\n  const { onChangeCell } = context;\n  const worksheet = xlsForm.worksheets[props.worksheetName];\n\n  const numRows = worksheet?.rows.length;\n  const columnNames = React.useMemo(\n    () =>\n      uniq(worksheet?.columnNamesNormalized.map((n) => n.replace(/::.*$/, \"\"))),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [xlsForm, worksheet]\n  );\n\n  const onConfirmCellEdit = React.useCallback(\n    (\n      value: string,\n      rowIndex?: number | undefined,\n      columnIndex?: number | undefined\n    ) => {\n      if (columnIndex === undefined || rowIndex === undefined) {\n        return;\n      }\n\n      const row = worksheet?.rows[rowIndex];\n      if (!row) {\n        throw new Error(\"Tried to change a row that doesn’t exist\");\n      }\n      const columnName = columnNames[columnIndex];\n      const oldValue = row[columnName];\n      if (oldValue === value) {\n        return;\n      }\n      onChangeCell(\n        worksheetName,\n        rowIndex,\n        columnName,\n        value,\n        xlsForm.flatNodes[rowIndex]\n      );\n    },\n    [\n      columnNames,\n      onChangeCell,\n      worksheet?.rows,\n      worksheetName,\n      xlsForm.flatNodes,\n    ]\n  );\n\n  const cellRenderer = React.useMemo(() => {\n    return (rowIndex: number, columnIndex: number) => {\n      const row = worksheet?.rows[rowIndex];\n      if (!row) {\n        return <></>;\n      }\n      const key = columnNames[columnIndex];\n      const value = row[key];\n      const node = xlsForm.flatNodes[rowIndex];\n\n      if (value !== undefined && typeof value !== \"string\") {\n        if (localizableColumnNames.includes(key)) {\n          return (\n            <EditableCell\n              {...{ rowIndex, columnIndex }}\n              onConfirm={onConfirmCellEdit}\n              value={value[language]}\n            />\n          );\n        } else {\n          return (\n            <EditableCell\n              {...{ rowIndex, columnIndex }}\n              onConfirm={onConfirmCellEdit}\n              value={JSON.stringify(value)}\n            />\n          );\n        }\n      }\n\n      return (\n        <EditableCell\n          {...{ rowIndex, columnIndex }}\n          onConfirm={onConfirmCellEdit}\n          value={value}\n          style={\n            [\"type\", \"name\"].includes(key)\n              ? { paddingLeft: `${4 + node?.indentationLevel * 8}px` }\n              : {}\n          }\n        >\n          {value}\n        </EditableCell>\n      );\n    };\n  }, [\n    worksheet?.rows,\n    columnNames,\n    xlsForm.flatNodes,\n    onConfirmCellEdit,\n    language,\n  ]);\n\n  if (!worksheet) {\n    return (\n      <Callout intent=\"warning\">No {props.worksheetName} sheet defined</Callout>\n    );\n  }\n\n  return (\n    <OverflowScrollContainer style={{ ...props.style }}>\n      <FlexTable\n        numRows={numRows}\n        enableRowResizing={false}\n        // numFrozenColumns={worksheetName === \"survey\" ? 2 : 0}\n      >\n        {columnNames.map((columnName) => (\n          <Column name={columnName} cellRenderer={cellRenderer} />\n        ))}\n      </FlexTable>\n    </OverflowScrollContainer>\n  );\n}\n","import { ODKNode } from '../../types/ODKNode';\nimport evaluateODKFormula from '../odk-formulas/evaluation/evaluateODKFormula';\nimport ODKFormulaEvaluationContext from '../odk-formulas/evaluation/ODKFormulaEvaluationContext';\n\nexport function getNodeOptionalFunction(node: ODKNode, context: ODKFormulaEvaluationContext) {\n  return function isNodeIrrelevantOrNotRequired() {\n    const isRelevant = node.row.relevant === undefined ||\n      node.row.relevant === '' ||\n      evaluateODKFormula(node.row.relevant, context, node);\n    if (!isRelevant) {\n      return true;\n    }\n    const isRequired = node.row.required === undefined ||\n      node.row.required === '' ||\n      evaluateODKFormula(node.row.required, context, node);\n      return !isRequired;\n    };\n}\n","import { ODKFormulaError } from \"../../types/Errors\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport evaluateExpression from \"../odk-formulas/evaluation/evaluateExpression\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { NameExpression, TokenType } from \"../odk-formulas/pratt-parser-base\";\n\nexport function getStringInterpolationFunctionOrString(\n  inputString: string,\n  context: ODKFormulaEvaluationContext,\n  node: ODKNode\n) {\n  const hasInterpolation = !!inputString.match(/\\${([^}]+)}/);\n  if (!hasInterpolation) {\n    return inputString;\n  }\n  return function getInterpolatedString(): string {\n    return inputString.replaceAll(\n      /\\${([^}]+)}/g,\n      (match, name, offset): string => {\n        try {\n          const text = match;\n          const result = evaluateExpression(\n            new NameExpression(\n              [{ type: TokenType.NAME, text, index: offset }],\n              name,\n              match\n            ),\n            context,\n            node\n          );\n          return String(result);\n        } catch (e) {\n          if (e instanceof ODKFormulaError) {\n            return e.toMarkdown();\n          }\n          throw e;\n        }\n      }\n    );\n  };\n}\n","import { SchemaDefinition } from \"simpl-schema\";\n\n/**\n * [GeoJSON](https://tools.ietf.org/html/rfc7946) `Point` object.\n */\nexport interface PointGeometry {\n  type: \"Point\";\n  coordinates: [number, number];\n}\n\nexport interface LineStringGeometry {\n  type: \"LineString\";\n  coordinates: [[number, number]];\n}\n\nexport interface PolygonGeometry {\n  type: \"Polygon\";\n  coordinates: [[[number, number]]];\n}\n\nexport const getPointGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  [`${key}.type`]: {\n    type: String,\n    allowedValues: [\"Point\"],\n    defaultValue: \"Point\",\n  },\n  [`${key}.coordinates`]: {\n    type: Array,\n    minCount: 2,\n    maxCount: 2,\n  },\n  [`${key}.coordinates.$`]: {\n    type: Number,\n    min: -180,\n    max: 180,\n  },\n});\n\nexport const getLineStringGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  [`${key}.type`]: {\n    type: String,\n    allowedValues: [\"LineString\"],\n    defaultValue: \"LineString\",\n  },\n  [`${key}.coordinates`]: {\n    type: Array,\n    minCount: 2,\n  },\n  [`${key}.coordinates.$`]: {\n    type: Array,\n    minCount: 2,\n    maxCount: 2,\n  },\n  [`${key}.coordinates.$.$`]: {\n    type: Number,\n    min: -180,\n    max: 180,\n  },\n});\n\nexport const getPolygonGeometrySchema = (\n  key: string\n): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n  },\n  type: {\n    type: String,\n    allowedValues: [\"Polygon\"],\n    defaultValue: \"Polygon\",\n  },\n  [`${key}.coordinates`]: {\n    // rings, outer rings first, holes in the outer ring from 2nd to n-th index\n    type: Array,\n    minCount: 1,\n  },\n  [`${key}.coordinates.$`]: {\n    type: Array,\n    minCount: 2,\n  },\n  [`${key}.coordinates.$.$`]: {\n    //\n    type: Array,\n    minCount: 4,\n    maxCount: 4,\n  },\n  [`${key}.coordinates.$.$.$`]: {\n    type: Number,\n    min: -180,\n    max: 180,\n  },\n});\n\nexport type Geometry = PointGeometry | LineStringGeometry | PolygonGeometry;\n","import SimpleSchema, { SchemaDefinition } from 'simpl-schema';\n\n/**\n * Inspired from https://schema.org/QuantitativeValue\n */\n\nexport const getQuantitativeValueSchema = (key: string, rootDefinition?: SchemaDefinition<unknown>): Record<string, SchemaDefinition<unknown>> => ({\n  [key]: {\n    type: Object,\n    ...rootDefinition\n  },\n  [`${key}.maxValue`]: {\n    type: Number,\n    optional: true,\n  },\n  [`${key}.minValue`]: {\n    type: Number,\n    optional: true,\n  },\n  [`${key}.unitCode`]: {\n    type: Text,\n    optional: true,\n  },\n  [`${key}.unitText`]: {\n    type: Text,\n    optional: true,\n  },\n  [`${key}.value`]: {\n    type: SimpleSchema.oneOf(Number, String, Boolean),\n  },\n});\n","import SimpleSchema, { SchemaDefinition } from 'simpl-schema';\nimport { getQuantitativeValueSchema } from './getQuantitativeValueSchema';\n\n/**\n * Inspired from https://schema.org/MediaObject\n */\n\nexport const getMediaObjectSchema = (key: string, rootDefinition?: Partial<SchemaDefinition<unknown>>): Record<string, SchemaDefinition<unknown>> => ({\n    [key]: {\n      type: Object,\n      ...rootDefinition\n    },\n    [`${key}.bitrate`]: {\n      type: String,\n      label: 'The bitrate of the media object.',\n      optional: true,\n    },\n    [`${key}.contentSize`]: {\n      type: String,\n      label: 'File size in (mega/kilo) bytes.',\n    },\n    [`${key}.contentUrl`]: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Url,\n      label: 'Actual bytes of the media object, for example the image file or video file.',\n    },\n    [`${key}.duration`]: {\n      type: String,\n      label:\n        'The duration of the item (movie, audio recording, event, etc.) in ISO 8601 date format.',\n      optional: true,\n    },\n    [`${key}.embedUrl`]: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Url,\n      label:\n        'A URL pointing to a player for a specific video. In general, this is the information in the src element of an embed tag and should not be the same as the content of the loc tag.',\n      optional: true,\n    },\n    [`${key}.encodingFormat`]: {\n      type: String,\n      label:\n        'Media type typically expressed using a MIME format (see IANA site and MDN reference) e.g. application/zip for a SoftwareApplication binary, audio/mpeg for .mp3 etc.).',\n    },\n    [`${key}.endTime`]: {\n      type: Date,\n      label: 'the time offset of the end of a clip within a larger file.',\n      optional: true,\n    },\n    [`${key}.startTime`]: {\n      type: Date,\n      label: 'the time offset of the start of a clip within a larger file.',\n      optional: true,\n    },\n    [`${key}.uploadDate`]: {\n      type: Date,\n      label: 'Date when this media object was uploaded to this site.',\n      optional: true,\n    },\n    ...getQuantitativeValueSchema(`${key}.height`, {\n      type: SimpleSchema.oneOf(String, Object),\n      label: 'The height of the item.',\n    }),\n    ...getQuantitativeValueSchema(`${key}.width`, {\n      type: SimpleSchema.oneOf(String, Object),\n      label: 'The width of the item.',\n    }),\n  });\n\nexport const getAudioObjectSchema = (key: string, rootDefinition?: Partial<SchemaDefinition<unknown>>): Record<string, SchemaDefinition<unknown>> => ({\n    [key]: {\n      type: Object,\n      ...rootDefinition\n    },\n    [`${key}.transcript`]: {\n      type: String,\n      optional: true,\n    },\n    ...getMediaObjectSchema(`${key}.caption`, {\n      type: SimpleSchema.oneOf(String, Object),\n      label:\n        'The caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.',\n      optional: true,\n    }),\n  });\n\nexport const getImageObjectSchema = (key: string, withThumbnail = true, rootDefinition?: Partial<SchemaDefinition<unknown>>): Record<string, SchemaDefinition<unknown>> => ({\n    [key]: {\n      type: Object,\n      ...rootDefinition\n    },\n    [`${key}.exifData`]: {\n      type: Object,\n      blackbox: true,\n      label: ' or Text\texif data for this object.',\n      optional: true,\n    },\n    [`${key}.representativeOfPage`]: {\n      type: Boolean,\n      label: 'Indicates whether this image is representative of the content of the page.',\n      optional: true,\n    },\n    ...getMediaObjectSchema(`${key}.caption`, {\n    label:\n      'The caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.',\n      optional: true,\n    }),\n    ...(withThumbnail ?\n      getImageObjectSchema(`${key}.thumbnail`, false, { label: 'Thumbnail image for an image or video.', optional: true }) : {})\n});\n\nexport const getVideoObjectSchema = (key: string, rootDefinition?: Partial<SchemaDefinition<unknown>>): Record<string, SchemaDefinition<unknown>> => ({\n    [key]: {\n      type: Object,\n      ...rootDefinition\n    },\n    [`${key}.caption`]: {\n      type: getMediaObjectSchema(`${key}.caption`),\n      label:\n        ' or Text\tThe caption for this object. For downloadable machine formats (closed caption, subtitles etc.) use MediaObject and indicate the encodingFormat.',\n      optional: true,\n    },\n    [`${key}.transcript`]: {\n      type: String,\n      label: 'If this MediaObject is an AudioObject or VideoObject, the transcript of that object.',\n      optional: true,\n    },\n    [`${key}.videoFrameSize`]: {\n      type: String,\n      label: 'The frame size of the video.',\n      optional: true,\n    },\n    [`${key}.videoQuality`]: {\n      type: String,\n      optional: true,\n    },\n    ...getImageObjectSchema(`${key}.thumbnail`, true, {\n      label: 'Thumbnail image for an image or video.',\n      optional: true,\n    }),\n  });\n","import { compact } from \"lodash\";\nimport { SemanticError } from \"../../types/Errors\";\nimport { NodeToDefinitionFunctionOptions } from \"./createLeafNodeSchemaDefinition\";\nimport { evaluateDynamicChoiceListName } from \"./evaluateDynamicChoiceListName\";\nimport { evaluateFilteredChoiceNames } from \"./evaluateFilteredChoiceNames\";\n\nexport default function getAllowedChoiceValues(\n  options: NodeToDefinitionFunctionOptions\n): string[] | (() => string[]) {\n  const choiceListStrings = options.node.typeParameters;\n  const availableListNames = Object.keys(options.xlsForm.choicesByName);\n  const { type } = options.node.row;\n  const firstList = availableListNames[0];\n  const hasAvailableChoiceList = firstList !== undefined;\n  if (!hasAvailableChoiceList) {\n    throw new SemanticError(\n      `Node \\`${options.key}\\` uses \\`${type}\\` as its \\`type\\`, but the ‘choices’ worksheet seems to be empty or invalid. Please define some valid choice lists first.`\n    );\n  }\n\n  const { choicesByName } = options.xlsForm;\n\n  let choiceListNames = compact(\n    choiceListStrings.map((choiceListString) => {\n      if (choiceListString.trim().startsWith(\"$\")) {\n        return evaluateDynamicChoiceListName(\n          choiceListString,\n          options,\n          choicesByName\n        );\n      } else {\n        return choiceListString;\n      }\n    })\n  ).filter((n) => n !== undefined && n !== \"\");\n\n  // const hasDefinedChoiceListName = choiceListNames.length > 0;\n  // if (!hasDefinedChoiceListName) {\n  //   const possibleStrings = availableListNames\n  //     .map((cl) => `- \\`${type} ${cl}\\``)\n  //     .join(\"\\n\");\n  //   throw new SemanticError(\n  //     `Node \\`${options.key}\\` is missing a reference to the set of possible answer choices. Its \\`type\\` cell contains \\`${type}\\`, but it should be one of these:\\n\\n${possibleStrings}`\n  //   );\n  // }\n\n  const choiceObjects = choiceListNames\n    .map((n) => choicesByName[n])\n    .filter((o) => o !== undefined);\n  if (choiceObjects.length !== choiceListNames.length) {\n    throw new SemanticError(\n      `Node \\`${options.key}\\` (row #${\n        options.node.rowIndex + 2\n      }) refers to list names \\`${choiceListNames}\\`. One of these lists is either not defined in the ‘choices’ worksheet, or could not be loaded correctly. Found list names:\\n\\n${availableListNames\n        .map((n) => `\\`${n}\\``)\n        .join(\", \")}`\n    );\n  }\n\n  const choiceFilterString = options.node.row.choice_filter?.trim();\n  if (!choiceFilterString || choiceFilterString === \"\") {\n    return choiceObjects.flatMap((choiceObject) => Object.keys(choiceObject));\n  }\n\n  return evaluateFilteredChoiceNames(\n    choiceFilterString,\n    choiceObjects,\n    options.node,\n    options.context\n  );\n}\n","import { EvaluationError } from \"../../types/Errors\";\nimport { ChoiceRow } from \"../../types/RowTypes\";\nimport evaluateODKFormula from \"../odk-formulas/evaluation/evaluateODKFormula\";\nimport { NodeToDefinitionFunctionOptions } from \"./createLeafNodeSchemaDefinition\";\n\nexport function evaluateDynamicChoiceListName(\n  choiceListString: string,\n  options: NodeToDefinitionFunctionOptions,\n  choicesByName: Record<string, Record<string, ChoiceRow>>\n) {\n  const evaluationResult = evaluateODKFormula(\n    choiceListString,\n    options.context,\n    options.node\n  );\n  if (evaluationResult.state === \"error\") {\n    throw new EvaluationError(\n      `Error evaluating \\`${choiceListString}\\` to determine available selection choices.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  if (typeof evaluationResult.result !== \"string\") {\n    throw new EvaluationError(\n      `Evaluating \\`${choiceListString}\\` did not yield a \\`string\\`. Please ensure the referenced field returns a string.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  const choiceListName = evaluationResult.result;\n  if (!choicesByName[choiceListName]) {\n    throw new EvaluationError(\n      `Evaluating \\`${choiceListString}\\` yielded string \\`'${choiceListName}'\\`, but the according choices list does not exist. Please ensure that the field calculates an existing list name.`,\n      \"invalidDynamicChoices\",\n      evaluationResult.expression,\n      options.context,\n      options.node\n    );\n  }\n  return choiceListName;\n}\n","import { EvaluationError } from \"../../types/Errors\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { ChoiceRow } from \"../../types/RowTypes\";\nimport evaluateExpression from \"../odk-formulas/evaluation/evaluateExpression\";\nimport ODKFormulaEvaluationContext, {\n  knownLiteralsWithoutDollarSign,\n} from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport ODKFormulaLexer from \"../odk-formulas/odk-formula-parser/ODKFormulaLexer\";\nimport ODKFormulaParser from \"../odk-formulas/odk-formula-parser/ODKFormulaParser\";\nimport { Expression } from \"../odk-formulas/pratt-parser-base\";\n\nexport function evaluateFilteredChoiceNames(\n  choiceFilterString: string,\n  choiceObjects: Record<string, ChoiceRow>[],\n  node: ODKNode,\n  context: ODKFormulaEvaluationContext\n) {\n  const lexer = new ODKFormulaLexer(choiceFilterString);\n  const parser = new ODKFormulaParser({ tokens: lexer });\n  const choiceFilterExpression: Expression = parser.parseExpression();\n  const result = function filteredChoiceValues() {\n    return choiceObjects\n      .flatMap((choiceObject) => Object.values(choiceObject))\n      .filter((choiceRow) => {\n        const evalResult = evaluateExpression(\n          choiceFilterExpression,\n          {\n            ...context,\n            evaluateNonDollarNameFn: (options) =>\n              choiceRow[options.expression.name] ||\n              knownLiteralsWithoutDollarSign[options.expression.name],\n          },\n          node\n        );\n        if (typeof evalResult !== \"boolean\") {\n          throw new EvaluationError(\n            `\\`choice_filter\\` formula did not evaluate to a \\`boolean\\`. Please ensure the formula returns a \\`boolean\\`.`,\n            \"invalidDynamicChoices\",\n            choiceFilterExpression,\n            context,\n            node\n          );\n        }\n        return evalResult;\n      })\n      .map((choiceRow) => choiceRow.name);\n  };\n  return result;\n}\n","import SimpleSchema from \"simpl-schema\";\nimport {\n  getLineStringGeometrySchema,\n  getPointGeometrySchema,\n  getPolygonGeometrySchema,\n} from \"./Geometry\";\nimport {\n  getAudioObjectSchema,\n  getImageObjectSchema,\n  getMediaObjectSchema,\n  getVideoObjectSchema,\n} from \"./MediaSchemas\";\nimport getAllowedChoiceValues from \"./getAllowedChoiceValues\";\nimport { NodeToDefinitionFunction } from \"./createLeafNodeSchemaDefinition\";\n\nexport const questionTypesToSchemaGenerators: Record<\n  string,\n  NodeToDefinitionFunction<unknown> | undefined\n> = {\n  \"\": () => ({}),\n  integer: (o) => ({ [o.key]: { type: SimpleSchema.Integer } }),\n  decimal: (o) => ({ [o.key]: { type: Number } }),\n  range: (o) => ({ [o.key]: { type: Number } }),\n  text: (o) => ({ [o.key]: { type: String } }),\n  select_one: (o) => ({\n    [o.key]: { type: String, allowedValues: getAllowedChoiceValues(o) },\n  }),\n  select_multiple: (o) => ({\n    [o.key]: { type: Array },\n    [o.key + \".$\"]: { type: String, allowedValues: getAllowedChoiceValues(o) },\n  }),\n  select_one_from_file: (o) => ({ [o.key]: { type: String } }),\n  select_multiple_from_file: (o) => ({\n    [o.key]: { type: Array },\n    [o.key + \".$\"]: { type: String },\n  }),\n  rank: (o) => ({ [o.key]: { type: String } }),\n  note: (o) => ({ [o.key]: { type: String } }),\n  geopoint: (o) => getPointGeometrySchema(o.key),\n  geotrace: (o) => getLineStringGeometrySchema(o.key),\n  geoshape: (o) => getPolygonGeometrySchema(o.key),\n  date: (o) => ({ [o.key]: { type: Date } }),\n  time: (o) => ({ [o.key]: { type: Date } }),\n  datetime: (o) => ({ [o.key]: { type: Date } }),\n  image: (o) => getImageObjectSchema(o.key),\n  audio: (o) => getAudioObjectSchema(o.key),\n  video: (o) => getVideoObjectSchema(o.key),\n  file: (o) => getMediaObjectSchema(o.key),\n  barcode: (o) => ({ [o.key]: { type: String } }),\n  calculate: (o) => ({ [o.key]: { type: String } }),\n  acknowledge: (o) => ({ [o.key]: { type: Boolean } }),\n  hidden: (o) => ({ [o.key]: { type: String } }),\n  \"xml-external\": (o) => ({ [o.key]: { type: String } }),\n  start: (o) => ({ [o.key]: { type: Date } }),\n  end: (o) => ({ [o.key]: { type: Date } }),\n  today: (o) => ({ [o.key]: { type: Date } }),\n  deviceid: (o) => ({ [o.key]: { type: String } }),\n  simserial: (o) => ({ [o.key]: { type: String } }),\n  subscriberid: (o) => ({ [o.key]: { type: String } }),\n  phonenumber: (o) => ({ [o.key]: { type: String } }),\n  username: (o) => ({ [o.key]: { type: String } }),\n  email: (o) => ({\n    [o.key]: { type: String, regEx: SimpleSchema.RegEx.EmailWithTLD },\n  }),\n  audit: (o) => ({ [o.key]: { type: String } }),\n};\n","import { SchemaDefinition } from \"simpl-schema\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport createLeafNodeSchemaDefinition from \"./createLeafNodeSchemaDefinition\";\nimport { getNodeOptionalFunction } from \"./getNodeOptionalFunction\";\nimport { getStringInterpolationFunctionOrString } from \"./getStringInterpolationFunctionOrString\";\n\nexport default function createRecursiveNodeSchemaDefinition(options: {\n  node: ODKNode;\n  language: string;\n  xlsForm: XLSForm;\n  context: ODKFormulaEvaluationContext;\n  key: string;\n}): Record<string, SchemaDefinition<unknown>> {\n  const { node, language, xlsForm, context, key } = options;\n  let schemaDefinitions: Record<string, SchemaDefinition<unknown>>;\n  const labelString = node.row.label?.[language] || \"\";\n  const definition: Pick<SchemaDefinition<unknown>, \"label\" | \"optional\"> = {\n    label: getStringInterpolationFunctionOrString(labelString, context, node),\n    optional: getNodeOptionalFunction(node, context),\n  };\n  if (node.row?.type.match(/^begin_repeat$/)) {\n    // We're in a repeated section\n    const childrenSchemaDefinitions = node.children.map((child) =>\n      createRecursiveNodeSchemaDefinition({\n        ...options,\n        node: child,\n        key: key + \".$.\" + child.row.name,\n      })\n    );\n    schemaDefinitions = Object.assign(\n      { [key]: { ...definition, type: Array } },\n      ...childrenSchemaDefinitions\n    );\n  } else if (\n    node.row.type.match(/^begin_group$/) ||\n    node === xlsForm.rootSurveyGroup\n  ) {\n    // We're in a group section or in the root (a special case that has children, but is not of `begin_group` type)\n    const childrenSchemaDefinitions = node.children.map((child) => {\n      if (!child.row) {\n        debugger;\n      }\n      return createRecursiveNodeSchemaDefinition({\n        ...options,\n        node: child,\n        key: key + \".\" + child.row.name,\n      });\n    });\n\n    schemaDefinitions = Object.assign(\n      { [key]: { ...definition, type: Object } },\n      ...childrenSchemaDefinitions\n    );\n  } else {\n    schemaDefinitions = createLeafNodeSchemaDefinition(\n      node,\n      language,\n      xlsForm,\n      context,\n      key\n    );\n  }\n\n  // console.log(`Schema for key \\`${key}\\`:`, schemaDefinitions);\n  return schemaDefinitions;\n}\n","import { SchemaDefinition } from \"simpl-schema\";\nimport { ODKNode } from \"../../types/ODKNode\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport { getNodeOptionalFunction } from \"./getNodeOptionalFunction\";\nimport { getStringInterpolationFunctionOrString } from \"./getStringInterpolationFunctionOrString\";\nimport { questionTypesToSchemaGenerators } from \"./questionTypesToSchemaGenerators\";\n\nexport type NodeToDefinitionFunctionOptions = {\n  key: string;\n  node: ODKNode;\n  xlsForm: XLSForm;\n  context: ODKFormulaEvaluationContext;\n};\n\nexport type NodeToDefinitionFunction<T> = (\n  options: NodeToDefinitionFunctionOptions\n) => Record<string, SchemaDefinition<T>>;\n\nexport default function createLeafNodeSchemaDefinition(\n  node: ODKNode,\n  language: string,\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext,\n  key: string\n): Record<string, SchemaDefinition<unknown>> {\n  const { row } = node;\n\n  if (!row) {\n    throw new Error(\"Node needs an associated row for creating a schema.\");\n  }\n\n  const labelString = row.label?.[language] || \"\";\n  const defaults = {\n    type: String,\n    label: getStringInterpolationFunctionOrString(labelString, context, node),\n    optional: getNodeOptionalFunction(node, context),\n  };\n\n  const schemaGeneratorFunction = questionTypesToSchemaGenerators[node.type];\n  if (!schemaGeneratorFunction) {\n    throw new Error(\n      `Could not find schema generator for node type ${JSON.stringify(row)}`\n    );\n  }\n  const schema = schemaGeneratorFunction({ key, node, xlsForm, context });\n  const firstField = schema[Object.keys(schema)[0]];\n  Object.assign(firstField, defaults, { ...firstField });\n  // console.log('Schema for node', JSON.stringify(node.row.name), ':', schema);\n  return schema;\n}\n","import {\n  Alignment,\n  Button,\n  FocusStyleManager,\n  Navbar,\n  NonIdealState,\n  Switch,\n} from \"@blueprintjs/core\";\nimport * as ExcelJS from \"exceljs\";\nimport React, { FormEvent } from \"react\";\nimport styled from \"styled-components\";\nimport \"./App.css\";\nimport ResultCodeTree from \"./code/ResultCodeTree\";\nimport ExcelFileInput from \"./components/ExcelFileInput\";\nimport LanguageSelector from \"./components/LanguageSelector\";\nimport OverflowScrollContainer from \"./components/OverflowScrollContainer\";\nimport { ODKSurveyContext } from \"./lib/ODKSurveyContext\";\nimport useChangeHooks from \"./lib/useChangeHooks\";\nimport { SheetTabs } from \"./SheetTabs\";\nimport { ODKNodeDragAndDropContext } from \"./survey/useNodeDragAndDrop\";\nimport XLSFormSurvey from \"./survey/XLSFormSurvey\";\nimport XLSFormWorksheet from \"./table/XLSFormWorksheet\";\nimport { loadFormFromExcelWorkbook } from \"./xlsform-simple-schema/functions/loadSurveyFromXLSX\";\nimport { createSurveySchemaFromXLSForm } from \"./xlsform-simple-schema/functions/schema-creation/createSurveySchemaFromXLSForm\";\nimport { WorksheetName, XLSForm } from \"./xlsform-simple-schema/index\";\n\nFocusStyleManager.onlyShowFocusOnTabs();\n\nconst StyledXLSFormSurvey = styled(XLSFormSurvey)`\n  max-width: 800px;\n  margin: auto;\n\n  font-size: 20px;\n  .bp3-small {\n    font-size: 16px;\n  }\n\n  .bp3-large {\n    font-size: 20px;\n  }\n\n  .bp3-form-helper-text {\n    font-size: 16px;\n  }\n\n  .bp3-form-group {\n    margin: 0 0 40px;\n  }\n\n  .bp3-control {\n    margin-bottom: 10px;\n  }\n`;\n\nconst AppBody = styled.div`\n  flex: 1;\n  overflow: hidden;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\n\nfunction NavbarSwitch(props: {\n  checked: boolean;\n  onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n  label: string;\n}) {\n  return (\n    <Switch\n      checked={props.checked}\n      label={props.label}\n      onChange={props.onChange}\n      inline={true}\n      style={{ marginBottom: \"0\" }}\n    />\n  );\n}\n\nfunction App() {\n  const [xlsForm, setXLSForm] = React.useState<XLSForm>();\n  const [language, setLanguage] = React.useState<string>();\n  const [debug, setDebug] = React.useState<boolean>(true);\n  const [showTable, setShowTable] = React.useState<boolean>(false);\n  const [showResult, setShowResult] = React.useState<boolean>(false);\n  const [worksheetName, setWorksheetName] = React.useState<WorksheetName>(\n    \"survey\"\n  );\n\n  const onLoadWorkbook = React.useCallback(\n    async (workbook: ExcelJS.Workbook) => {\n      const xlsForm = await loadFormFromExcelWorkbook(workbook);\n      setXLSForm(xlsForm);\n      setLanguage(\n        xlsForm.worksheets.settings?.rows[0].default_language ||\n          [...xlsForm.languages?.values()][0] ||\n          \"English (en)\"\n      );\n    },\n    []\n  );\n\n  const onDebugChange = React.useCallback(\n    (event: FormEvent<HTMLInputElement>) => {\n      setDebug(!event.currentTarget.checked);\n    },\n    []\n  );\n\n  const onShowTableChange = React.useCallback(\n    (event: FormEvent<HTMLInputElement>) => {\n      setShowTable(event.currentTarget.checked);\n    },\n    []\n  );\n\n  const onShowResultChange = React.useCallback(\n    (event: FormEvent<HTMLInputElement>) => {\n      setShowResult(event.currentTarget.checked);\n    },\n    []\n  );\n\n  const fileInput = <ExcelFileInput onLoadWorkbook={onLoadWorkbook} />;\n\n  const reset = React.useCallback(() => {\n    setXLSForm(undefined);\n  }, []);\n\n  const resetButton = (\n    <Button className=\"bp3-minimal\" icon=\"reset\" text=\"Reset\" onClick={reset} />\n  );\n\n  const resultCodeElement = xlsForm && (\n    <OverflowScrollContainer\n      className={\"bp3-code-block\"}\n      style={{ padding: \"1rem\", margin: \"0\", whiteSpace: \"pre\" }}\n    >\n      <ResultCodeTree {...{ xlsForm }} />\n    </OverflowScrollContainer>\n  );\n\n  const changeHooks = useChangeHooks({\n    language,\n    xlsForm,\n    setXLSForm,\n  });\n\n  const { context } = changeHooks;\n  const [, languageName, languageCode] =\n    language?.match(/^(.*) \\((\\w+)\\)$/) || [];\n\n  const schema = React.useMemo(() => {\n    if (xlsForm && language && context) {\n      return createSurveySchemaFromXLSForm(xlsForm, context, language);\n    }\n    return undefined;\n  }, [xlsForm, language, context]);\n\n  return (\n    <ODKNodeDragAndDropContext.Provider\n      value={{ onDropNode: changeHooks.onMoveNode }}\n    >\n      <ODKSurveyContext.Provider\n        value={{\n          schema,\n          language,\n          languageCode,\n          languageName,\n          debug,\n          xlsForm,\n          ...changeHooks,\n        }}\n      >\n        {xlsForm && (\n          <Navbar>\n            {showTable && (\n              <SheetTabs {...{ setWorksheetName, worksheetName }} />\n            )}\n\n            <Navbar.Group align={Alignment.RIGHT}>\n              {resetButton}\n              <Navbar.Divider />\n              <NavbarSwitch\n                checked={showTable === true}\n                label=\"Table\"\n                onChange={onShowTableChange}\n              />\n              <NavbarSwitch\n                checked={debug === false}\n                label=\"Live View\"\n                onChange={onDebugChange}\n              />\n              <NavbarSwitch\n                checked={showResult === true}\n                label=\"JSON\"\n                onChange={onShowResultChange}\n              />\n              <Navbar.Divider />\n              {xlsForm && language && (\n                <LanguageSelector\n                  languages={Array.from(xlsForm.languages.values())}\n                  language={language}\n                  onChange={setLanguage}\n                />\n              )}\n            </Navbar.Group>\n          </Navbar>\n        )}\n\n        <AppBody>\n          {!xlsForm && (\n            <OverflowScrollContainer>\n              <NonIdealState\n                icon=\"document-open\"\n                title=\"Open an XLSForm Excel file to start.\"\n                action={fileInput}\n              />\n            </OverflowScrollContainer>\n          )}\n          {xlsForm && language && showTable && (\n            <XLSFormWorksheet\n              xlsForm={xlsForm}\n              language={language}\n              debug={debug}\n              style={{ width: \"50%\" }}\n              worksheetName={worksheetName}\n            />\n          )}\n          {xlsForm && language && (\n            <OverflowScrollContainer\n              style={{ boxShadow: \"0 0px 30px #9fb7c2\", zIndex: 1 }}\n            >\n              <StyledXLSFormSurvey\n                xlsForm={xlsForm}\n                language={language}\n                debug={debug}\n              />\n            </OverflowScrollContainer>\n          )}\n          {xlsForm && language && showResult && resultCodeElement}\n        </AppBody>\n      </ODKSurveyContext.Provider>\n    </ODKNodeDragAndDropContext.Provider>\n  );\n}\n\nexport default App;\n","import * as React from \"react\";\nimport PaddedContainer from \"../components/PaddedContainer\";\nimport { ODKSurveyContext } from \"../lib/ODKSurveyContext\";\nimport { XLSForm } from \"../xlsform-simple-schema\";\nimport { FieldSetForKey } from \"./FieldSetForKey\";\n\nexport default function XLSFormSurvey(props: {\n  xlsForm: XLSForm;\n  language: string;\n  debug: boolean;\n  className?: string;\n}) {\n  const { schema, languageCode, debug } = React.useContext(ODKSurveyContext);\n\n  const fieldSets = schema\n    ?.objectKeys()\n    .map((k) => <FieldSetForKey key={k} schemaKey={k} />);\n\n  return (\n    <PaddedContainer\n      horizontal={2}\n      vertical={2}\n      className={props.className}\n      style={{\n        maxWidth: debug ? \"60rem\" : \"50rem\",\n        padding: \"4rem\",\n        margin: \"auto\",\n      }}\n      lang={languageCode}\n    >\n      <form>{fieldSets}</form>\n    </PaddedContainer>\n  );\n}\n","import SimpleSchema from \"simpl-schema\";\nimport { XLSForm } from \"../../types/XLSForm\";\nimport ODKFormulaEvaluationContext from \"../odk-formulas/evaluation/ODKFormulaEvaluationContext\";\nimport createRecursiveNodeSchemaDefinition from \"./createRecursiveNodeSchemaDefinition\";\n\nexport function createSurveySchemaFromXLSForm(\n  xlsForm: XLSForm,\n  context: ODKFormulaEvaluationContext,\n  language: string\n): SimpleSchema {\n  const schemaDefinition = createRecursiveNodeSchemaDefinition({\n    node: xlsForm.rootSurveyGroup,\n    xlsForm,\n    context,\n    language,\n    key: xlsForm.rootSurveyGroup.row.name,\n  });\n\n  const schema = new SimpleSchema(\n    new SimpleSchema(schemaDefinition).mergedSchema()\n  );\n\n  return schema;\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { enableAllPlugins, enablePatches } from \"immer\";\n\nenableAllPlugins();\nenablePatches();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}